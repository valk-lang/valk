
use ext
use core
use coro
use mem
use gc
use type
use io

global current_coro : ?Coro
global g_coros : Array[?Coro] (.new(16))
global g_coro_indexes : type:Pool[uint] (.new(16))
global g_coro_count : uint
global run_coros : Array[Coro] (.new(16))
global next_coros : Array[Coro] (.new(16))

global main_state : <CoroState> (@undefined)

#if OS == macos
global timer_id : uint
#end

#if OS == win
global cport : ?ptr
#end

struct CoroState {
    rsp: ptr
}
class Coro {
    // Args & results
    args: ptr
    gc_args: Array[gc:GcPtr] (.{})
    // Coro state
    state: <CoroState> (@undefined)
    // Stack info
    backup_main_stack: ptr (@undefined)
    backup_main_stack_size: uint (0)
    backup_main_stack_alloc_size: uint (0)
    backup_gc_stack: ptr (@undefined)
    backup_gc_stack_size: uint (0)
    backup_gc_stack_alloc_size: uint (0)
    backup_gc_sp: ptr (@undefined)
    stack_base: ptr (@undefined)
    gc_stack_base: ptr (@undefined)
    //
    start_func: fnptr()()
    handler: fnptr()()
    follow_up: ?Coro
    g_list_index: uint (0)
    // Error result
    error_code: u32 (0)
    error_msg: String ("")
    // async results
    poll_event: io:PollEvent (0)
    completion_res: i64 (0)
    //
    started: bool (false)
    active: bool (false)
    freed: bool (false)
    done: bool (false)

    static fn new(handler: ptr, start_func: ptr) SELF {

        let coro = Coro {
            args: mem:alloc(128)
            //
            start_func: start_func.@cast(fnptr()())
            handler: handler.@cast(fnptr()())
        }

        let indexes = g_coro_indexes
        if indexes.count == 0 {
            let index = g_coros.length
            g_coros.append(coro)
            coro.g_list_index = index
        } else {
            let index = indexes.get() !? 0
            g_coros.set(index, coro) _
            coro.g_list_index = index
        }

        run_coros.append(coro)

        g_coro_count++

        return coro
    }

    fn gc_free() {
        this.free_stacks()
        mem:free(this.args)
    }

    fn free_stacks() {
        if this.freed : return
        this.freed = true
        if this.backup_main_stack_alloc_size > 0 {
            mem:free(this.backup_main_stack)
        }
        if this.backup_gc_stack_alloc_size > 0 {
            mem:free(this.backup_gc_stack)
        }
    }

    fn init_stack(base: ptr) {

        #if ARCH == x64
        let return_addr_space = 2 * size_of(ptr)
        #if OS == win
        let regs = 30
        #else
        let regs = 6
        #end
        #elif ARCH == arm64
        let return_addr_space = size_of(ptr)
        let regs = 19
        #else
        #error "Unsupported OS: coroutines"
        #end

        let stack_start = base - (regs * size_of(ptr)) - return_addr_space
        // Make sure stack is 16 byte aligned (ptr size)
        stack_start = stack_start - (stack_start & 0xF)

        mem:clear(stack_start, regs * size_of(ptr)) // Required for windows

        @ptrv(stack_start, ptr, regs) = this.start_func
        this.state.rsp = stack_start
    }

    //////////////
    // AWAIT
    //////////////

    fn await_coro(coro: Coro) {
        if coro.done : return
        let ob = coro
        let ref = ob.follow_up
        while isset(ref) {
            ob = ref
            ref = ref.follow_up
        }
        ob.follow_up = this
        this.yield()
    }

    fn sleep(ns: uint) {
        #if OS == linux
        let sqe = io:sqe(this) ! return
        let nsec = ns.@cast(int)
        let ts : <io:kernel_timespec> = {
            tv_sec: nsec / 1000000000
            tv_nsec: (nsec % 1000000000)
        }
        io:io_uring_prep_timeout(sqe, @stableRef(ts), 0, 0)

        #elif OS == macos
        let ms = ns.to(i64) / 1000000
        let ev : <ext:kEvent> = @undefined
        io:EV_SET(@ref(ev), timer_id++, io:EVFILT_TIMER, io:EV_ADD | io:EV_ENABLE | io:EV_ONESHOT, 0, ms, this)
        let kq = io:kqueue()
        ext:kevent(kq, @ref(ev), 1, null, 0, null)

        #else
        let timer = ext:CreateWaitableTimerExW(null, null, 0, ext:TIMER_ALL_ACCESS)
        if timer == 0 : return

        let due : i64 = (ns.to(int) / 100) * -1
        let ok = ext:SetWaitableTimer(timer, &due, 0, null, null, false)
        if !ok {
            ext:CloseHandle(timer)
            return
        }

        let wcp : ext:HANDLE = 0
        let status = ext:NtCreateWaitCompletionPacket(&wcp, ext:MAXIMUM_ALLOWED, null)
        if status != 0 {
            ext:CloseHandle(timer)
            return
        }

        let ov = io:overlap[io:OverlapData]

        let sig : bool = false
        status = ext:NtAssociateWaitCompletionPacket(wcp, io:iocp(), timer, null, ov, ext:STATUS_SUCCESS, 0, &sig)
        if status != 0 {
            ext:CloseHandle(timer)
            return
        }

        #end
        this.yield()
    }

    fn await_last() {
        next_coros.append(this)
        this.yield()
    }

    //////////////
    // FLOW
    //////////////

    fn yield() $undefined {
        SELF.swap(@ref(this.state), @ref(main_state))
    }

    static fn swap(from: ptr, to: ptr) $undefined {
        ext:valk_stack_swap(from, to)
    }

    fn resume() $undefined {
        if this.done : return

        let v = 0
        current_coro = this

        // Set stack base
        let sp = @ref(main_stack).@cast(ptr) + STACK_SIZE - size_of(ptr)
        gc_stack_sp_backup = gc_stack_sp
        this.active = true

        if this.started {
            if this.stack_base != sp : panic("Resuming coroutine from another stack position (SP)")
            if this.gc_stack_base != gc_stack_sp : panic("Resuming coroutine from another stack position (GC)")
            // Restore stack
            if this.backup_main_stack_size > 0 {
                mem:copy(this.backup_main_stack, this.state.rsp, this.backup_main_stack_size)
            }
            if this.backup_gc_stack_size > 0 {
                mem:copy(this.backup_gc_stack, this.gc_stack_base, this.backup_gc_stack_size)
            }
            gc_stack_sp = this.backup_gc_sp
        } else {
            // Init stack
            this.stack_base = sp
            this.gc_stack_base = gc_stack_sp
            this.init_stack(sp)
            this.started = true
        }

        // Swap
        SELF.swap(@ref(main_state), @ref(this.state))

        // Restore backup
        if !this.done {

            // Backup Main stack
            let size : uint = this.stack_base - this.state.rsp
            let asize = this.backup_main_stack_alloc_size 
            if size > asize {
                if asize > 0 : mem:free(this.backup_main_stack)
                this.backup_main_stack = mem:alloc(size)
                this.backup_main_stack_alloc_size = size
            }
            this.backup_main_stack_size = size

            // Backup GC stack
            let gc_size : uint = gc_stack_sp - this.gc_stack_base
            let gc_asize = this.backup_gc_stack_alloc_size
            if gc_size > gc_asize {
                if gc_asize > 0 : mem:free(this.backup_gc_stack)
                this.backup_gc_stack = mem:alloc(gc_size)
                this.backup_gc_stack_alloc_size = gc_size
            }
            this.backup_gc_stack_size = gc_size

            if size > 0 {
                mem:copy(this.state.rsp, this.backup_main_stack, this.backup_main_stack_size)
            }
            if gc_size > 0 {
                mem:copy(this.gc_stack_base, this.backup_gc_stack, this.backup_gc_stack_size)
            }
        }

        // Restore stack base
        this.active = false
        gc_stack_sp = gc_stack_sp_backup
        current_coro = null

        if this.done {
            // Clean up
            this.free_stacks()

            // Next
            let next = this.follow_up
            if isset(next) {
                this.follow_up = null
                run_coros.append(next)
            }
        }
    }

    fn complete() {
        this.done = true
        current_coro = null
        g_coro_count--
        let index = this.g_list_index

        g_coros.set(index, null) _
        g_coro_indexes.add(index)

        this.yield()
    }

    //////////////
    // LOOP
    //////////////

    static fn loop(until: ?Coro (null)) {
        // Done check
        if isset(until) && until.done : return

        #if OS == linux
        let ring = io:uring()
        #elif OS == macos
        let kq = io:kqueue()
        #elif OS == win
        let cport = io:iocp()
        #end

        while true {

            // Run coroutines
            each run_coros as coro {
                coro.resume()
            }
            // Clear
            run_coros.clear()

            //
            each next_coros as coro {
                run_coros.append(coro)
            }
            next_coros.clear()

            // Done check
            if isset(until) && until.done : break

            // Wait for poll coros
            #if OS == linux
            if io:uring_unsubmitted > 0 : io:uring_submit(ring)
            #end

            gc:collect_if_threshold_almost_reached()
            #if OS == linux
            while true {
                let cqe : ?ext:io_uring_cqe = null
                if run_coros.length == 0 {
                    gc:unlock()
                    io:io_uring_wait_cqe(ring, @ref(cqe))
                    gc:lock()
                } else {
                    io:io_uring_peek_cqe(ring, @ref(cqe))
                }
                if !isset(cqe) {
                    break
                }
                //
                let coro = cqe.user_data.@cast(Coro)
                run_coros.append(coro)
                coro.poll_event = cqe.res.@cast(io:PollEvent)
                coro.completion_res = cqe.res
                io:io_uring_cqe_seen(ring, cqe)
            }
            #elif OS == macos
            let events : [<ext:kEvent> x 64] = @undefined
            gc:unlock()
            let timeout : ?ext:libc_timespec = null
            if run_coros.length > 0 {
                let t : <ext:libc_timespec> = { tv_sec: 0, tv_nsec: 0 }
                timeout = @ref(t)
            }
            let nevents = ext:kevent(kq, null, 0, @ref(events), 64, timeout)
            gc:lock()
            while nevents-- > 0 {
                let ev = events[nevents]
                let coro = ev.udata.@cast(Coro)
                if ev.filter == io:EVFILT_READ {
                    coro.poll_event = ext:POLLIN
                    coro.completion_res = ev.data
                    if (ev.flags & io:EV_EOF) == io:EV_EOF : coro.poll_event = ext:POLLHUP
                } else if ev.filter == io:EVFILT_WRITE {
                    coro.poll_event = ext:POLLOUT
                    coro.completion_res = ev.data
                    if (ev.flags & io:EV_EOF) == io:EV_EOF : coro.poll_event = ext:POLLHUP
                }
                run_coros.append(coro)
            }

            #elif OS == win
            gc:unlock()
            let first = run_coros.length == 0

            while true {
                let bytes: u32 = 0
                let key: uint = 0
                let ov: ?io:OverlapData = null
                let result = ext:GetQueuedCompletionStatus(cport, &bytes, &key, &ov, first ? ext:INFINITE : 0)
                if !result || !isset(ov) : break
                first = false
                let coro = ov.base.coro.@cast(Coro)
                run_coros.append(coro)
            }
            gc:lock()

            #else
            panic("Unsupported OS for: coroutine loop")
            #end
        }
    }
}
