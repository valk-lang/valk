
header "sys" as sys

use mem
use io
use gc
use type

global coro_run_first : ?Coro (null)
global coro_run_last : ?Coro (null)
global current_coro : ?Coro (null)

global coro_poll : ?CoroPoll (null)
global g_coros : Array[?Coro] (Array[?Coro].new(16))
global g_coro_indexes : type:Pool[uint] (type:Pool[uint].new(16))
global g_coro_poll_count : uint
global g_coro_count : uint

class Coro {
    args: ?ptr
    stack: gc:Stack

    start_func: fn(Coro)()
    handler: fn()()
    follow_up: ?Coro (null)
    next_resume: ?Coro (null)
    g_list_index: uint (0)

    s_stack: ?ptr (null)
    s_top: ptr (0 @as ptr)
    s_bottom: ptr (0 @as ptr)
    s_cont: ptr (0 @as ptr)
    s_size: uint (0)
    s_back_buf: ptr (0 @as ptr)

    test: uint (10)
    error: u32 (0)
    started: bool (false)
    done: bool (false)

    static fn new(handler: ptr, start_func: ptr) SELF {

        let stack = gc:Stack.new()
        let args = stack.base + stack.size - 128

        let coro = Coro {
            args: args
            stack: stack
            //
            start_func: start_func @as fn(Coro)()
            handler: handler @as fn()()
        }

        let indexes = g_coro_indexes
        if indexes.count == 0 {
            let index = g_coros.push(coro)
            coro.g_list_index = index
        } else {
            let index = indexes.get() ? 0
            g_coros.set(index, coro) _
            coro.g_list_index = index
        }

        let last = coro_run_last
        if isset(last) {
            last.next_resume = coro
            coro_run_last = coro
        } else {
            coro_run_first = coro
            coro_run_last = coro
        }

        g_coro_count++

        return coro
    }

    static fn get_poll() CoroPoll {
        let poll = coro_poll
        if poll == null {
            let p = CoroPoll.new()
            coro_poll = p
            return p
        }
        return poll @as CoroPoll
    }

    static fn yield_current() {
        let current = current_coro
        if current != null {
            // await_last
        }
    }

    //////////////
    // AWAIT
    //////////////

    fn await_coro(coro: Coro) {
        let ob = coro
        let ref = ob.follow_up
        while isset(ref) {
            ob = ref
            ref = ref.follow_up
        }
        ob.follow_up = this
        this.block()
    }

    fn poll_fd(fd: FD, read: bool, write: bool) {
        let poll = Coro.get_poll()
        poll.set(fd, this, read, write)
        g_coro_poll_count++
    }

    fn await_fd(fd: FD, read: bool, write: bool) {
        this.poll_fd(fd, read, write)
        this.block()
    }

    fn await_last() {
        let last = coro_run_last
        if isset(last) {
            last.next_resume = this
            coro_run_last = this
        } else {
            coro_run_first = this
            coro_run_last = this
        }
        this.block()
    }

    //////////////
    // FLOW
    //////////////

    fn block() {
        // let here = @stack(inline [ptr, 5])
        current_coro = null
        let here = @stack(<sys:libc_jmp_buf>)
        if @setjmp(here) == 0 {
            this.s_cont = here @as ptr
            this.s_top = this.s_cont - 32

            #if OS == win
            @ptrv(here, ptr, 0) += 0x80
            #end

            // Copy stack
            let size = (this.s_bottom - this.s_top) @as uint
            let stack = this.s_stack
            let has_stack = isset(stack)
            let create_stack = !has_stack || size > this.s_size
            if create_stack {
                if has_stack : mem:free(stack @as ptr)
                stack = mem:alloc(size)
                this.s_size = size
                this.s_stack = stack
            }

            mem:copy(this.s_top, stack @as ptr, size)

            // Jump out
            @longjmp(this.s_back_buf)
        }
    }

    fn start() {
        let pad = @stack(<[2048 x u8]>) @as ptr
        this.started = true
        this.s_bottom = pad
        let start = this.start_func
        start(this)
    }
    fn continue() {
        let size = (this.s_bottom - this.s_top) @as uint
        let stack = this.s_stack @as ptr
        mem:copy(stack, this.s_top, size)
        @longjmp(this.s_cont)
    }

    static fn setjmp(buf: ptr) i32 {
        if @setjmp(buf) == 0 {
            return 0
        }
        return 1
    }
    fn resume() {
        if this.done : return
        current_coro = this

        let jmpbuf = @stack(<sys:libc_jmp_buf>)
        let current_stack = gc:stack_active
        if @setjmp(jmpbuf) == 0 {

            #if OS == win
            @ptrv(jmpbuf, ptr, 0) += 0x80
            #end

            this.s_back_buf = jmpbuf
            gc:stack_active = this.stack
            if this.started == false {
                this.start()
            } else {
                this.continue()
            }
        }
        gc:stack_active = current_stack

        if this.done {
            let next = this.follow_up
            if isset(next) {
                this.follow_up = null
                next.resume()
            }
        }
    }

    fn complete() {
        this.done = true
        current_coro = null
        g_coro_count--
        let index = this.g_list_index
        g_coros.set(index, null) _
        g_coro_indexes.add(index)
        @longjmp(this.s_back_buf)
    }

    //////////////
    // LOOP
    //////////////

    static fn loop() {
        let poll = Coro.get_poll()
        while g_coro_count > 0 {
            // Run coro chain
            let coro = coro_run_first
            while isset(coro) {
                coro.resume()
                let next = coro.next_resume
                coro.next_resume = null
                coro = next
            }
            coro_run_first = null
            coro_run_last = null
            // Wait for poll coros
            if g_coro_poll_count > 0 {
                let coros = poll.wait(1000) ! {
                    panic("Too many file descriptors")
                }
                g_coro_poll_count -= coros.length
                each coros => coro {
                    coro.resume()
                }
            }
            // if mem:mem_usage > 10 || mem:run_gc {
            //     mem:gc()
            // }
        }
    }

    ///////////////////
    // GC
    ///////////////////

    // static fn transfer_check() {
    //     let coros = g_coros

    //     each coros as coro {
    //         if isset(coro) {
    //             let base = coro.gc_stack.base
    //             let adr = coro.gc_stack.adr
    //             while adr > base {
    //                 adr -= sizeof(ptr)
    //                 mem:gc_transfer_item(@ptrv(adr, ptr, 0))
    //             }
    //         }
    //     }
    // }

    // fn _gc_mark() {
    //     let base = this.gc_stack.base
    //     let adr = this.gc_stack.adr
    //     while adr > base {
    //         adr -= sizeof(ptr)
    //         mem:gc_mark_item(@ptrv(adr, ptr, 0))
    //     }
    // }
    // fn _gc_mark_shared() {
    //     let base = this.gc_stack.base
    //     let adr = this.gc_stack.adr
    //     while adr > base {
    //         adr -= sizeof(ptr)
    //         mem:gc_mark_shared_item(@ptrv(adr, ptr, 0))
    //     }
    // }

    // fn _gc_free() {
    //     this.gc_stack.free()
    //     let s = this.s_stack
    //     if isset(s) {
    //         mem:free(s)
    //     }
    // }
}


// use mem
// use gc

// class Coro {
//     size: uint
//     size_gc: uint
//     stack: ?ptr
//     stack_gc: ?gc:Stack
//     handler: ptr
//     error_code: u32 (0)
//     error_msg: String ("")

//     static fn init(func: ptr, size: uint, size_gc: uint) Coro {

//         let stack = size > 0 ? mem:alloc(size) : null
//         let stack_gc = size_gc > 0 ? gc:Stack.new() : null

//         return Coro {
//             size: size
//             size_gc: size_gc
//             stack: stack
//             stack_gc: stack_gc
//             func: func
//         }
//     }

//     fn _gc_mark(color: u16) {
//         let stack = this.stack_gc
//         if !isset(stack) : return
//         let base = stack.base
//         let adr = stack.adr
//         while base < adr {
//             let item = @ptrv(base, ptr)
//             if item != null {
//                 let vti = @ptrv(item, u16, -1)
//                 if vti > 0 {
//                     let mark = @ptrv(gc:vtable, fn(ptr, u16)(), vti @as uint * gc:VTABLE_COLS)
//                     mark(item, color)
//                 }
//             }
//             base += sizeof(ptr)
//         }
//     }

//     fn _gc_demark(color: u16) {
//         let stack = this.stack_gc
//         if !isset(stack) : return
//         let base = stack.base
//         let adr = stack.adr
//         while base < adr {
//             let item = @ptrv(base, ptr)
//             if item != null {
//                 let vti = @ptrv(item, u16, -1)
//                 if vti > 0 {
//                     let demark = @ptrv(gc:vtable, fn(ptr, u16)(), vti @as uint * gc:VTABLE_COLS + 1)
//                     demark(item, color)
//                 }
//             }

//             base += sizeof(ptr)
//         }
//     }
// }


// codegen COROGEN[bind_properties, return_properties, handler_type] {
//     struct Data {
//         #loop properties bind_properties as name, T 
//         #{name}: T
//         #end
//         #loop properties return_properties as name, T 
//         #{name}: T (@undefined)
//         #end
//     }

//     fn coro_init(
//         handler: ptr,
//         #loop properties bind_properties as name, T 
//         #{name}: T,
//         #end
//     ) Coro {
//         let data = Data {
//             #loop properties return_properties as name, T 
//             #{name}: #{name}
//             #end
//         }
//         return Coro {
//             handler: handler
//             data: data @as ptr
//             start_func: start_func @as ptr
//             result_func: result_func @as ptr
//             mark_func: mark_func @as ptr
//             demark_func: demark_func @as ptr
//             share_func: share_func @as ptr
//         }
//     }

//     fn start_func(coro: Coro) {
//         let data = coro.data as Data
//         let handler = coro.handler @as handler_type

//         (
//         #loop properties return_properties as name, T 
//         data.#{name}
//         #end
//         ) = handler(
//             #loop properties bind_properties as name, T 
//             #{name}: T,
//             #end
//         )
//         #if @type_can_error(handler_type)
//         ! {
//             coro.error = 1
//             coro.finished = true
//             return
//         }
//         #end
//         coro.finished = true
//     }

//     fn result_func(coro: Coro) return_properties {

//         let data = coro.data as Data

//         return (
//         #loop properties return_properties as name, T 
//         data.#{name},
//         #end
//         )
//     }
// }