
header "sys" as sys

use core
use mem
use gc
use type
use io

global coro_run_first : ?Coro
global coro_run_last : ?Coro
global current_coro : ?Coro
global g_coros : Array[?Coro] (.new(16))
global g_coro_indexes : type:Pool[uint] (.new(16))
global g_coro_count : uint

global main_state : <CoroState> (@undefined)

#if OS == macos
global kqfd : i32
global timer_id : uint
#end

#if OS == win
global cport : ?ptr
#end

struct CoroState {
    rsp: ptr
}
class Coro {
    args: ptr
    gc_args: Array[gc:GcPtr] (.{})

    // stack: ?ptr
    // stack_mem_size: uint (0)
    // stack_size: uint (0)

    s: core:Stack (core:Stack.new())

    state: <CoroState> (@undefined)
    stack: ptr (@undefined)

    start_func: fnRef()()
    handler: fnRef()()
    follow_up: ?Coro
    next_resume: ?Coro
    g_list_index: uint (0)

    s_stack: ?ptr
    s_top: ptr (0.@cast(ptr))
    s_bottom: ptr (0.@cast(ptr))
    s_cont: ptr (0.@cast(ptr))
    s_size: uint (0)
    s_back_buf: ptr (0.@cast(ptr))

    error_code: u32 (0)
    error_msg: String ("")
    // async results
    poll_event: io:PollEvent (0)
    completion_res: i64 (0)

    test: uint (10)
    error: u32 (0)
    started: bool (false)
    done: bool (false)

    static fn new(handler: ptr, start_func: ptr) SELF {

        let coro = Coro {
            args: mem:alloc(128)
            //
            start_func: start_func.@cast(fnRef()())
            handler: handler.@cast(fnRef()())
        }

        let indexes = g_coro_indexes
        if indexes.count == 0 {
            let index = g_coros.length
            g_coros.append(coro)
            coro.g_list_index = index
        } else {
            let index = indexes.get() !? 0
            g_coros.set(index, coro) _
            coro.g_list_index = index
        }

        let last = coro_run_last
        if isset(last) {
            last.next_resume = coro
            coro_run_last = coro
        } else {
            coro_run_first = coro
            coro_run_last = coro
        }

        let stack = mem:alloc(core:STACK_SIZE)
        let stack_top = stack + core:STACK_SIZE
        let stack_start = stack_top - (8 * size_of(ptr)) - (stack_top.to(uint) % (size_of(ptr) * 2))
        @ptrv(stack_start, ptr, 6) = start_func
        coro.state.rsp = stack_start
        coro.stack = stack

        g_coro_count++

        return coro
    }

    #if OS == macos
    static fn get_kq() i32 {
        let fd = kqfd
        if fd == 0 {
            kqfd = sys:kqueue()
            if kqfd == -1 : panic("Failed init kqueue")
        }
        return kqfd
    }
    #end


    //////////////
    // AWAIT
    //////////////

    fn await_coro(coro: Coro) {
        if coro.done : return
        let ob = coro
        let ref = ob.follow_up
        while isset(ref) {
            ob = ref
            ref = ref.follow_up
        }
        ob.follow_up = this
        this.block()
    }

    fn sleep(ns: uint) {
        #if OS == linux
        let sqe = io:sqe(this) ! return
        let nsec = ns.@cast(int)
        let ts = io:kernel_timespec {
            tv_sec: nsec / 1000000000
            tv_nsec: (nsec % 1000000000)
        }
        io:io_uring_prep_timeout(sqe, ts, 0, 0)

        #elif OS == macos
        let ms = ns.to(i64) / 1000000
        let ev : <sys:kEvent> = @undefined
        io:EV_SET(@ref(ev), timer_id++, io:EVFILT_TIMER, io:EV_ADD | io:EV_ENABLE | io:EV_ONESHOT, 0, ms, this)
        let kq = this.get_kq()
        sys:kevent(kq, @ref(ev), 1, null, 0, null)

        #else
        let timer = sys:CreateWaitableTimerExW(null, null, 0, sys:TIMER_ALL_ACCESS)
        if timer == 0 : return

        let due : i64 = (ns.to(int) / 100) * -1
        let ok = sys:SetWaitableTimer(timer, &due, 0, null, null, false)
        if !ok {
            sys:CloseHandle(timer)
            return
        }

        let wcp : sys:HANDLE = 0
        let status = sys:NtCreateWaitCompletionPacket(&wcp, sys:MAXIMUM_ALLOWED, null)
        if status != 0 {
            sys:CloseHandle(timer)
            return
        }

        let ov = io:overlap[io:OverlapData]()
        let sig : bool = false
        status = sys:NtAssociateWaitCompletionPacket(wcp, io:iocp(), timer, null, ov, sys:STATUS_SUCCESS, 0, &sig)
        if status != 0 {
            sys:CloseHandle(timer)
            io:free_ov(ov)
            return
        }

        #end
        this.block()

        #if OS == win
        io:free_ov(ov)
        #end
    }

    fn await_last() {
        let last = coro_run_last
        if isset(last) {
            last.next_resume = this
            coro_run_last = this
        } else {
            coro_run_first = this
            coro_run_last = this
        }
        this.block()
    }

    //////////////
    // FLOW
    //////////////

    fn block() {
        current_coro = null
        sys:valk_stack_swap(@ref(this.state), @ref(main_state))
        return

        current_coro = null
        let here = @stack(<sys:libc_jmp_buf>)
        if @setjmp(here) == 0 {
            this.s_cont = here.@cast(ptr)
            this.s_top = this.s_cont - 32

            #if OS == win
            @ptrv(here, ptr, 0) += 0x80
            #end

            // Save stack
            let size = (this.s_bottom - this.s_top).@cast(uint)
            let stack = this.s_stack
            let has_stack = isset(stack)
            let create_stack = !has_stack || size > this.s_size
            if create_stack {
                if has_stack : mem:free(stack.@cast(ptr))
                stack = mem:alloc(size)
                this.s_size = size
                this.s_stack = stack
            }

            mem:copy(this.s_top, stack.@cast(ptr), size)

            // Save GC stack
            // let gc_stack = this.stack
            // let gc_size : uint = gc:stack_top - (&gc:stack_root).@cast(ptr)
            // if !isset(gc_stack) || gc_size > this.stack_mem_size {
            //     if isset(gc_stack) : mem:free(gc_stack)
            //     gc_stack = mem:alloc(gc_size)
            //     this.stack_mem_size = gc_size
            //     this.stack = gc_stack
            // }
            // this.stack_size = gc_size

            // mem:copy(gc:stack_root, gc_stack, gc_size)
            // @memcpy(@ref(core:stack), this.s, size_of(<core:Stack>))
            this.s.now = stack_now

            // Jump out
            @longjmp(this.s_back_buf)
        }
    }

    // fn start() {
    //     let pad = @stack([u8 x 2048]).@cast(ptr)
    //     this.started = true
    //     this.s_bottom = pad
    //     core:stack = this.s
    //     let start = this.start_func
    //     start()
    // }
    // fn continue() {
    //     // Restore stack
    //     let size = (this.s_bottom - this.s_top).@cast(uint)
    //     let stack = this.s_stack.@cast(ptr)
    //     mem:copy(stack, this.s_top, size)
    //     // Restore GC stack
    //     // let gc_stack = this.stack
    //     // let gc_size = this.stack_size
    //     // if isset(gc_stack) : mem:copy(gc_stack, gc:stack_root, gc_size)
    //     // gc:stack_top = (&gc:stack_root).@cast(ptr) + gc_size
    //     // core:stack = this.s
    //     core:stack = this.s

    //     // Jump
    //     @longjmp(this.s_cont)
    // }

    static fn setjmp(buf: ptr) i32 {
        if @setjmp(buf) == 0 {
            return 0
        }
        return 1
    }

    fn resume() {
        if this.done : return

        let current = current_coro
        current_coro = this

        // core:main_stack = @ref(core:stack)
        core:main_stack.now = core:stack_now
        core:stack_now = this.s.now

        // this.start_func()
        if isset(current) : sys:valk_stack_swap(@ref(current.state), @ref(this.state))
        else : sys:valk_stack_swap(@ref(main_state), @ref(this.state))

        this.s.now = core:stack_now
        core:stack_now = core:main_stack.now
        // core:stack = @ref(core:main_stack)

        if this.done {
            let next = this.follow_up
            if isset(next) {
                this.follow_up = null
                next.resume()
            }
        }

        // OLD
        // core:main_stack = @ref(core:stack)

        // // Start/continue coro
        // let jmpbuf = @stack(<sys:libc_jmp_buf>)
        // if @setjmp(jmpbuf) == 0 {

        //     #if OS == win
        //     @ptrv(jmpbuf, ptr, 0) += 0x80
        //     #end

        //     this.s_back_buf = jmpbuf
        //     if this.started == false {
        //         this.start()
        //     } else {
        //         this.continue()
        //     }
        // }

        // // gc:restore_gc_stack()
        // core:stack = @ref(core:main_stack)

        // if this.done {
        //     let next = this.follow_up
        //     if isset(next) {
        //         this.follow_up = null
        //         next.resume()
        //     }
        // }
    }

    fn complete() {
        this.done = true
        current_coro = null
        g_coro_count--
        let index = this.g_list_index
        // let gc_stack = this.stack
        // if isset(gc_stack) {
        //     mem:free(gc_stack)
        //     this.stack = null
        //     this.stack_size = 0
        // }
        let s = this.s_stack
        if isset(s) : mem:free(s)

        this.s.free()

        g_coros.set(index, null) _
        g_coro_indexes.add(index)
        // @longjmp(this.s_back_buf)
        this.block()
    }

    //////////////
    // LOOP
    //////////////

    static fn loop(until: ?Coro (null)) {
        #if OS == linux
        let ring = io:uring()
        #elif OS == macos
        let kq = Coro.get_kq()
        #elif OS == win
        let cport = io:iocp()
        #end

        let coros = Array[Coro].new(16)
        let has_run = true

        while true {
            if isset(until) && until.done : break

            // Run coro chain
            let coro = coro_run_first
            while isset(coro) {
                coro.resume()
                let next = coro.next_resume
                coro.next_resume = null
                coro = next
            }
            coro_run_first = null
            coro_run_last = null

            // Done check
            if isset(until) {
                if until.done : break
            }

            // Wait for poll coros
            #if OS == linux
            if io:uring_unsubmitted > 0 : io:uring_submit(ring)
            #end

            coros.clear()
            #if OS == linux
            while true {
                let cqe : ?sys:io_uring_cqe = null
                if coros.length == 0 {
                    gc:unlock()
                    io:io_uring_wait_cqe(ring, @ref(cqe))
                    gc:lock()
                } else {
                    io:io_uring_peek_cqe(ring, @ref(cqe))
                }
                if !isset(cqe) {
                    break
                }
                //
                let coro = cqe.user_data.@cast(Coro)
                coros.append(coro)
                coro.poll_event = cqe.res.@cast(io:PollEvent)
                coro.completion_res = cqe.res
                io:io_uring_cqe_seen(ring, cqe)
            }
            #elif OS == macos
            let events : [<sys:kEvent> x 64] = @undefined
            gc:unlock()
            let nevents = sys:kevent(kq, null, 0, @ref(events), 64, null)
            gc:lock()
            while nevents-- > 0 {
                let ev = events[nevents]
                let coro = ev.udata.@cast(Coro)
                if ev.filter == io:EVFILT_READ {
                    coro.poll_event = sys:POLLIN
                    coro.completion_res = ev.data
                } else if ev.filter == io:EVFILT_WRITE {
                    coro.poll_event = sys:POLLOUT
                    coro.completion_res = ev.data
                }
                coros.append(coro)
            }

            #elif OS == win
            gc:unlock()
            let first = true

            while true {
                let bytes: u32 = 0
                let key: uint = 0
                let ov: ?io:OverlapData = null
                let result = sys:GetQueuedCompletionStatus(cport, &bytes, &key, &ov, first ? sys:INFINITE : 0)
                if !result || !isset(ov) : break
                first = false
                let coro = ov.base.coro.@cast(Coro)
                coros.append(coro)
            }
            gc:lock()

            #else
            panic("Unsupported OS for: coroutine loop")
            #end
            //
            if coros.length == 0 {
                if has_run {
                    // has_run = false
                    gc:collect()
                }
            } else {
                has_run = true
            }
            // Resume coroutines
            each coros as coro {
                coro.resume()
            }
        }
    }

    ///////////////////
    // GC
    ///////////////////

    fn gc_free() {
        mem:free(this.args)
    }
}
