
trait EncodeTrait {
    + fn json_value() Value {
        #if is_integer_type(SELF)
        return new_int(this)
        #elif is_float_type(SELF)
        return new_float(this)
        #elif is_bool_type(SELF)
        return new_bool(this)
        #elif !is_structural_type(SELF)
            #if is_pointer(SELF)
            return new_string(this.@cast(ptr))
            #else
            #error "Cannot convert this value type to json"
            #end
        #end

        // Structural
        let i = map[Value]{}

        #loop object this as prop
        {
            let propv = prop.value
        // If nullable
        #if is_nullable_type(prop)
        if !isset(propv) {
            i.set(prop.name, new_null())
        } else {
            #end

            // IF HAS METHOD
            #if type_has_method(prop, json_value)
            let v = propv.json_value()
            #else

            #if is_integer_type(prop)
            let v = new_int(prop.value.to(int))
            #elif is_float_type(prop)
            let v = new_float(prop.value)
            #elif is_bool_type(prop)
            let v = new_bool(prop.value)
            #elif is_raw_pointer_type(prop)
            let v = new_int(prop.value.@cast(int))
            #else
            // Trigger error
            let v = propv.json_value()
            #end
            #end // End else has method

            i.set(prop.name, v)

            #if is_nullable_type(prop)
        }
        #end

        }
        #end // End loop
        return new_object(i)
    }
    + fn json_encode(pretty: bool (false)) String {
        return this.json_value().encode(pretty)
    }
}

trait DecodeTrait {
    + static fn json_decode(data: Value) SELF {
        #if is_integer_type(SELF)
        return data.int().@cast(SELF)
        #elif is_float_type(SELF)
        return data.float().@cast(SELF)
        #elif is_bool_type(SELF)
        return data.bool().@cast(SELF)
        #elif is_raw_pointer_type(SELF)
        return data.int().@cast(SELF)
        #elif !is_structural_type(SELF)
        #print_type(SELF)
        #error "Cannot convert json to this value type"
        #end

        // Structural
        let values = data.map()
        let result = SELF {
            #loop properties SELF as prop
            prop: <{
                let val = values.get(prop.name) !? new_null()

                #if is_nullable_type(prop)
                if val.is_null() : return null
                #end
                
                #if is_integer_type(prop)
                return val.int().@cast(prop)
                #elif is_float_type(prop)
                return val.float().@cast(prop)
                #elif is_bool_type(prop)
                return val.bool().@cast(prop)
                #elif is_raw_pointer_type(prop)
                return data.int().@cast(SELF)

                #elif !type_has_method(prop, json_value)
                #error "Cannot convert json to this value type"
                #end

                return prop.type.json_decode(val)
            }
            #end // End loop
        }
        return result
    }
}

extend KeyMap[K, V] {

    #if is_type_of_class(V, String)
    + fn json_value() Value {
        // Convert to KeyMap[K, V] -> KeyMap[String, Value]
        let result = keymap[String, Value]{}
        each this as v, k {
            result.set(k, v.json_value())
        }
        return new_object(result)
    }

    + fn json_encode(pretty: bool (false)) String {
        return this.json_value().encode(pretty)
    }
    #end
}

extend Array[T] {

    #if is_type_of_class(T, String)
    + fn json_value() Value {
        // Convert to Array[T] -> Array[Value]
        let result = array[Value]{}
        each this as v {
            #if is_nullable_type(T)
            if !isset(v) {
                result.append(new_null())
                continue
            }
            #end
            result.append(v.json_value())
        }
        return new_array(result)
    }

    + fn json_encode(pretty: bool (false)) String {
        return this.json_value().encode(pretty)
    }
    #end
}

extend String {

    + fn json_value() Value {
        return new_string(this)
    }
    + fn json_encode(pretty: bool (false)) String {
        return this.json_value().encode(pretty)
    }
    + static fn json_decode(val: Value) String {
        return val.string()
    }
}