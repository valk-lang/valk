
class ToHtmlOptions {
    code_class: ?String (null)
    paragraph_class: ?String (null)
}

+ fn to_html(md: String, options: ?ToHtmlOptions (null)) String {
    let html = ByteBuffer.new(1024)
    let lines = md.split("\n")
    let state = State{}
    // Options
    if isset(options) {
        let pclass = options.paragraph_class
        if isset(pclass) : state.paragraph_class = pclass
        let code_class = options.code_class
        if isset(code_class) : state.code_class = code_class
    }
    //
    handle_lines(html, state, lines)
    return html
}

enum LT : uint {
    empty
    text
    code
    h1 h2 h3 h4 h5 h6
    hr // 9
    blockquote
    ul1 ul2 ul3
    ol
    li
    title
}

fn line_type(line: String) LT {
    if line.is_empty() : return LT.empty
    if line.starts_with("```") : return LT.code
    if line.starts_with("# ") : return LT.h1
    if line.starts_with("## ") : return LT.h2
    if line.starts_with("### ") : return LT.h3
    if line.starts_with("#### ") : return LT.h4
    if line.starts_with("##### ") : return LT.h5
    if line.starts_with("###### ") : return LT.h6
    if line.starts_with("---") : return LT.hr
    if line.starts_with("___") : return LT.hr
    if line.starts_with("***") : return LT.hr
    if line.starts_with(">") : return LT.blockquote
    if line.starts_with("- ") : return LT.ul1
    if line.starts_with("+ ") : return LT.ul2
    if line.starts_with("* ") : return LT.ul3
    if line.starts_with("--") : return LT.title
    if line.starts_with("==") : return LT.title
    if is_numbered_li(line) : return LT.ol
    return LT.text
}

class State {
    scopes: Array[LT] (.{})
    li_starts: Array[uint] (.{})
    text_lines: Array[String] (.{})
    offset: uint (0)
    paragraph_class: ?String (null)
    code_class: ?String (null)
    use_para: bool (true)
}

fn handle_lines(html: ByteBuffer, state: State, lines: Array[String]) {

    each lines as line, lindex {

        let current = state.scopes.get(state.scopes.length - 1) !? LT.empty

        if current == LT.code {
            if trim_whitespace(line) == "```" {
                state.scopes.pop_last() _
                html.append_str("</code></pre>\n")
            } else {
                html.append_str(line)
                html.append_byte('\n')
            }
            continue
        }

        state.offset = 0
        line = parse_scope(html, line, state)

        while true {

            let lt = line_type(line)
            let current = state.scopes.get(state.scopes.length - 1) !? LT.empty

            // Check invalid <hr>
            if lt == LT.hr || line.starts_with("==") || line.starts_with("--") {
                let fch = line.get(0)
                let i = 2
                while i < line.length {
                    let ch = line.get(i++)
                    if ch != fch && ch != ' ' {
                        lt = LT.text
                        break
                    }
                }
            }

            // Header
            if lt != LT.text && (line.starts_with("==") || line.starts_with("--")) {
                if state.text_lines.length > 0 {
                    state.use_para = true
                    let title = state.text_lines.pop_last() ! continue
                    dump_text(state, html)
                    if line.starts_with("=") : html.append_str("<h1>%title</h1>")
                    else : html.append_str("<h2>%title</h2>")
                    break
                }
                lt = LT.text
            }

            // Dump text
            if lt != LT.text && state.text_lines.length > 0 {
                state.use_para = true
                dump_text(state, html)
            }

            if lt == LT.empty : break

            if lt == LT.blockquote {
                html.append_str("<blockquote>")
                line = skip_part_and_spaces(state, line, 1)
                state.scopes.append(lt)
                continue
            }
            if lt >= LT.ul1 && lt <= LT.ul3 {
                state.use_para = false
                if current != lt : html.append_str("<ul>")
                html.append_str("<li>")
                line = skip_part_and_spaces(state, line, 2)
                state.scopes.append(lt)
                state.scopes.append(LT.li)
                continue
            }
            if lt == LT.ol {
                state.use_para = false
                if current != lt : html.append_str("<ol>")
                html.append_str("<li>")
                line = skip_part_and_spaces(state, line, 2)
                state.scopes.append(lt)
                state.scopes.append(LT.li)
                continue
            }

            if lt >= LT.h1 && lt <= LT.h6 {
                let nr = (lt - LT.h1) + 1
                line = line.part(nr + 1, line.length)
                html.append_str("<h")
                html.append_int(nr)
                html.append_str(">")
                html.append_str(line)
                html.append_str("</h")
                html.append_int(nr)
                html.append_str(">")
                html.append_byte('\n')
                break
            }

            if lt == LT.code {
                let code_class = state.code_class
                if isset(code_class) : html.append_str("<pre><code class=\"%code_class\">")
                else : html.append_str("<pre><code>")
                state.scopes.append(lt)
                break
            }

            if lt == LT.text {
                state.text_lines.append(line)
                break
            }

            if lt == LT.hr {
                html.append_str("<hr/>\n")
                break
            }

            panic("Unhandled markdown type (bug): " + lt)
        }
    }
}

fn line_format_all(line: String) String {

    line = line_format(line, "`", "`", "<code>", "</code>")
    line = line_format(line, "***", "***", "<em><strong>", "</strong></em>")
    line = line_format(line, "___", "___", "<em><strong>", "</strong></em>", true)
    line = line_format(line, "__*", "*__", "<em><strong>", "</strong></em>", true)
    line = line_format(line, "**_", "_**", "<em><strong>", "</strong></em>", true)
    line = line_format(line, "**", "**", "<strong>", "</strong>")
    line = line_format(line, "__", "__", "<strong>", "</strong>", true)
    line = line_format(line, "*", "*", "<em>", "</em>")
    line = line_format(line, "~~", "~~", "<del>", "</del>")

    // Links
    while true {
        let is_image = false
        let p1 = line.index_of_byte('[') ! break
        if p1 > 0 && line.get(p1 - 1) == '!' : is_image = true
        let p2 = find_end_scope(line, p1 + 1, '[', ']') ! break
        if line.get(p2 + 1) != '(' : break
        let p3 = find_end_scope(line, p2 + 2, '(', ')') ! break
        //
        let s1 = line.part(0, p1 - is_image.to(u8))
        let label = line.part(p1 + 1, p2 - p1 - 1)
        let url = line.part(p2 + 2, p3 - p2 - 2)
        let s2 = line.part(p3 + 1, line.length - p3 - 1)
        if is_image {
            line = "%s1<img src=\"%url\" label=\"%label\"/>%s2"
        } else {
            line = "%s1<a href=\"%url\">%label</a>%s2"
        }
    }

    return line
}

fn find_end_scope(line: String, start: uint, char_start: u8, char_end: u8) uint !none {
    let depth = 1
    let i = start
    while i < line.length {
        let ch = line.get(i)
        if ch == char_start : depth++
        else if ch == char_end {
            if depth-- == 0 : throw none
            if depth == 0 {
                return i
            }
        }
        i++
    }
    throw none
}

fn line_format(line: String, find1: String, find2: String, before: String, after: String, no_ascii: bool (false)) String {
    let fl1 = find1.length
    let fl2 = find2.length
    while true {
        let p1 = line.index_of(find1) ! break
        if p1 > 0 && no_ascii && line.get(p1 - 1).is_alpha_numeric() : break
        let p2 = line.index_of(find2, p1 + 1) ! break
        if p2 + fl2 < line.length && no_ascii && line.get(p2 + fl2).is_alpha_numeric() : break
        let s1 = line.part(0, p1)
        let s2 = line.part(p1 + fl1, p2 - p1 - fl1)
        let s3 = line.part(p2 + fl2, line.length - p2 - fl2)
        line = "%s1%before%s2%after%s3"
    }
    return line
}

fn is_numbered_li(line: String) bool {
    let i : uint = 0
    while true {
        let ch = line.get(i++)
        if ch.is_number() : continue
        if ch == '.' && line.get(i) == ' ' && i > 1 : return true
        return false
    }
    return false
}

fn parse_scope(html: ByteBuffer, line: String, state: State) String {

    let current = state.scopes.get(state.scopes.length - 1) !? LT.empty

    if current == LT.code : return line

    // Check leading whitespace
    let linespaces : uint = 0
    let whitespace_chars : uint = 0
    let i = 0
    while true {
        let ch = line.get(i++)
        if ch == ' ' { linespaces++; whitespace_chars++ }
        else if ch == '\t' { linespaces += 3; whitespace_chars++ }
        else : break
    }

    // Spaces until in list item
    let scope_same_count = 0
    let cut = 0
    each state.li_starts as pos {
        if linespaces >= pos {
            cut = pos
            while true {
                let scope = state.scopes.get(scope_same_count++) ! break
                if scope == LT.li : break
            }
        }
    }
    if cut > 0 : line = line.part(cut, line.length)
    state.offset += cut

    // Progress scopes
    i = 0
    while i < line.length {
        let ch = line.get(i++)
        if ch == ' ' || ch == '\t' : continue
        if ch == '>' {
            if (state.scopes.get(scope_same_count) ! break) == LT.blockquote {
                scope_same_count++
                continue
            }
        }
        i--
        break
    }
    line = line.part(i, line.length)
    state.offset += i

    // Get type of line remainder
    let type = line_type(line)
    current = state.scopes.get(scope_same_count) !? LT.empty
    if type == current && current != LT.empty {
        if type >= LT.ul1 && type <= LT.ol : scope_same_count++
    }

    // Close un-used scopes
    let amount = state.scopes.length - scope_same_count
    if amount > 0 && state.text_lines.length > 0 {
        dump_text(state, html)
    }
    while amount-- > 0 {
        let scope = state.scopes.get(scope_same_count + amount) ! panic("Missing scope (bug)")
        if scope == LT.blockquote : html.append_str("</blockquote>\n")
        // else if scope == LT.code : html.append_str("</code></pre>\n")
        else if scope == LT.li { 
            state.li_starts.pop_last() _
            html.append_str("</li>\n")
        }
        else if scope >= LT.ul1 && scope <= LT.ul3 : html.append_str("</ul>\n")
        else if scope == LT.ol : html.append_str("</ol>\n")
        // else if scope == LT.paragraph : html.append_str("</p>\n")
        else : panic("Unknown scope (bug): " + scope)
    }

    return line
}

fn trim_whitespace(line: String) String {
    let len = line.length
    let from = 0
    let until = len
    while from < len {
        let ch = line.get(from)
        if !ch.is_whitespace() : break
        from++
    }
    while until > from {
        let ch = line.get(until - 1)
        if !ch.is_whitespace() : break
        until--
    }
    return line.part(from, until - from)
}

fn skip_part_and_spaces(state: State, line: String, start: uint) String {
    let i = start
    let len = line.length
    while i < len {
        let ch = line.get(i)
        if ch != ' ' && ch != '\t' : break
        i++
    }
    state.offset += i
    return line.part(i, line.length)
}


fn dump_text(state: State, html: ByteBuffer) {
    if state.use_para {
        let pclass = state.paragraph_class
        if isset(pclass) : html.append_str("<p class=\"%pclass\">")
        else : html.append_str("<p>")
    }
    each state.text_lines as line, i {
        if i > 0 : html.append_str("<br>\n")
        html.append_str(line_format_all(line))
    }
    if state.use_para : html.append_str("</p>\n")
    state.text_lines.clear()
}
