
use utils

value BCRYPT_HASH_STRING_LEN (60)
value BCRYPT_MIN_COST (3)
value BCRYPT_MAX_COST (31)

// @brief Password hashing function
// @param[in] prngAlgo PRNG algorithm
// @param[in] prngContext Pointer to the PRNG context
// @param[in] cost Key expansion iteration count as a power of two
// @param[in] password NULL-terminated password to be encoded
// @param[out] hash NULL-terminated hash string
// @param[out] hashLen Length of the hash string (optional parameter)
// @return Error code

// Pseudo random algorithm
class PrngAlgo {
    name: String
    contextSize: uint
    init: fn(ptr)(void) // ctx
    seed: fn(ptr, String)(void) // ctx, input
    addEntropy: fn(ptr, uint, String, uint)(void) // ctx, source, input, entropy
    read: fn(ptr, ptr, uint)(void) // ctx, output, length
}
  
fn bcryptHashPassword(prngAlgo: PrngAlgo, prngContext: ptr, cost: uint, password: String) String {
    // Generate a 16-byte random salt
    let salt_buf : [u8 x 16] = [0...]
    prngAlgo.read(prngContext, salt_buf, 16);
    let salt = String.make_from_ptr(salt_buf, 16)
    // Generate hash
    let hash = utils:ByteBuffer.new(BCRYPT_HASH_STRING_LEN)
    bcrypt(cost, salt, password, hash)
    return hash
}

fn bcryptVerifyPassword(password: String, hash: String) bool {
    let cost : uint = 0
  
    // Check the length of the hash string
    if hash.length != BCRYPT_HASH_STRING_LEN : return false
  
    // bcrypt uses the $2a$ prefix in the hash string
    if !hash.starts_with("$2a$") : return false
  
    // Parse cost parameter
    let cost_end = hash.index_of_byte('$', 4) ! return false
    cost = hash.part(4, cost_end - 4).to_uint() ! return false
  
    // Check the value of the cost parameter
    if cost < BCRYPT_MIN_COST || cost > BCRYPT_MAX_COST : return false
  
    // Parse salt parameter
    let hash_buf = utils:ByteBuffer.new(22)
    hash_buf.append_str(hash.part(cost_end, 22))
    println(hash_buf)
    let salt_buf = utils:ByteBuffer.new(32)
    radix64_decode(hash_buf, salt_buf) ! return false
    let salt : String = salt_buf
  
    // Hash the password using bcrypt algorithm
    hash_buf.clear()
    hash_buf.minimum_free_space(BCRYPT_HASH_STRING_LEN)
    bcrypt(cost, salt, password, hash_buf);
  
    // The calculated string is bitwise compared to the hash string. The password is correct if and only if the strings match
    let i : uint = 0
    let mask : u8 = 0
    while i < BCRYPT_HASH_STRING_LEN {
       mask |= hash_buf[i] ^ hash[i];
       i++
    }
  
    return mask == 0
 }
  
  
// @brief bcrypt algorithm
// @param[in] cost Key expansion iteration count as a power of two
// @param[in] salt Random salt (16 bytes)
// @param[in] password NULL-terminated password to be encoded
// @param[out] hash NULL-terminated hash string
// @param[out] hashLen Length of the hash string (optional parameter)
// @return Error code
  
fn bcrypt(cost: uint, salt: String, password: String, output: utils:ByteBuffer) {
    let n : uint = 0
    let length : uint = 0
    let buffer = utils:ByteBuffer.new(24)
    let context = BlowfishContext {}
  
    eksBlowfishSetup(context, cost, salt, password);
  
    buffer.append_str("OrpheanBeholderScryDoubt")
  
    // Repeatedly encrypt the text "OrpheanBeholderScryDoubt" 64 times
    let i : uint = 0
    let data = buffer.data.to_ptr()
    while i < 64 {
       //Perform encryption using Blowfish in ECB mode
       blowfishEncryptBlock(context, data, data);
       blowfishEncryptBlock(context, data + 8, data + 8);
       blowfishEncryptBlock(context, data + 16, data + 16);
       i++
    }

    // bcrypt uses the $2a$ prefix in the hash string
    let hash_start = "$2a$%{ cost.to_base(10).pad_left('0', 2) }$"
  
    // Concatenate the salt and the ciphertext
    let buf1 = utils:ByteBuffer.new(24)
    buf1.append_str(salt)
    output.clear()
    output.append_str(hash_start)
    radix64_encode(buf1, output)
    radix64_encode(buffer, output)
}
  
// @brief Expensive key setup
// @param[in] context Pointer to the Blowfish context
// @param[in] cost Key expansion iteration count as a power of 2
// @param[in] salt Random salt
// @param[in] saltLen Length of the random salt, in bytes
// @param[in] password NULL-terminated password to be encoded
// @param[in] passwordLen Length of the password, in bytes
// @return Error code
  
fn eksBlowfishSetup(context: BlowfishContext, cost: uint, salt: String, password: String) {
    // Initialize Blowfish state
    blowfishInitState(context)
    // Perform the first key expansion
    blowfishExpandKey(context, salt, password);

    // The cost parameter specifies a key expansion iteration count as a power of two
    let n : u32 = 1.to(u32) << cost
    // Iterate as many times as desired
    let i : u32 = 0
    while i < n {
        // Perform key expansion with password
        blowfishExpandKey(context, NULL, 0, password) ! break
        // Perform key expansion with salt
        blowfishExpandKey(context, NULL, 0, salt) ! break
        i++
    }
}
