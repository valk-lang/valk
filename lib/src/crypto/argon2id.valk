
use mem
use gc

enum Argon2Type : u32 {
  d (0)
  i (1)
  id (2)
}

value ARGON2_VERSION (0x13)
value ARGON2_BLOCK_SIZE (1024)
value ARGON2_ADDRESSES_IN_BLOCK (128)
value ARGON2_PREHASH_DIGEST_LENGTH (64)
value ARGON2_PREHASH_SEED_LENGTH (72)
value ARGON2_SYNCPOINTS (4)

value ARGON2_QWORDS_IN_BLOCK (ARGON2_BLOCK_SIZE / 8)

class Argon2 {
    type: u32
    hashout: ptr
    hashlen: u32
    pwd: ?String (null)
    salt: ?String (null)
    secret: ?String (null)
    ad: ?String (null) // Associated data

    passes: u32
    threads: u32
    block_count: u32
    blocks_per_thread: u32

    data: ptr[[u64 x ARGON2_ADDRESSES_IN_BLOCK]]

    static fn new(type: Argon2Type, hashout: ptr, hashlen: u32, pwd: ?String, salt: ?String, secret: ?String, ad: ?String, passes: u32 (1), block_count: u32 (0), threads: u32 (1)) SELF {
        if threads < 1 : threads = 1
        if passes < 1 : passes = 1

        let st = ARGON2_SYNCPOINTS * threads
        // Rounding
        block_count = block_count / st * st
        // Fitting
        if block_count < 2 * st : block_count = 2 * st

        let blocks_per_thread = block_count / threads
        let data = mem:alloc(ARGON2_BLOCK_SIZE * block_count)

        return SELF {
            type: type
            hashout: hashout
            hashlen: hashlen

            pwd: pwd
            salt: salt
            secret: secret
            ad: ad

            passes: passes
            threads: threads
            block_count: block_count
            blocks_per_thread: blocks_per_thread
            data: data
        }
    }

    fn gc_free() {
        mem:free(this.data)
    }

    fn init() {
        let blockhash : [u8 x ARGON2_PREHASH_SEED_LENGTH] = [0...]
        this.init_hash(blockhash)
        this.init_start_blocks(blockhash)
    }

    fn init_hash(blockhash: ptr[u8 x 72]) {

        let value : [u8 x size_of(u32)] = [0...]

        let b = Blake2b.new(ARGON2_PREHASH_DIGEST_LENGTH, null) ! return

        u32.write_little_endian(this.threads, value)
        b.update(value, value.$length)

        u32.write_little_endian(this.hashlen, value)
        b.update(value, value.$length)

        u32.write_little_endian(this.passes, value)
        b.update(value, value.$length)

        u32.write_little_endian(this.block_count, value)
        b.update(value, value.$length)

        u32.write_little_endian(ARGON2_VERSION, value)
        b.update(value, value.$length)

        u32.write_little_endian(this.type, value)
        b.update(value, value.$length)

        let pwd = this.pwd
        if isset(pwd) {
            u32.write_little_endian(pwd.length.to(u32), value)
            b.update(value, value.$length)
            b.update(pwd.data, pwd.length)

        } else {
            u32.write_little_endian(0, value)
            b.update(value, value.$length)
        }

        let salt = this.salt
        if isset(salt) {
            u32.write_little_endian(salt.length.to(u32), value)
            b.update(value, value.$length)
            b.update(salt.data, salt.length)

        } else {
            u32.write_little_endian(0, value)
            b.update(value, value.$length)
        }

        let secret = this.secret
        if isset(secret) {
            u32.write_little_endian(secret.length.to(u32), value)
            b.update(value, value.$length)
            b.update(secret.data, secret.length)

        } else {
            u32.write_little_endian(0, value)
            b.update(value, value.$length)
        }

        let ad = this.ad
        if isset(ad) {
            u32.write_little_endian(ad.length.to(u32), value)
            b.update(value, value.$length)
            b.update(ad.data, ad.length)

        } else {
            u32.write_little_endian(0, value)
            b.update(value, value.$length)
        }

        b.finalize(blockhash)
    }

    fn init_start_blocks(blockhash: ptr[u8 x 72]) {
        let block : [u8 x 1024] = [0...]
        let blockhash_bytes = @ref(block)

        let thr : u32 = 0
        let threads = this.threads
        while thr < threads {
            // Per thread, we initialize the first 2 blocks

            u32.write_little_endian(0, blockhash + ARGON2_PREHASH_DIGEST_LENGTH)
            u32.write_little_endian(thr, blockhash + ARGON2_PREHASH_DIGEST_LENGTH + 4)

            argon2_blake2b(blockhash_bytes, ARGON2_BLOCK_SIZE, blockhash, ARGON2_PREHASH_SEED_LENGTH)
            argon2_load_block(@ref(this.data[thr * this.blocks_per_thread]), blockhash_bytes);

            u32.write_little_endian(1, blockhash + ARGON2_PREHASH_DIGEST_LENGTH)

            argon2_blake2b(blockhash_bytes, ARGON2_BLOCK_SIZE, blockhash, ARGON2_PREHASH_SEED_LENGTH)
            argon2_load_block(@ref(this.data[thr * this.blocks_per_thread + 1]), blockhash_bytes);

            thr++
        }
    }
}

fn key(password: String, salt: String, rounds: u32, memory: u32, threads: u8, keyLen: u32) String {
    return deriveKey(Argon2Type.i, password, salt, null, null, 0, rounds, memory, threads, keyLen)
}

fn deriveKey(mode: Argon2Type, password: String, salt: String, secret: ?String, data: ?ptr, data_len: u32, rounds: u32, memory: u32, threads: u32, keyLen: u32) String {
    if rounds < 1 : panic("argon2: number of rounds too small")
    if threads < 1 : panic("argon2: parallelism degree too low")
    let h0 = initHash(password, salt, secret, data, rounds, memory, threads, keyLen, mode)

    memory = memory / (syncPoints * threads) * (syncPoints * threads)
    if memory < 2 * syncPoints * threads {
        memory = 2 * syncPoints * threads
    }
    let B = initBlocks(&h0, memory, threads)
    processBlocks(B, time, memory, threads, mode)
    return extractKey(B, memory, threads, keyLen)
}


value syncPoints (4)
// const (
// 	blockLength = 128
// 	syncPoints  = 4
// )

// type block [blockLength]uint64

fn initHash(password: String, salt: String, key: ?String, data: ?ptr, rounds: u32, memory: u32, threads: u32, keyLen: u32, mode: int) [u8 x 72] {
  let h0 : [u8 x 72] = [0...]
  let params : [u8 x 24] = [0...]
  let tmp : [u8 x 4] = [0...]

  return h0
}

fn argon2_load_block(dst: ptr[u64], input: ptr) {
    let i = 0
    while i < ARGON2_QWORDS_IN_BLOCK {
        dst[i] = u64.read_little_endian(input + i * size_of(u64))
        i++
    }
}

fn processBlocks(B: []block, time, memory, threads uint32, mode int) {
    lanes := memory / threads
    segments := lanes / syncPoints

    processSegment := func(n, slice, lane uint32, wg *sync.WaitGroup) {
        var addresses, in, zero block
        if mode == argon2i || (mode == argon2id && n == 0 && slice < syncPoints/2) {
            in[0] = uint64(n)
            in[1] = uint64(lane)
            in[2] = uint64(slice)
            in[3] = uint64(memory)
            in[4] = uint64(time)
            in[5] = uint64(mode)
        }

        index := uint32(0)
        if n == 0 && slice == 0 {
            index = 2 // we have already generated the first two blocks
            if mode == argon2i || mode == argon2id {
                in[6]++
                processBlock(&addresses, &in, &zero)
                processBlock(&addresses, &addresses, &zero)
            }
        }

        offset := lane*lanes + slice*segments + index
        var random uint64
        for index < segments {
            prev := offset - 1
            if index == 0 && slice == 0 {
                prev += lanes // last block in lane
            }
            if mode == argon2i || (mode == argon2id && n == 0 && slice < syncPoints/2) {
                if index%blockLength == 0 {
                    in[6]++
                    processBlock(&addresses, &in, &zero)
                    processBlock(&addresses, &addresses, &zero)
                }
                random = addresses[index%blockLength]
            } else {
                random = B[prev][0]
            }
            newOffset := indexAlpha(random, lanes, segments, threads, n, slice, lane, index)
            processBlockXOR(&B[offset], &B[prev], &B[newOffset])
            index, offset = index+1, offset+1
        }
        wg.Done()
    }

    for n := uint32(0); n < time; n++ {
        for slice := uint32(0); slice < syncPoints; slice++ {
            var wg sync.WaitGroup
            for lane := uint32(0); lane < threads; lane++ {
                wg.Add(1)
                go processSegment(n, slice, lane, &wg)
            }
            wg.Wait()
        }
    }

}

fn argon2_blake2b(out: ptr[u8], outlen: u32, in: ptr, inlen: uint) {

    let outlen_bytes : [u8 x size_of(u32)] = [0...]
    let ret = -1;

    u32.write_little_endian(outlen, outlen_bytes)

    if (outlen <= BLAKE2B_OUTBYTES) {
        let b = Blake2b.new(outlen, null) ! return
        b.update(outlen_bytes, outlen_bytes.$length)
        b.update(in, inlen)
        b.finalize(out)
    } else {
        let toproduce : u32 = 0;
        let out_buffer : [u8 x BLAKE2B_OUTBYTES] = [0...]
        let in_buffer : [u8 x BLAKE2B_OUTBYTES] = [0...]

        let b = Blake2b.new(BLAKE2B_OUTBYTES, null) ! return
        b.update(outlen_bytes, outlen_bytes.$length)
        b.update(in, inlen)
        b.finalize(out_buffer)

        mem:copy(out_buffer, out, BLAKE2B_OUTBYTES / 2)
        out += BLAKE2B_OUTBYTES / 2;
        toproduce = outlen - BLAKE2B_OUTBYTES / 2;

        while toproduce > BLAKE2B_OUTBYTES {
            mem:copy(out_buffer, in_buffer, BLAKE2B_OUTBYTES)

            let b = Blake2b.new(BLAKE2B_OUTBYTES, null) ! return
            b.update(in_buffer, BLAKE2B_OUTBYTES)
            b.finalize(out_buffer)

            mem:copy(out_buffer, out, BLAKE2B_OUTBYTES / 2)
            out += BLAKE2B_OUTBYTES / 2;
            toproduce -= BLAKE2B_OUTBYTES / 2;
        }

        mem:copy(out_buffer, in_buffer, BLAKE2B_OUTBYTES)

        b = Blake2b.new(toproduce, null) ! return
        b.update(in_buffer, BLAKE2B_OUTBYTES)
        b.finalize(out_buffer)

        mem:copy(out_buffer, out, toproduce)
    }
}
