
+ value BLOCK_BYTES (128)
+ value KEY_BYTES (64)
+ value OUT_BYTES (64)
+ value IV_LEN (8)

+ macro ROR64 "(" V:word "," V:shift ")" <{
   return (word >> shift) | (word << (64 - shift))
}
+ macro G "(" V:a "," V:b "," V:c "," V:d "," V:x "," V:y ")" {
   a += b + x
   d = d ^ a
   d = ROR64(d, 32)
   c += d
   b = b ^ c
   b = ROR64(b, 24)
   a += b + y
   d = d ^ a
   d = ROR64(d, 16)
   c += d
   b = b ^ c
   b = ROR64(b, 63)
}

+ global IV : [u64 x 8] ([
    0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1
    0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179
])

+ global SIGMA : [[u8 x 16] x 12] ([
    [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 ]
    [ 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 ]
    [ 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 ]
    [  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 ]
    [  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 ]
    [  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 ]
    [ 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 ]
    [ 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 ]
    [  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 ]
    [ 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 ]
    [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 ]
    [ 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 ]
])

+ class Blake2b {
    h: [u64 x 8]
    t: [u64 x 2]
    f: [u64 x 2]
    buf: [u8 x 2*BLOCK_BYTES]
    buf_len: uint
}

// impl Copy for Blake2b {}
// impl Clone for Blake2b { fn clone(&self) -> Blake2b { *self } }

extend Blake2b {
    + static fn new(size: uint) Blake2b {
        // assert!(size > 0 && size <= OUT_BYTES)

        let param = encode_params(size.to(u8), 0)
        let state = IV

        let i = 0
        while i < IV_LEN {
            state[i] = state[i] ^ load64(&param[i*8])
            i++
        }

        return Blake2b {
            h: state
            t: [0, 0]
            f: [0, 0]
            buf: [0 ...]
            buf_len: 0
        }
    }

    + fn new_with_key(size: uint, key: String) Blake2b {
        // assert!(size > 0 && size <= OUT_BYTES)
        // assert!(key.len() > 0 && key.len() <= KEY_BYTES)

        let keylen = key.length
        let param = encode_params(size.to(u8), keylen.to(u8))
        let state = IV

        let i = 0
        while i < IV_LEN {
            state[i] = state[i] ^ load64(&param[i*8])
            i++
        }

        let b = Blake2b{
            h: state
            t: [0, 0]
            f: [0, 0]
            buf: [0...]
            buf_len: 0
        }

        let block : [u8 x BLOCK_BYTES] = [0...]
        i = 0
        while i < keylen : block[i] = key[i++]
        b.update(&block, block.$length)
        return b
    }

    + fn update(data: ptr[u8], length: uint) {

        // while bytes > 0 {
        // }
        let len = length

        while len > 0 {
            let left = this.buf_len
            let fill = 2 * BLOCK_BYTES - left

            if len > fill {
                let i = 0
                while i < fill {
                    this.buf[left+i] = data[i]
                    i++
                }
                this.buf_len += fill
                data = data + fill
                len -= fill
                //
                this.increment_counter(BLOCK_BYTES)
                this.compress()
                i = 0
                while i < BLOCK_BYTES {
                    this.buf[i] = this.buf[i+BLOCK_BYTES]
                    i++
                }
                this.buf_len -= BLOCK_BYTES
            } else {
                let i = 0
                while i < len {
                    this.buf[left+i] = data[i]
                    i++
                }
                this.buf_len += len
                data = data + len
                len -= len
            }
        }
    }

    + fn finalize(out: ptr[u8], out_len: uint) {
        let buf : [u8 x OUT_BYTES] = [0...]
        if this.buf_len > BLOCK_BYTES {
            this.increment_counter(BLOCK_BYTES)
            this.compress()
            let i = 0
            while i < BLOCK_BYTES {
                this.buf[i] = this.buf[i+BLOCK_BYTES]
                i++
            }
            this.buf_len -= BLOCK_BYTES
        }
        let n = this.buf_len
        this.increment_counter(n)
        this.f[0] = this.f[0] == 0 ? 1 : 0
        let i = this.buf_len
        while i < 2*BLOCK_BYTES {
            this.buf[i++] = 0
        }
        this.compress()
        i = 0
        while i < 8 {
            store64(&buf[i*8], this.h[i])
        }
        i = 0
        let min = out_len < OUT_BYTES ? out_len : OUT_BYTES
        while i < min {
            out[i] = buf[i]
            i++
        }
    }

    fn increment_counter(inc: u64) {
        this.t[0] += inc
        this.t[1] += this.t[0] < inc ? 1 : 0
    }

    fn compress() {
        let m : [u64 x 16] = [0...]
        let v : [u64 x 16] = [0...]
        let block = this.buf

        // assert!(block.len() >= BLOCK_BYTES)

        let i = 0
        while i < 16 {
            m[i] = load64(&block[i*8])
            i++
        }

        i = 0
        while i < 8 {
            v[i] = this.h[i]
            i++
        }

        v[ 8] = IV[0]
        v[ 9] = IV[1]
        v[10] = IV[2]
        v[11] = IV[3]
        v[12] = this.t[0] ^ IV[4]
        v[13] = this.t[1] ^ IV[5]
        v[14] = this.f[0] ^ IV[6]
        v[15] = this.f[1] ^ IV[7]

        i = 0
        while i < 12 {
            G(v[0], v[4], v[8],  v[12], m[SIGMA[i][0]], m[SIGMA[i][1]])
            G(v[1], v[5], v[9],  v[13], m[SIGMA[i][2]], m[SIGMA[i][3]])
            G(v[2], v[6], v[10], v[14], m[SIGMA[i][4]], m[SIGMA[i][5]])
            G(v[3], v[7], v[11], v[15], m[SIGMA[i][6]], m[SIGMA[i][7]])

            G(v[0], v[5], v[10], v[15], m[SIGMA[i][8]],  m[SIGMA[i][9]])
            G(v[1], v[6], v[11], v[12], m[SIGMA[i][10]], m[SIGMA[i][11]])
            G(v[2], v[7], v[8],  v[13], m[SIGMA[i][12]], m[SIGMA[i][13]])
            G(v[3], v[4], v[9],  v[14], m[SIGMA[i][14]], m[SIGMA[i][15]])
            i++
        }

        i = 0
        while i < 8 {
            this.h[i] = this.h[i] ^ (v[i] ^ v[i+8])
            i++
        }
    }
}

fn encode_params(size: u8, keylen: u8) [u8 x 64] {
    return [ size, keylen, 1, 1, 0... ]
}

fn load64(b: ptr[u8]) u64 {
    let v = 0
    let i = 0
    while i < 8 {
        v = v | (b[i].to(u64) << (8*i)) 
        i++
    }
    return v
}

fn store64(b: ptr[u8], v: u64) {
    let i = 0
    while i < 8 {
        b[i] = v.to(u8)
        v = v >> 8
        i++
    }
}
