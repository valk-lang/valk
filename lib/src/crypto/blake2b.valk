
use mem

+ value BLOCK_BYTES (128)
+ value KEY_BYTES (64)
+ value OUT_BYTES (64)
+ value IV_LEN (8)

+ macro ROR64 "(" V:word "," V:shift ")" <{
   return (word >> shift) | (word << (64 - shift))
}
+ macro G "(" V:a "," V:b "," V:c "," V:d "," V:x "," V:y ")" {
   a += b + x
   d = d ^ a
   d = ROR64(d, 32)
   c += d
   b = b ^ c
   b = ROR64(b, 24)
   a += b + y
   d = d ^ a
   d = ROR64(d, 16)
   c += d
   b = b ^ c
   b = ROR64(b, 63)
}

macro LOAD64LE "(" V:val ")" <{
    let v : u64 = val
    let r = (&v).@cast(ptr[u8])
    return r[0].to(u64) | (r[1].to(u64) << 8) | (r[2].to(u64) << 16) | (r[3].to(u64) << 24) | (r[4].to(u64) << 32) | (r[5].to(u64) << 40) | (r[6].to(u64) << 48) | (r[7].to(u64) << 56)
}

+ global IV : [u64 x 8] ([
    0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1
    0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179
])

+ global SIGMA : [[u8 x 16] x 12] ([
    [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 ]
    [ 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 ]
    [ 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 ]
    [  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 ]
    [  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 ]
    [  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 ]
    [ 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 ]
    [ 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 ]
    [  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 ]
    [ 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 ]
    [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 ]
    [ 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 ]
])

+ class Blake2b {
    h: [u64 x 8]
    total_size: [u64 x 2] ([0, 0])
    // f: [u64 x 2] ([0, 0])
    buf: [u8 x BLOCK_BYTES] ([0 ...])
    buf_len: uint (0)
    hash_size: uint

    static fn init_state(state: &[u64 x 8], hash_size: u8, keylen: u8) {
        // size, keylen, 1, 1, ...
        let s = state[0]
        //The first byte of the parameter block is the hash size in bytes
        s = s ^ hash_size;
        //The second byte of the parameter block is the key size in bytes
        s = s ^ (keylen << 8);
        //Bytes 2 and 3 are set as 01
        s = s ^ 0x01010000;
        state[0] = s
    }

    + static fn new(hash_size: uint, key: ?String (null)) Blake2b !invalid_hash_size !invalid_key {
        if hash_size == 0 : throw invalid_hash_size
        if hash_size > OUT_BYTES : throw invalid_hash_size

        let keylen = 0
        if isset(key) {
            keylen = key.length
            if keylen > KEY_BYTES : throw invalid_key
        }

        let state : [u64 x 8] = IV
        SELF.init_state(state, hash_size.to(u8), 0)

        let b = Blake2b { h: state, hash_size: hash_size }

        // Secret key
        if isset(key) {
           mem:copy(key.data, b.buf, keylen);
           b.buf_len = 128;
        }

        return b
    }

    + fn update(data: ptr[u8], length: uint) {

        let n = 0

        while length > 0 {
            if this.buf_len == 128 {
                this.compress()
                this.buf_len = 0
            }

            n = 128 - this.buf_len
            if length < n : n = length

            mem:copy(data, this.buf.@cast(ptr) + this.buf_len, n)
            this.buf_len += n
  
            data += n
            length -= n
        }
    }

    + fn finalize(out: ptr[u8], out_len: uint) {
        let block = this.buf
        let hash_size = this.hash_size

        let i = this.buf_len
        while i < 128 : block[i++] = 0
  
        this.compress(true)
  
        let out_index = 0
        i = 0
        while i < 8 {
            let u64v = this.h[i++]
            let count = 0
            while count++ < 8 && out_index < hash_size {
                out[out_index++] = (u64v & 0xFF).to(u8)
                u64v = u64v >> 8
            }
        }
    }

    fn compress(last: bool (false)) {
        let v : [u64 x 16] = [0...]
        let block = this.buf
        let block_len = this.buf_len

        if block_len > BLOCK_BYTES : panic("Blake2b overflow")

        let i = 0
        while i < 8 {
            //First half from state
            v[i] = this.h[i]
            //Second half from IV
            v[i + 8] = IV[i];
            i++
        }

        // Increment offset counter
        this.total_size[0] += block_len;
        // Propagate the carry if necessary
        if this.total_size[0] < block_len : this.total_size[1]++

        //Low word of the offset
        v[12] = v[12] ^ this.total_size[0];
        //High word of the offset
        v[13] = v[13] ^ this.total_size[1];
  
        if last : v[14] = v[14] ^ -1 // Invert bits

        // Convert from little-endian byte order to host byte order
        let buf64 : ptr[u64 x 16] = this.buf.@cast(ptr[u64 x 16])
        let m : [u64 x 16] = [0...]
        i = 0
        while i < 16 {
            m[i] = LOAD64LE(buf64[i]);
            i++
        }

        i = 0
        while i < 12 {
            G(v[0], v[4], v[8],  v[12], m[SIGMA[i][0]], m[SIGMA[i][1]])
            G(v[1], v[5], v[9],  v[13], m[SIGMA[i][2]], m[SIGMA[i][3]])
            G(v[2], v[6], v[10], v[14], m[SIGMA[i][4]], m[SIGMA[i][5]])
            G(v[3], v[7], v[11], v[15], m[SIGMA[i][6]], m[SIGMA[i][7]])

            G(v[0], v[5], v[10], v[15], m[SIGMA[i][8]],  m[SIGMA[i][9]])
            G(v[1], v[6], v[11], v[12], m[SIGMA[i][10]], m[SIGMA[i][11]])
            G(v[2], v[7], v[8],  v[13], m[SIGMA[i][12]], m[SIGMA[i][13]])
            G(v[3], v[4], v[9],  v[14], m[SIGMA[i][14]], m[SIGMA[i][15]])
            i++
        }

        i = 0
        while i < 8 {
            this.h[i] = this.h[i] ^ (v[i] ^ v[i+8])
            i++
        }
    }
}

// fn encode_params(size: u8, keylen: u8) [u8 x 64] {
//     return [ size, keylen, 1, 1, 0... ]
// }

// fn load64(b: ptr[u8]) u64 {
//     let v = 0
//     let i = 0
//     while i < 8 {
//         v = v | (b[i].to(u64) << (8*i)) 
//         i++
//     }
//     return v
// }

// fn store64(b: ptr[u8], v: u64) {
//     let i = 0
//     while i < 8 {
//         b[i] = v.to(u8)
//         v = v >> 8
//         i++
//     }
// }
