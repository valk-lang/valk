
use mem
use gc

class Coro {
    size: uint
    size_gc: uint
    stack: ?ptr
    stack_gc: ?ptr
    func: ptr
    error_code: u32 (0)
    error_msg: String ("")

    static fn init(func: ptr, size: uint, size_gc: uint) Coro {

        let stack = size > 0 ? mem:alloc(size) : null
        let stack_gc = size_gc > 0 ? mem:alloc(size_gc) : null

        return Coro {
            size: size
            size_gc: size_gc
            stack: stack
            stack_gc: stack_gc
            func: func
        }
    }

    fn _gc_mark(color: u16) {
        let stack = this.stack_gc
        if !isset(stack) : return
        let size = this.size_gc
        while size > 0 {
            let item = @ptrv(stack, ptr)
            if item != null {
                let vti = @ptrv(item, u16, -1)
                if vti > 0 {
                    let mark = @ptrv(gc:vtable, fn(ptr, u16)(), vti @as uint * gc:VTABLE_COLS)
                    mark(item, color)
                }
            }

            stack += sizeof(ptr)
            size -= sizeof(ptr)
        }
    }
}


// codegen COROGEN[bind_properties, return_properties, handler_type] {
//     struct Data {
//         #loop properties bind_properties as name, T 
//         #{name}: T
//         #end
//         #loop properties return_properties as name, T 
//         #{name}: T (@undefined)
//         #end
//     }

//     fn coro_init(
//         handler: ptr,
//         #loop properties bind_properties as name, T 
//         #{name}: T,
//         #end
//     ) Coro {
//         let data = Data {
//             #loop properties return_properties as name, T 
//             #{name}: #{name}
//             #end
//         }
//         return Coro {
//             handler: handler
//             data: data @as ptr
//             start_func: start_func @as ptr
//             result_func: result_func @as ptr
//             mark_func: mark_func @as ptr
//             demark_func: demark_func @as ptr
//             share_func: share_func @as ptr
//         }
//     }

//     fn start_func(coro: Coro) {
//         let data = coro.data as Data
//         let handler = coro.handler @as handler_type

//         (
//         #loop properties return_properties as name, T 
//         data.#{name}
//         #end
//         ) = handler(
//             #loop properties bind_properties as name, T 
//             #{name}: T,
//             #end
//         )
//         #if @type_can_error(handler_type)
//         ! {
//             coro.error = 1
//             coro.finished = true
//             return
//         }
//         #end
//         coro.finished = true
//     }

//     fn result_func(coro: Coro) return_properties {

//         let data = coro.data as Data

//         return (
//         #loop properties return_properties as name, T 
//         data.#{name},
//         #end
//         )
//     }
// }
