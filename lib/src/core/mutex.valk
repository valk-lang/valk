
header "sys" as sys

use coro
use io

#if OS == win
class MutexWait {
    iocp: FD
    coro: coro:Coro
}
#end

+ class Mutex[T] {
    #if !is_void_type(T)
    - value: T
    #end

    #if OS == linux || OS == macos
    - pipe: [i32 x 2] ({ 0... })
    #elif OS == win
    - locked: bool (false)
    - mutex: SyncMutex[void] (.new())
    - waiters: Array[MutexWait] (.new(128))
    #end

    + static fn new(value: T) SELF !create {
        #if !is_void_type(T)
        let m = SELF { value: value }
        #else
        let m = SELF {}
        #end

        #if OS == linux || OS == macos
        let res = sys:pipe(m.pipe)
        if res != 0 : throw create
        io:write_string(m.pipe[1], "v") ! throw create
        #elif OS == win
        #end
        return m
    }

    + fn await_unlock() {
        let buf : u8 = 0
        io:read_to_ptr(this.pipe[0], &buf, 0, 0) ! return
    }

    + fn lock() T {
        #if OS == linux || OS == macos
        let buf : u8 = 0
        io:read_to_ptr(this.pipe[0], &buf, 1, 0) ! return
        #elif OS == win
        #end

        #if !is_void_type(T)
        return this.value
        #end

        // let m = this.mutex
        // while true {
        //     m.lock()
        //     if this.locked {

        //         #if OS == linux
        //         let w = MutexWait {
        //             uring: io:uring()
        //             coro: coro:current_coro.@cast(coro:Coro)
        //         }
        //         #end

        //         this.waiters.append(w)
        //         m.unlock()
        //         coro:yield()
        //         continue
        //     }
        //     this.locked = true
        //     m.unlock()
        //     break
        // }
    }

    + fn unlock(value: T) {
        #if OS == linux || OS == macos
        io:write_string(this.pipe[1], "v") ! return
        #elif OS == win
        #end
        // let m = this.mutex
        // m.lock()
        // #if OS == linux
        // let waiters = this.waiters
        // each waiters as w {
        //     let ring = io:uring()
        //     let sqe = io:sqe(w.coro) ! panic("Failed to unlock Mutex")
        //     io:io_uring_prep_msg_ring(sqe, w.uring.ring_fd, w.coro)
        //     let s = io:uring_submit(ring) // We must submit instantly
        // }
        // waiters.clear()
        // #end
        // this.locked = false
        // m.unlock()
    }

    fn gc_free() {
        print("FREE LOCK\n")
        #if OS == linux || OS == macos
        io:close(this.pipe[0])
        io:close(this.pipe[1])
        #end
    }
}
