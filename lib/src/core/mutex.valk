
header "sys" as sys

use coro
use mem
use io

#if OS == win
class MutexWait {
    ov: io:OverlapData
    iocp: FD
}
#end

+ class Mutex[T] {
    #if !is_void_type(T)
    - value: T
    #end

    #if OS == linux || OS == macos
    - pipe: [i32 x 2] ({ 0... })
    #elif OS == win
    - locked: bool (false)
    - mutex: SyncMutex[void] (.new())
    - waits: Array[MutexWait] (.new(128))
    #end

    + static fn new(value: T) SELF !create {
        #if !is_void_type(T)
        let m = SELF { value: value }
        #else
        let m = SELF {}
        #end

        #if OS == linux || OS == macos
        let res = sys:pipe(@ref(m.pipe))
        if res != 0 : throw create
        io:write_string(m.pipe[1], "v") ! throw create
        #if OS == macos
        io:set_non_block(m.pipe[0], true)
        #end
        #end
        return m
    }

    + fn await_unlock() {
        #if OS == linux || OS == macos
        let buf : u8 = 0
        io:read_to_ptr(this.pipe[0], &buf, 1, 0) ! return
        io:write_string(this.pipe[1], "v") ! return
        #elif OS == win
        this.mutex.lock()
        if !this.locked {
            this.mutex.unlock()
            return
        }

        let ov = @stack(<io:OverlapData>)
        mem:clear(ov, size_of(<io:OverlapData>))
        ov.base.coro = coro:current_coro
        this.waits.append(MutexWait {
            iocp: io:iocp()
            ov: ov
        })
        this.mutex.unlock()
        coro:yield()
        #end
    }

    + fn lock() T {
        #if OS == linux || OS == macos
        let buf : u8 = 0
        io:read_to_ptr(this.pipe[0], &buf, 1, 0) _
        #elif OS == win
        while true {
            this.mutex.lock()
            if !this.locked {
                this.locked = true
                this.mutex.unlock()
                break
            }
            let ov = @stack(<io:OverlapData>)
            mem:clear(ov, size_of(<io:OverlapData>))
            ov.base.coro = coro:current_coro
            this.waits.append(MutexWait {
                iocp: io:iocp()
                ov: ov
            })
            this.mutex.unlock()
            coro:yield()
        }
        #end

        #if !is_void_type(T)
        return this.value
        #end
    }

    + fn unlock(value: T) {
        #if OS == linux || OS == macos
        io:write_string(this.pipe[1], "v") ! return
        #elif OS == win
        if !this.locked : return
        this.mutex.lock()
        each this.waits as w {
            let ok = sys:PostQueuedCompletionStatus(w.iocp, 0, 0, w.ov)
        }
        this.waits.clear()
        this.locked = false
        this.mutex.unlock()
        #end
    }

    fn gc_free() {
        #if OS == linux || OS == macos
        io:close(this.pipe[0])
        io:close(this.pipe[1])
        #end
    }
}
