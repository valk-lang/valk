
// class Coro[bind_types, arg_types, return_types] {
//     func: fn(bind_types, arg_types)(return_types)
//     finished: bool (false)

//     #type_list_to_named_type_list bind_types bind_types_named
//     #type_list_to_named_type_list arg_types arg_types_named
//     #type_list_to_named_type_list return_types return_types_named

//     // #define_properties bind_types_named as props
//     #loop named_type_list bind_types_named as name, T
//     #{name}: T (default_value_of(T))
//     #end

//     fn init(func: fn(bind_types, arg_types)(return_types), bind_types_named) SELF {
//         return SELF {
//             func: func
//             #loop named_type_list bind_types_named as name T
//             #{name}: #{name}
//             #end
//         }
//     }

//     fn run(arg_types_named) return_types {
//         return this.func(bind_types_named, arg_types_named)
//     }
// }

class Closure {
    size: uint
    size_gc: uint
    stack: ?ptr
    stack_gc: ?ptr
    func: ptr

    fn init[bind_types](func: ptr, bind_types) Closure {

        let size : uint = 0
        let size_gc : uint = 0

        #loop named_type_list args as name, T
        #is_gc_type(T)
        size_gc += sizeof(T)
        #else
        size += sizeof(T)
        #end
        #end

        let stack: size > 0 ? mem:alloc(size) : null
        let stack_gc: size_gc > 0 ? mem:alloc(size_gc) : null

        #loop named_type_list args as name, T
        #is_gc_type(T)
        @ptrv(stack_gc.offset(size_gc), T) = name
        size_gc += sizeof(T)
        #else
        @ptrv(stack.offset(size), T) = name
        size += sizeof(T)
        #end
        #end

        return SELF {
            size: size
            size_gc: size_gc
            stack: stack
            stack_gc: stack_gc
            func: func
        }
    }

    fn run[bind_types, arg_types, return_types](#declare_arguments(arg_types, args)) return_types {

        let func = this.func @as fn(bind_types, arg_types)(return_types)
        #func_call func as call

        #loop type_list bind_types as T
        {
            #is_gc_type(T)
            let v = @ptrv(stack_gc.offset(size_gc), T)
            size_gc += sizeof(T)
            #else
            let v = @ptrv(stack.offset(size), T)
            size += sizeof(T)
            #end
            #func_call_add_argument call v
        }
        #end
        
        #func_call_add_arguments call args
        return #func_call_run call
    }

    fn _gc_mark(color: u16) {
        let stack = this.stack_gc
        if !isset(stack) : return
        let size = this.size_gc
        while size > 0 {
            let item = @ptrv(stack, ptr)
            if item != null {
                let vti = @ptrv(item, u16, -1)
                if vti > 0 {
                    let mark = @ptrv(vtable, fn(ptr, u16)(), vti @as uint * VTABLE_COLS)
                    mark(item, color)
                }
            }

            stack += sizeof(ptr)
            size -= sizeof(ptr)
        }
    }
}

// fn closure_init[bind_types, arg_types, return_types](bind_types) Closure {
//     let size : uint = 0
//     let size_gc : uint = 0
//     #loop type_list bind_types as T
//     #is_gc_type(T)
//     size_gc += sizeof(T)
//     #else
//     size += sizeof(T)
//     #end
//     #end

//     let cl = Closure.init(size, size_gc)
//     let stack = cl.stack
//     let stack_gc = cl.stack_gc

//     size : uint = 0
//     size_gc : uint = 0
//     #loop type_list bind_types as T
//     #is_gc_type(T)
//     @ptrv(stack, T, size_gc) = 
//     size_gc += sizeof(T)
//     #else
//     size += sizeof(T)
//     #end
//     #end

//     return cl
// }

// fn closure_run[bind_types, arg_types, return_types](closure: Close, arg_types) return_types {
// }
