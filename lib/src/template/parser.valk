
use utils
use json
use fs

class Parser {
    parent: ?Parser (null)
    //
    path: ?String (null)
    content: String
    i: uint (0)
    line: uint (1)
    col: uint (1)
    spaces: uint (0)
    //
    data: json:Value
    scope: ?Scope (null)
    options: ?RenderOptions (null)
    token: utils:ByteBuffer (.new())
    result: utils:ByteBuffer (.new())

    fn render() String {
        let result = this.result
        let token = this.token
        let options = this.options
        let data = this.data
        let len = this.content.length
        let escaped = false

        while this.i < len {
            this.tok(true)
            // Add spaces
            let spaces = this.spaces
            while spaces-- > 0 : result.append_byte(' ')
            //
            if this.token_is("\\") && !escaped {
                escaped = true
                continue
            }
            // Handle token
            if !escaped {
                if this.token_is("@include") {
                    this.expect("(", false) ! return EMSG
                    this.expect("\"", false) ! return EMSG
                    let str = this.read_str() ! return EMSG

                    let dir : ?String = null
                    if isset(options) : dir = options.template_directory
                    if !isset(dir) : return this.error("Using @include without passing a template-directory path")

                    let sub_path = fs:add(dir, str)
                    let sub_content = fs:read(sub_path) ! return this.error("Template not found: " + sub_path)
                    let sub = Parser{
                        parent: this
                        path: sub_path
                        content: sub_content
                        data: data
                        options: options
                    }
                    result.append_str(sub.render())

                    this.expect(")", true) ! return EMSG
                    continue
                }
            }


            //
            if escaped {
                result.append_byte('\\')
                escaped = false
            }
            result.append(token)
        }

        return result
    }

    fn error(msg: String) String {
        return "[ Error at line " + this.line + " in " + (this.path ?? "{content}") + " | Error: " + msg + " ]"
    }

    fn expect(tok: String, allow_space: bool, update: bool (true)) !notfound {
        this.tok(allow_space, update)
        if !this.token_is(tok) : throw notfound, this.error("Expected '%{tok}' instead of '%{this.token}'")
    }

    fn read_str() String !missing_end {
        let token = this.token
        token.clear()

        let i = this.i
        let col = this.col
        let line = this.line

        let content = this.content
        let bytes = content.bytes
        while i < bytes{
            let ch = content.get(i)
            i++
            col++
            if ch == '\n' {
                line++
                col = 1
            } else if ch == '"' {
                this.i = i
                this.col = col
                this.line = line
                return token
            }
            token.append_byte(ch)
        }
        throw missing_end, this.error("Missing double-quote")
    }

    fn tok(allow_space: bool, update: bool (true)) {
        let token = this.token
        token.clear()

        let i = this.i
        let col = this.col
        let line = this.line
        let spaces = 0

        let content = this.content
        let bytes = content.bytes
        let is_str = false
        while i < bytes{
            let ch = content.get(i)
            i++
            col++
            if allow_space && ch == ' ' {
                spaces++
                continue
            }
            allow_space = false
            if ch.is_alpha() || ch == '_' || (ch == '@' && !is_str) {
                token.append_byte(ch)
                is_str = true
                continue
            }
            if is_str {
                i--
                col--
                break
            }
            token.append_byte(ch)
            if ch == '\n' {
                line++
                col = 1
            }
            //
            let nch = content.get(i)
            if
            (ch == '=' && nch == '=')
            || (ch == '!' && nch == '=')
            {
                i++
                col++
                token.append_byte(nch)
            }

            break
        }

        this.spaces = spaces
        if update {
            this.i = i
            this.col = col
            this.line = line
        }
    }

    fn token_is(tok: String) bool {
        return this.token.equals_str(tok)
    }
}