
use utils
use json
use fs

class Parser {
    parent: ?Parser (null)
    //
    path: ?String (null)
    content: String
    i: uint (0)
    line: uint (1)
    col: uint (1)
    spaces: uint (0)
    //
    data: json:Value
    scope: ?Scope (null)
    options: ?RenderOptions (null)
    token: utils:ByteBuffer (.new())
    result: utils:ByteBuffer (.new())
    //
    // ignore: bool (false)

    fn render() String {
        let result = this.result
        let token = this.token
        let options = this.options
        let data = this.data
        let len = this.content.length
        let escaped = false
        let ignore = false
        let ignore_depth = 1

        while this.i < len {
            this.tok(true)

            // Ignore
            if ignore {
                let con = true
                if this.token_is("@each") : ignore_depth++
                else if this.token_is("@if") : ignore_depth++
                else if this.token_is("@end") : ignore_depth--
                else if this.token_is("@else") {
                    let scope = this.scope
                    if ignore_depth == 1 && isset(scope) && scope.type == scope_type_if : ignore_depth--
                }
                if ignore_depth == 0 {
                    ignore = false
                    ignore_depth = 1
                    if this.token_is("@else") {
                        con = false
                    }
                } else if ignore_depth < 0 {
                    return this.error("Unexpected token: '%token'")
                }
                if con : continue
            }

            // Add spaces
            let spaces = this.spaces
            while spaces-- > 0 : result.append_byte(' ')
            //
            if this.token_is("\\") && !escaped {
                result.append_byte('\\')
                escaped = true
                continue
            }
            // Handle token
            if !escaped {
                if this.token_is("@include") {
                    this.expect("(", false) ! return EMSG
                    this.expect("\"", false) ! return EMSG
                    let str = this.read_str() ! return EMSG

                    let dir : ?String = null
                    if isset(options) : dir = options.template_directory
                    if !isset(dir) : return this.error("Using @include without passing a template-directory path")

                    let sub_path = fs:add(dir, str)
                    let sub_content = fs:read(sub_path) ! return this.error("Template not found: " + sub_path)
                    let sub = Parser{
                        parent: this
                        path: sub_path
                        content: sub_content
                        data: data
                        options: options
                    }
                    result.append_str(sub.render())

                    this.expect(")", true) ! return EMSG
                    continue
                }
                if this.token_is("@each") {
                    this.expect("(", false) ! return EMSG
                    let val = this.read_value() ! return EMSG
                    if !val.is_array() && !val.is_object() : return this.error("@each value must be an array or object")
                    this.expect("as", true) ! return EMSG
                    let vname = this.read_var_name() ! return EMSG
                    let kname : ?String = null
                    let iname : ?String = null
                    if this.next_is(",", true) {
                        kname = this.read_var_name() ! return EMSG
                        if this.next_is(",", true) {
                            iname = this.read_var_name() ! return EMSG
                        }
                    }

                    let scope = this.new_scope(scope_type_each)
                    this.scope = scope
                    scope.vname = vname
                    scope.kname = kname
                    scope.iname = iname
                    scope.list = val

                    if val.is_object() {
                        let vals = val.object_values
                        if isset(vals) : scope.list_keys = vals.keys()
                    }

                    scope.set_list_index(0) ! {
                        ignore = true
                    }

                    this.expect(")", true) ! return EMSG
                    scope.start = this.i
                    continue
                }
                if this.token_is("@end") {
                    let scope = this.scope
                    if !isset(scope) : return this.error("Unexpected token: '@end'")
                    let index = scope.index
                    let has_item = true
                    scope.set_list_index(index + 1) ! {
                        has_item = false
                        this.scope = scope.parent
                    }
                    if has_item : this.i = scope.start
                    continue
                }
                if this.token_is("{{") || this.token_is("{!") {
                    let raw = this.token_is("{!")
                    let val = this.read_value() ! return EMSG
                    result.append_str(val.to_string())
                    if raw : this.expect("!}", true, true) ! return EMSG
                    else : this.expect("}}", true, true) ! return EMSG
                    continue
                }
            }


            //
            escaped = false
            result.append(token)
        }

        return result
    }

    fn new_scope(type: int) Scope {
        return Scope {
            type: type
            parent: this.scope
            start: this.i
        }
    }

    fn read_value() json:Value !invalid {
        let data = this.data
        let token = this.token
        this.tok(true, true)
        let name : String = token
        let val : ?json:Value = null
        //
        let scope = this.scope
        while isset(scope) {
            let sd = scope.data
            if isset(sd) {
                let sv = sd.get(name) !? null
                if isset(sv) {
                    val = sv
                    break
                }
            }
            scope = scope.parent
        }
        if !isset(val) {
            if !data.has(name) : throw invalid, this.error("Data not found: '%name'")
            val = data.get(name)
        }

        while true {
            if !this.next_is(".", false) : break
            this.tok(false, true)
            let name : String = token
            if !val.has(name) : throw invalid, this.error("Property not found: '%name'")
            val = val.get(name)
        }

        return val
    }

    fn read_var_name() String !invalid {
        let data = this.data
        let token = this.token
        this.tok(true, true)
        let name : String = token
        if !name.get(0).is_alpha() : throw invalid, this.error("Invalid variable name syntax: '%name' ([a-zA-Z0-9_])")
        return name
    }

    fn error(msg: String) String {
        return "[ Error at line " + this.line + " in " + (this.path ?? "{content}") + " | Error: " + msg + " ]"
    }

    fn next_is(tok: String, allow_space: bool) bool {
        this.tok(allow_space, false)
        if !this.token_is(tok) : return false
        this.tok(allow_space, true)
        return true
    }

    fn expect(tok: String, allow_space: bool, update: bool (true)) !notfound {
        this.tok(allow_space, update)
        if !this.token_is(tok) : throw notfound, this.error("Expected '%{tok}' instead of '%{this.token}'")
    }

    fn read_str() String !missing_end {
        let token = this.token
        token.clear()

        let i = this.i
        let col = this.col
        let line = this.line

        let content = this.content
        let bytes = content.bytes
        while i < bytes{
            let ch = content.get(i)
            i++
            col++
            if ch == '\n' {
                line++
                col = 1
            } else if ch == '"' {
                this.i = i
                this.col = col
                this.line = line
                return token
            }
            token.append_byte(ch)
        }
        throw missing_end, this.error("Missing double-quote")
    }

    fn tok(allow_space: bool, update: bool (true)) {
        let token = this.token
        token.clear()

        let i = this.i
        let col = this.col
        let line = this.line
        let spaces = 0

        let content = this.content
        let bytes = content.bytes
        let is_str = false
        while i < bytes{
            let ch = content.get(i)
            i++
            col++
            if allow_space && ch == ' ' {
                spaces++
                continue
            }
            allow_space = false
            if ch.is_alpha() || ch == '_' || (is_str && ch.is_number()) || (ch == '@' && !is_str) {
                token.append_byte(ch)
                is_str = true
                continue
            }
            if is_str {
                i--
                col--
                break
            }
            token.append_byte(ch)
            if ch == '\n' {
                line++
                col = 1
            }
            //
            let nch = content.get(i)
            if
            (ch == '=' && nch == '=')
            || (ch == '!' && (nch == '=' || nch == '}')) // != !}
            || (ch == '{' && (nch == '{' || nch == '!')) // {{ {!
            || (ch == '}' && nch == '}')
            {
                i++
                col++
                token.append_byte(nch)
            }

            break
        }

        this.spaces = spaces
        if update {
            this.i = i
            this.col = col
            this.line = line
        }
    }

    fn token_is(tok: String) bool {
        return this.token.equals_str(tok)
    }
}