
use json
use fs
use utils

+ class RenderOptions {
    sanitize: ?fn(String)(String) (null)
    template_directory: ?String (null)
}

value scope_each (1)

- class Scope {
    type: int
    parent: ?Scope (null)
    start: int
    list: Array[json:Value] (.{})
    index: int (0)
    list_keys: ?Array[String] (null)
    list_item: json:Value (json:new_null())
    vname: String ("")
    kname: ?String (null)
    iname: ?String (null)
    ignore: bool (false)
    data: ?Map[json:Value] (null)
}

+ fn render(path: String, data: $T, options: ?RenderOptions (null)) String !FileNotFound {
    let d = json:value(data)
    let content = fs:read(path) ! throw FileNotFound, "File not found: " + path
    let p = Parser{
        path: path
        content: content
        data: d
        options: options
    }
    return p.render()
}

// + fn render_content(content: String, data: ?json:Value (null), options: ?RenderOptions (null), template_path: ?String (null), parent_scope: ?Scope (null)) String {

//     data = data ?? json:new_null()

//     let path = template_path
//     let dir = isset(options) ? options.template_directory : null
//     let scope : ?Scope = null

//     let token = utils:ByteBuffer.new(64)
//     let result = utils:ByteBuffer.new(256)
//     let bytes = content.bytes
//     let line : uint = 0
//     let c : uint = 0
//     let ignore = false

//     while(c < bytes){
//         let ch = content.get(c)
//         c++
//         if ch == '@' {
//             let c_tmp = c
//             tok(content, token, c, false, @ref(c))
//             let len = token.length
//             if(len > 0) {
//                 // Valid token
//                 if token.equals_str("include") {
//                     if !isset(dir) : return error(path, content, line, "Using @include without passing a template-directory path")

//                     let nc = expect(content, c, false, "(")
//                     if nc == 0 : return error(path, content, line, "Expected '(' after @include")
//                     c = nc
//                     nc = expect(content, c, true, "\"")
//                     if nc == 0 : return error(path, content, line, "Expected '\"' after @include(")
//                     c = nc
//                     let part = read_str(content, c) ! { return error(path, content, line, "Invalid string syntax") }
//                     let sub_path = fs:add(dir, part)
//                     let part_len = part.bytes
//                     c += part_len + 1
//                     // Load content
//                     let sub_content = fs:read(sub_path) ! return error(path, content, line, "Template not found: " + sub_path)
//                     // Render
//                     let part_str = render_content(sub_content, data, options, sub_path, scope)
//                     result.append_str(part_str)

//                     nc = expect(content, c, true, ")")
//                     if nc == 0 : return error(path, content, line, "Expected ')' at the end of the @include statement")
//                     c = nc
//                     continue
//                 } else if token.equals_str("each") {
//                     let nc = expect(content, c, false, "(")
//                     if nc == 0 : return error(path, content, line, "Expected '(' after @each")
//                     c = nc

//                     let list = read_data_item(content, token, @ref(c), data) ! return error(path, content, line, EMSG)
//                     if !list.is_array() && !list.is_object() : return error(path, content, line, "Value for @each must an array or object")

//                     nc = expect(content, c, true, "as")
//                     if nc == 0 : return error(path, content, line, "Expected 'as' after @each value")
//                     c = nc

//                     tok(content, token, c, true, @ref(c))
//                     let vname : String = token
//                     let kname : ?String = null
//                     let iname : ?String = null

//                     // key name
//                     nc = expect(content, c, true, ",")
//                     if nc != 0 {
//                         c = nc
//                         tok(content, token, c, true, @ref(c))
//                         kname = token
//                         // index name
//                         nc = expect(content, c, true, ",")
//                         if nc != 0 {
//                             c = nc
//                             tok(content, token, c, true, @ref(c))
//                             iname = token
//                         }
//                     }

//                     let ig = list.length() == 0
//                     let keys : ?Array[String] = null
//                     let item = json:new_null()
//                     let d : ?Map[json:Value] = null

//                     if !ig {
//                         item = list.get_index(0) !? item

//                         d = .{}
//                         d.set(vname, item)
//                         if list.is_array() {
//                             if isset(kname) : d.set(kname, json:new_int(0))
//                             if isset(iname) : d.set(iname, json:new_int(0))
//                         } else if list.is_object() {
//                             if isset(kname) : if isset(keys) : d.set(kname, json:new_string(keys.get(0) !? "-missing-key-"))
//                             if isset(iname) : d.set(iname, json:new_int(0))
//                         }
//                     }

//                     nc = expect(content, c, true, ")")
//                     if nc == 0 : return error(path, content, line, "Expected ')' at the end of the @include statement")
//                     c = nc

//                     let s = Scope {
//                         type: scope_each
//                         parent: scope
//                         list: list
//                         index: 0
//                         list_item: item
//                         start: c
//                         vname: vname
//                         kname: kname
//                         iname: iname
//                         ignore: ig
//                         data: d
//                     }

//                     scope = s
//                     continue
//                 }
//             }
//             c = c_tmp
//         }
//         if(ch == '{') {
//             let nch = content.get(c)
//             if(nch == '\\') {
//                 c++
//                 nch = content.get(c)
//             }else if(nch == '{') {
//                 c++
//                 let item = read_data_item(content, token, @ref(c), data) ! return error(path, content, line, EMSG)
//                 let val = item.string()
//                 if !item.is_string() : val = item.encode()

//                 let nc = expect(content, c, true, "}")
//                 if(nc == 0){
//                     return error(path, content, line, "Expected '}}' after variable name")
//                 }
//                 c = nc
//                 nc = expect(content, c, false, "}")
//                 if(nc == 0){
//                     return error(path, content, line, "Expected '}}' after variable name.")
//                 }
//                 c = nc

//                 result.append_str(val)
//                 continue
//             }
//         }
//         if(ch == '\n') {
//             line++
//         }
//         result.append_byte(ch)
//     }

//     return result.to_string()
// }

// fn error(path: ?String, content: String, line: uint, error: String) String {
//     return "[ Error at line " + line + " in " + (path ?? "content") + " | Error: " + error + " ]"
// }

// fn read_str(content: String, index: uint) String !invalid {
//     let result = utils:ByteBuffer.new(50)
//     let bytes = content.bytes
//     let c = index
//     while(c < bytes){
//         let ch = content.get(c)
//         c++
//         if(ch == '"'){
//             break
//         }
//         if(ch == '\n'){
//             throw invalid
//         }
//         result.append_byte(ch)
//     }
//     return result.to_string()
// }

// fn expect(content: String, index: uint, allow_space: bool, expect: String) uint {

//     let bytes = content.bytes
//     let c = index
//     if(allow_space) {
//         while(c < bytes){
//             let ch = content.get(c)
//             if(ch != ' '){
//                 break
//             }
//             c++
//         }
//     }

//     let ex_len = expect.bytes
//     if(bytes - c < ex_len) {
//         return 0
//     }

//     let xc : uint = 0
//     while(xc < ex_len){
//         let ch = content.get(c)
//         let cch = expect.get(xc)
//         c++
//         xc++
//         if(ch != cch){
//             // println(ch + " vs " + cch)
//             return 0
//         }
//     }

//     return c
// }

// fn tok(content: String, buf: utils:ByteBuffer, index: uint, allow_space: bool, c_ptr: ptr) {

//     buf.clear()
//     let bytes = content.bytes
//     let c = index
//     let is_str = false
//     while(c < bytes){
//         let ch = content.get(c)
//         c++
//         if allow_space && ch == ' ' : continue
//         allow_space = false
//         if ch.is_lower() || ch == '_' {
//             allow_space = false
//             buf.append_byte(ch)
//             is_str = true
//             continue
//         }
//         if is_str : c--
//         else: buf.append_byte(ch)
//         break
//     }
//     @ptrv(c_ptr, uint, 0) = c
// }

// fn read_data_item(content: String, token: utils:ByteBuffer, c: ptr[uint x 1], data: json:Value) json:Value !invalid{

//     let item = data

//     while true {
//         tok(content, token, c[0], true, c)
//         let name : String = token
//         if !item.has(name) : throw invalid, "Unknown variable: '" + name + "'"
//         item = item.get(name)

//         let before = c[0]
//         tok(content, token, c[0], false, c)
//         if token.equals_str(".") : continue
//         c[0] = before
//         break
//     }

//     return item
// }