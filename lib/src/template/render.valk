
use json
use fs
use utils

// + fn render_path(path: String, data: $T, template_directory: String (fs:cwd())) String !FileNotFound !DirectoryNotFound {
//     let d = json:value(data)
//     let content = fs:read(path) !FileNotFound
//     let e = Engine.new(template_directory)
//     return e.render(content, d)
// }

// + fn render(content: String, data: $T, template_directory: String (fs:cwd())) String !FileNotFound !DirectoryNotFound {
//     let d = json:value(data)
//     let content = fs:read(path) !FileNotFound
//     let e = Engine.new(template_directory)
//     return e.render(content, d)
// }

+ class Engine {
    + dir: String

    static fn new(template_directory: String (fs:cwd())) Engine {
        return SELF {
            dir: template_directory
        }
    }

    + fn render(path: String, data: ?json:Value (null)) String !FileNotFound {
        let full = fs:add(this.dir, path)
        let content = fs:read(full) ! throw FileNotFound, "File not found: " + path
        return this.render_content(content, data, path)
    }

    + fn render_content(content: String, data: ?json:Value (null), path: String ("/")) String {

        data = data ?? json:null_value()

        let dir = this.dir
        let token = utils:ByteBuffer.new(64)
        let result = utils:ByteBuffer.new(256)
        let bytes = content.bytes
        let line : uint = 0
        let c : uint = 0

        while(c < bytes){
            let ch = content.get(c)
            c++
            if ch == '@' {
                let c_tmp = c
                SELF.token(content, token, c, false, @ref(c))
                let len = token.length
                if(len > 0) {
                    // Valid token
                    if token.equals_str("include") {
                        let nc = SELF.expect(content, c, true, "\"")
                        if nc == 0 : return SELF.error(path, content, line, "Expected '\"' after @include")
                        c = nc
                        let part = SELF.read_str(content, c) ! { return SELF.error(path, content, line, "Invalid string syntax") }
                        let sub_path = fs:add(dir, part)
                        let part_len = part.bytes
                        c += part_len + 1
                        // Load content
                        let content = fs:read(sub_path) ! return SELF.error(path, content, line, "Template not found: " + sub_path)
                        // Render
                        let part_str = this.render_content(content, data, sub_path)
                        result.append_str(part_str)
                        continue
                    }
                }
                c = c_tmp
            }
            if(ch == '{') {
                let nch = content.get(c)
                if(nch == '\\') {
                    c++
                    nch = content.get(c)
                }else if(nch == '{') {
                    c++
                    let val = "?"
                    let item = data

                    while true {
                        SELF.token(content, token, c, true, @ref(c))
                        let name : String = token
                        if !item.has(name) : return SELF.error(path, content, line, "Unknown variable: '" + name + "'")
                        item = item.get(name)
                        val = item.string()
                        if !item.is_string() : val = item.encode()

                        let before = c
                        SELF.token(content, token, c, false, @ref(c))
                        if token.equals_str(".") : continue
                        c = before
                        break
                    }

                    let nc = SELF.expect(content, c, true, "}")
                    if(nc == 0){
                        return SELF.error(path, content, line, "Expected '}}' after variable name")
                    }
                    c = nc
                    nc = SELF.expect(content, c, false, "}")
                    if(nc == 0){
                        return SELF.error(path, content, line, "Expected '}}' after variable name.")
                    }
                    c = nc

                    result.append_str(val)
                    continue
                }
            }
            if(ch == '\n') {
                line++
            }
            result.append_byte(ch)
        }

        return result.to_string()
    }

    - static fn error(path: String, content: String, line: uint, error: String) String {
        return "[ Error at line " + line + " in " + path + " | Error: " + error + " ]"
    }

    - static fn read_str(content: String, index: uint) String !invalid {
        let result = utils:ByteBuffer.new(50)
        let bytes = content.bytes
        let c = index
        while(c < bytes){
            let ch = content.get(c)
            c++
            if(ch == '"'){
                break
            }
            if(ch == '\n'){
                throw invalid
            }
            result.append_byte(ch)
        }
        return result.to_string()
    }

    - static fn expect(content: String, index: uint, allow_space: bool, expect: String) uint {

        let bytes = content.bytes
        let c = index
        if(allow_space) {
            while(c < bytes){
                let ch = content.get(c)
                if(ch != ' '){
                    break
                }
                c++
            }
        }

        let ex_len = expect.bytes
        if(bytes - c < ex_len) {
            return 0
        }

        let xc : uint = 0
        while(xc < ex_len){
            let ch = content.get(c)
            let cch = expect.get(xc)
            c++
            xc++
            if(ch != cch){
                // println(ch + " vs " + cch)
                return 0
            }
        }

        return c
    }

    - static fn token(content: String, buf: utils:ByteBuffer, index: uint, allow_space: bool, c_ptr: ptr) {

        buf.clear()
        let bytes = content.bytes
        let c = index
        let is_str = false
        while(c < bytes){
            let ch = content.get(c)
            c++
            if allow_space && ch == ' ' : continue
            allow_space = false
            if ch.is_lower() || ch == '_' {
                allow_space = false
                buf.append_byte(ch)
                is_str = true
                continue
            }
            if is_str : c--
            else: buf.append_byte(ch)
            break
        }
        @ptrv(c_ptr, uint, 0) = c
    }
}

