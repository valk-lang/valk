
use json
use fs
use utils

+ fn render(path: String, data: $T, template_directory: ?String (null)) String !FileNotFound {
    let dir = template_directory ?? fs:dir_of(path)
    let d = json:value(data)
    let content = fs:read(path) ! throw FileNotFound, "File not found: " + path
    return render_content(content, d, dir, path)
}

+ fn render_content(content: String, data: ?json:Value (null), template_directory: ?String (null), template_path: ?String (null)) String {

    data = data ?? json:null_value()

    let path = template_path
    let dir = template_directory

    let token = utils:ByteBuffer.new(64)
    let result = utils:ByteBuffer.new(256)
    let bytes = content.bytes
    let line : uint = 0
    let c : uint = 0

    while(c < bytes){
        let ch = content.get(c)
        c++
        if ch == '@' {
            let c_tmp = c
            tok(content, token, c, false, @ref(c))
            let len = token.length
            if(len > 0) {
                // Valid token
                if token.equals_str("include") {
                    if !isset(dir) : return error(path, content, line, "Using @include without passing a template-directory path")

                    let nc = expect(content, c, true, "\"")
                    if nc == 0 : return error(path, content, line, "Expected '\"' after @include")
                    c = nc
                    let part = read_str(content, c) ! { return error(path, content, line, "Invalid string syntax") }
                    let sub_path = fs:add(dir, part)
                    let part_len = part.bytes
                    c += part_len + 1
                    // Load content
                    let content = fs:read(sub_path) ! return error(path, content, line, "Template not found: " + sub_path)
                    // Render
                    let part_str = render_content(content, data, dir, sub_path)
                    result.append_str(part_str)
                    continue
                }
            }
            c = c_tmp
        }
        if(ch == '{') {
            let nch = content.get(c)
            if(nch == '\\') {
                c++
                nch = content.get(c)
            }else if(nch == '{') {
                c++
                let val = "?"
                let item = data

                while true {
                    tok(content, token, c, true, @ref(c))
                    let name : String = token
                    if !item.has(name) : return error(path, content, line, "Unknown variable: '" + name + "'")
                    item = item.get(name)
                    val = item.string()
                    if !item.is_string() : val = item.encode()

                    let before = c
                    tok(content, token, c, false, @ref(c))
                    if token.equals_str(".") : continue
                    c = before
                    break
                }

                let nc = expect(content, c, true, "}")
                if(nc == 0){
                    return error(path, content, line, "Expected '}}' after variable name")
                }
                c = nc
                nc = expect(content, c, false, "}")
                if(nc == 0){
                    return error(path, content, line, "Expected '}}' after variable name.")
                }
                c = nc

                result.append_str(val)
                continue
            }
        }
        if(ch == '\n') {
            line++
        }
        result.append_byte(ch)
    }

    return result.to_string()
}

fn error(path: ?String, content: String, line: uint, error: String) String {
    return "[ Error at line " + line + " in " + (path ?? "content") + " | Error: " + error + " ]"
}

fn read_str(content: String, index: uint) String !invalid {
    let result = utils:ByteBuffer.new(50)
    let bytes = content.bytes
    let c = index
    while(c < bytes){
        let ch = content.get(c)
        c++
        if(ch == '"'){
            break
        }
        if(ch == '\n'){
            throw invalid
        }
        result.append_byte(ch)
    }
    return result.to_string()
}

fn expect(content: String, index: uint, allow_space: bool, expect: String) uint {

    let bytes = content.bytes
    let c = index
    if(allow_space) {
        while(c < bytes){
            let ch = content.get(c)
            if(ch != ' '){
                break
            }
            c++
        }
    }

    let ex_len = expect.bytes
    if(bytes - c < ex_len) {
        return 0
    }

    let xc : uint = 0
    while(xc < ex_len){
        let ch = content.get(c)
        let cch = expect.get(xc)
        c++
        xc++
        if(ch != cch){
            // println(ch + " vs " + cch)
            return 0
        }
    }

    return c
}

fn tok(content: String, buf: utils:ByteBuffer, index: uint, allow_space: bool, c_ptr: ptr) {

    buf.clear()
    let bytes = content.bytes
    let c = index
    let is_str = false
    while(c < bytes){
        let ch = content.get(c)
        c++
        if allow_space && ch == ' ' : continue
        allow_space = false
        if ch.is_lower() || ch == '_' {
            allow_space = false
            buf.append_byte(ch)
            is_str = true
            continue
        }
        if is_str : c--
        else: buf.append_byte(ch)
        break
    }
    @ptrv(c_ptr, uint, 0) = c
}

