
@ignore_access

header "sys" as sys

use gc
use io
use coro
use core

#if OS != win
use mem
#end

global current_thread: ?Thread (null)

+ fn start(func: fn()()) Thread !start {
    let t = Thread {
        handler: func
    }
    t.init() !>
    return t
}

#if OS == win
class OverlapShare {
    ov: io:OverlapData
    iocp: sys:HANDLE
}
#end

+ class Thread {
    #if OS == win
    - thread: sys:HANDLE (0)
    #else
    - thread: ?ptr
    #end
    - handler: fn()()
    ~ finished: bool (false)
    #if OS == linux
    - efd: i32 (sys:eventfd(0, 0))
    #elif OS == macos
    - pipe: [i32 x 2] ({ 0... })
    #elif OS == win
    - mutex: core:Mutex[void] (core:Mutex[void].new())
    - overlaps: Array[OverlapShare] (.{})
    #end

    + static fn start(func: fn()()) SELF !start {
        let t = SELF {
            handler: func
        }
        t.init() !>
        return t
    }
    + static fn start_unsafe(func: fn()()) SELF !start {
        let t = SELF {
            handler: func
        }
        t.init() !>
        return t
    }

    fn init() !start $undefined {
        #if OS == macos
        sys:pipe(@ref(this.pipe))
        #elif OS == win
        #end

        gc:share(this)

        #if OS == win
        this.thread = sys:CreateThread(null, 0, this.entry, this, 0, null)
        #else
        let thr = sys:pthread_t{ data: 0 }
        let err = sys:pthread_create(thr, null, this.entry, this)
        if err != 0 : throw start
        this.thread = thr
        #end
    }

    fn entry() $entrance {

        // Init
        gc:stack_top = gc:stack_root
        gc:thread_init()

        @allocas

        // Store globals & Set default value (local only)
        #loop globals G T
        #if !global_is_shared(G)
        G = @global_default_value(G)
        #if is_gc_type(T)
        gc:gc.globals.add_ptr(@ref(G))
        #end
        #end
        #end

        current_thread = this
        gc:gc.disable = false

        // Run
        let run_until = (co this.handler()).@cast(coro:Coro)
        coro:Coro.loop(run_until)

        // Stop
        this.finished = true
        #if OS == linux
        io:write_string(this.efd, "mustbe8b") _ // Must be exactly 8 bytes long
        #elif OS == macos
        io:write_string(this.pipe[1], "x") _
        io:close(this.pipe[1])
        #elif OS == win
        this.mutex.lock()
        each this.overlaps as os {
            let ok = sys:PostQueuedCompletionStatus(os.iocp, 0, 0, os.ov)
        }
        this.mutex.unlock()
        #end
        gc:thread_stop()
    }

    + fn wait() {
        if this.finished : return
        let thr = this.thread
        #if OS == win

        this.mutex.lock()
        if this.finished {
            this.mutex.unlock()
            return
        }
        let ov = io:overlap[io:OverlapData]()
        this.overlaps.append(OverlapShare {
            iocp: io:iocp()
            ov: ov
        })
        this.mutex.unlock()
        coro:block()
        io:free_ov(ov)
        #else
        if isset(thr) {
            #if OS == linux
            coro:await_fd(this.efd, true, false)
            #elif OS == macos
            coro:await_fd(this.pipe[0], true, false)
            #else
            panic("Unsupported OS: thread wait")
            #end
        }
        #end
    }

    fn gc_free() {
        let thr = this.thread
        #if OS == win
        sys:CloseHandle(thr)
        #else
        if isset(thr) : mem:free(thr)
        #end

        #if OS == linux
        io:close(this.efd)
        #elif OS == macos
        io:close(this.pipe[0])
        #end
    }
}
