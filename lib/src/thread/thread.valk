
@ignore_access

use ext

use gc
use core
use coro
use mem

global current_thread: ?Thread (null)

+ fn start(func: fn()()) Thread !start {
    return Thread.start(func) !>
}

+ class Thread {
    #if OS == win
    - thread: ext:HANDLE (0)
    #else
    - thread: ?ptr
    #end
    - handler: fn()()
    ~ finished: bool (false)
    - mutex: core:Mutex[void]

    + static fn start(func: fn()()) SELF !start {
        let t = SELF {
            handler: func
            mutex: .new() ! throw start
        }
        t.init() !>
        return t
    }

    fn init() !start $undefined {
        //
        this.mutex.lock()

        gc:share(this)

        #if OS == win
        this.thread = ext:CreateThread(null, 0, this.entry, this, 0, null)
        #else
        let thr = ext:pthread_t{ data: 0 }
        let err = ext:pthread_create(thr, null, this.entry, this)
        if err != 0 : throw start
        this.thread = thr
        #end
    }

    fn entry() $entrance {

        // Init
        coro:gc_stack_sp = @ref(coro:gc_stack)
        gc:thread_init()

        @allocas

        // Store globals & Set default value (local only)
        ir_comment("INIT GLOBALS")
        #loop globals G T
        #if !global_is_shared(G)
        G = @global_default_value(G)
        #if is_gc_type(T)
        gc:gc.globals.add_ptr(@ref(G))
        #end
        #end
        #end
        ir_comment("END GLOBALS")

        current_thread = this
        gc:gc.disable = false

        // Run
        await co this.handler()

        // Stop
        this.finished = true
        this.mutex.unlock()
        gc:thread_stop()
    }

    + fn wait() {
        if this.finished : return
        this.mutex.await_unlock()
    }

    fn gc_free() {
        let thr = this.thread
        #if OS == win
        ext:CloseHandle(thr)
        #else
        if isset(thr) : mem:free(thr)
        #end
    }
}
