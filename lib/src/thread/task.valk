
use time
use core

shared task_gate : ThreadSuspendGate (.new() ! panic("Failed to create task scheduler"))
shared tasks : Array[Task] (.{})
shared threads_waiting : uint (0)

+ fn task(handler: fn()()) Task !error {
    let task = Task {
        handler: handler
        mutex: .new() ! throw error
    }
    tasks.append(task)
    start_taskrunner() ! throw error
    return task
}

+ class Task {
    - handler: fn()()
    - mutex: core:Mutex
    ~ started: bool (false)
    ~ done: bool (false)

    + fn await() {
        if this.done : return
        while !this.started : time:sleep_ns(10)
        this.mutex.await_unlock()
    }
}

fn start_taskrunner() !error {

    if threads_waiting == 0 {
        // Start new runner
        start(fn() {
            while true {
                let task = tasks.pop_last() !? null
                if !isset(task) {
                    atomic(threads_waiting + 1)
                    let timed_out = task_gate.wait(fn() bool { return tasks.length == 0 }, 5000)
                    atomic(threads_waiting - 1)
                    task = tasks.pop_last() !? null
                    if !isset(task) {
                        if timed_out : break
                        continue
                    }
                }
                task.mutex.lock()
                task.started = true
                task.handler()
                task.done = true
                task.mutex.unlock()
            }
        }) ! {
            throw error
        }
    }
    // Continue existing runners
    task_gate.signal()
}

