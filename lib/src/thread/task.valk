
use time

shared tasks : Array[Task] (.{})
shared threads_waiting : uint (0)

+ fn task(handler: fn()()) Task !error {
    let task = Task {
        handler: handler
    }
    tasks.append(task)
    start_taskrunner()
    return task
}

shared task_gate : ThreadSuspendGate (.new() ! panic("Failed to create task scheduler"))

+ class Task {
    - handler: fn()()
    ~ done: bool (false)

    + fn await() {
        if this.done : return

        while !this.done {
            time:sleep_ns(10)
        }
    }
}

fn start_taskrunner() {

    if threads_waiting == 0 {
        // Start new runner
        start(fn() {
            while true {
                let task = tasks.pop_last() !? null
                if !isset(task) {
                    atomic(threads_waiting + 1)
                    let timed_out = task_gate.wait(fn() bool { return tasks.length == 0 }, 5000)
                    atomic(threads_waiting - 1)
                    task = tasks.pop_last() !? null
                    if !isset(task) {
                        if timed_out : break
                        continue
                    }
                }
                task.handler()
                task.done = true
            }
        }) ! {
            println("Failed to start task-runner")
        }
    }
    // Continue existing runners
    task_gate.signal()
}

