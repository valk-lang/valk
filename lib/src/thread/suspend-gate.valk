
use ext
use gc

+ class ThreadSuspendGate {
    #if OS == win
    crit: <ext:CRITICAL_SECTION> (@undefined)
    var: <ext:CONDITION_VARIABLE> (@undefined)
    #else
    mutex: <ext:pthread_mutex_t> ({})
    cond: <ext:pthread_cond_t> ({})
    #end
    ready: bool (false)

    + static fn new() SELF !error {
        let sig = SELF{}
        #if OS == win
        ext:InitializeCriticalSection(sig.crit)
        ext:InitializeConditionVariable(sig.var)
        #else
        ext:pthread_mutex_init(sig.mutex, null)
        ext:pthread_cond_init(sig.cond)
        #end
        return sig
    }

    + fn wait(should_wait: fn()(bool), timeout_ms: uint (0)) bool {
        let is_timeout = false
        #if OS == win
        if timeout_ms == 0 : timeout_ms = ext:INFINITE
        while should_wait() {
            gc:unlock()
            ext:EnterCriticalSection(this.crit)
            let ok = ext:SleepConditionVariableCS(this.var, this.crit, timeout_ms.to(u32))
            if !ok && ext:GetLastError() == ext:ERROR_TIMEOUT {
                is_timeout = true
                break
            }
            ext:LeaveCriticalSection(this.crit)
            gc:lock()
        }
        #else
        let until : <ext:libc_timespec> = @undefined
        if timeout_ms > 0 {
            let now : <ext:libc_timeval> = @undefined
            ext:gettimeofday(now, null)
            let ns = now.tv_usec * 1000 + (timeout_ms % 1000) * 1_000_000
            let extra_s = (ns >= 1_000_000_000).to(int)
            until.tv_sec = now.tv_sec + (timeout_ms / 1000) + extra_s
            until.tv_nsec = ns - extra_s * 1_000_000_000
        }
        //
        while should_wait() {
            gc:unlock()
            ext:pthread_mutex_lock(this.mutex)
            if timeout_ms == 0 {
                ext:pthread_cond_wait(this.cond, this.mutex)
            } else {
                let err = ext:pthread_cond_timedwait(this.cond, this.mutex, until)
                if err == ext:ETIMEDOUT {
                    is_timeout = true
                    break
                }
            }
            ext:pthread_mutex_unlock(this.mutex)
            gc:lock()
        }
        #end
        return is_timeout
    }

    + fn signal() {
        #if OS == win
        ext:EnterCriticalSection(this.crit)
        ext:WakeConditionVariable(this.var)
        ext:LeaveCriticalSection(this.crit)
        #else
        ext:pthread_mutex_lock(this.mutex)
        ext:pthread_cond_signal(this.cond)
        ext:pthread_mutex_unlock(this.mutex)
        #end
    }

    fn gc_free() {
        #if OS == win
        ext:DeleteCriticalSection(this.crit)
        #else
        ext:pthread_mutex_destroy(this.mutex)
        ext:pthread_cond_destroy(this.cond)
        #end
    }
}
