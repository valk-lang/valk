
struct OVERLAPPED {
    Internal: uint
    InternalHigh: uint
    Offset: u32
    OffsetHigh: u32
    hEvent: HANDLE
}

extern fn CreateIoCompletionPort(FileHandle: ptr, ExistingCompletionPort: ?ptr, CompletionKey: uint, NumberOfConcurrentThreads: u32) HANDLE;
extern fn GetQueuedCompletionStatus(CompletionPort: ptr, lpNumberOfBytesTransferred: ptr, lpCompletionKey: ptr, lpOverlapped: ptr, dwMilliseconds: u32) bool;
extern fn PostQueuedCompletionStatus(CompletionPort: HANDLE, dwNumberOfBytesTransferred: u32, dwCompletionKey: uint, lpOverlapped: ?ptr) bool;
extern fn SetFileCompletionNotificationModes(FileHandle: HANDLE, Flags: u8) bool;
extern fn GetOverlappedResult(s: SOCKET, lpOverlapped: ptr, lpcbTransfer: &u32, fWait: bool) bool;
extern fn WSAGetOverlappedResult(s: SOCKET, lpOverlapped: ptr, lpcbTransfer: &u32, fWait: bool, flags: &u32) bool;

extern fn NtAssociateWaitCompletionPacket(WaitCompletionPacketHandle: HANDLE, IoCompletionHandle: HANDLE, TargetObjectHandle: HANDLE, KeyContext: ?ptr, ApcContext: ?ptr, IoStatus: i32, IoStatusInformation: uint, AlreadySignaled: ?&bool) i32;
extern fn NtCreateWaitCompletionPacket(WaitCompletionPacketHandle: &HANDLE, DesiredAccess: u32, ObjectAttributes: ?ptr) i32;
