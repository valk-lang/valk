
// #if OS == win
extern shared stderr : ?ptr;
extern shared stdin : ?ptr;
extern shared stdout : ?ptr;

alias FILE for ptr
alias SOCKET for uint
alias HANDLE for uint
alias BOOLEAN for u8

// DWORD : u32
// ULONG : u32

alias read for _read;
alias write for _write;
alias open for _open;
alias close for _close;
alias sync for _flushall;

alias stat for _stat;
alias mkdir for _mkdir;
alias rmdir for _rmdir;
alias unlink for _unlink;

alias popen for _popen;
alias pclose for _pclose;
alias getcwd for _getcwd;
alias chdir for _chdir;

alias poll for WSAPoll;

extern fn malloc(size: uint) ptr;
extern fn free(adr: ptr) void;

extern fn getenv(key: cstring) ?cstring;
extern fn GetLastError() u32;

extern fn _setmode(fd: i32, mode: i32) i32;
extern fn _read(fd: i32, buf: cstring, size: u32) int;
extern fn _write(fd: i32, buf: cstring, size: u32) int;
extern fn _open(path: cstring, flags: i32, mode: i32) i32;
extern fn _close(fd: i32) i32;

extern fn recv(fd: uint, buf: ptr, len: i32, flags: i32) i32;
extern fn send(fd: uint, buf: ptr, len: i32, flags: i32) i32;

// Files
extern fn _stat(path: cstring, stat_buf: libc_stat) i32;
extern fn fstat(fd: i32, stat_buf: libc_stat) i32;
extern fn lstat(path: cstring, stat_buf: libc_stat) i32;

extern fn FindFirstFileA(lpFileName: cstring, lpFindFileData: ptr) ptr;
extern fn FindNextFileA(hFindFile: ptr, lpFindFileData: ptr) bool;
extern fn FindClose(hFindFile: ptr) bool;

extern fn ReadFile(hFile: uint, lpBuffer: ptr, nNumberOfBytesToRead: u32, lpNumberOfBytesRead: ?ptr, lpOverlapped: ?ptr) bool;
extern fn WriteFile(hFile: uint, lpBuffer: ptr, nNumberOfBytesToWrite: u32, lpNumberOfBytesWritten: ?ptr, lpOverlapped: ?ptr) bool;
extern fn CreateFileA(path: cstring, access: u32, share_mode: u32, lpSecurityAttributes: ?ptr, dwCreationDisposition: u32, dwFlagsAndAttributes: u32, hTemplateFile: HANDLE) HANDLE;

// OS
extern fn _popen(command: cstring, type: cstring) ?FILE;
extern fn fgets(s: cstring, n: i32, stream: FILE) ?cstring;
extern fn _pclose(stream: FILE) i32;
extern fn system(cmd: cstring) i32;
extern fn Sleep(ms: u32) void;

extern fn srand(seed: u32);
extern fn rand() i32;

// Poll
extern fn WSAPoll(fds: ptr, nfds: uint, timeout: i32) i32;
extern fn WSAGetLastError() i32;
extern fn WSAStartup(wVersionRequired: u16, lpWSAData: ptr) i32;
extern fn WSACleanup() i32;
extern fn WSARecv(fd: uint, lpBuffers: ?ptr, dwBufferCount: u32, lpNumberOfBytesRecvd: ?&u32, lpFlags: ?&u32, lpOverlapped: ?ptr, lpCompletionRoutine: ?ptr) i32;
extern fn WSASend(fd: uint, lpBuffers: ?ptr, dwBufferCount: u32, lpNumberOfBytesSent: ?&u32, dwFlags: u32, lpOverlapped: ?ptr, lpCompletionRoutine: ?ptr) i32;
extern fn WSASocketA(af: i32, type: i32, protocol: i32, lpProtocolInfo: ?ptr, g: uint, dwFlags: u32) SOCKET;
extern fn WSAAccept(s: SOCKET, name: ?libc_sockaddr, namelen: i32, lpfnCondition: ?ptr, dwCallbackData: ?&u32) i32;
extern fn WSAConnect(s: SOCKET, name: libc_sockaddr, namelen: i32, lpCallerData: ?ptr, lpCalleeData: ?ptr, lpSQOS: ?ptr, lpGQOS: ?ptr) i32;
extern fn WSAIoctl(s: SOCKET, dwIoControlCode: u32, lpvInBuffer: ptr, cbInBuffer: u32, lpvOutBuffer: ptr, cbOutBuffer: u32, lpcbBytesReturned: &u32, lpOverlapped: ?ptr, lpCompletionRoutine: ?ptr) i32;
extern fn closesocket(fd: uint) i32;
extern fn ioctlsocket(fd: uint, cmd: int, arg: ptr) i32;

extern fn CreatePipe(hReadPipe: &HANDLE, hWritePipe: &HANDLE, lpPipeAttributes: ?ptr, nSize: u32) bool;
extern fn CreateNamedPipeA(name: cstring, dwOpenMode: u32, dwPipeMode: u32, nMaxInstances: u32, nOutBufferSize: u32, nInBufferSize: u32, nDefaultTimeOut: u32, lpSecurityAttributes: ?ptr) HANDLE;
extern fn ConnectNamedPipe(pipe: HANDLE, lpOverlapped: ?ptr) bool;
//extern fn pipe(pipefd: i32[2]) i32;
//int select(int nfds, fd_set restrict readfds, fd_set restrict writefds, fd_set restrict exceptfds, struct timeval restrict timeout);
extern fn dup(old_fd: i32) i32;
extern fn dup2(old_fd: i32, new_fd: i32) i32;

extern fn socket(domain: i32, type: i32, protocol: i32) uint;
extern fn connect(sockfd: uint, addr: libc_sockaddr, addrlen: u32) i32;
extern fn accept(sockfd: uint, addr: ?libc_sockaddr, addrlen: ?ptr) uint;
extern fn AcceptEx(sListenSocket: SOCKET, sAcceptSocket: SOCKET, lpOutputBuffer: ptr, dwReceiveDataLength: u32, dwLocalAddressLength: u32, dwRemoteAddressLength: u32, lpdwBytesReceived: &u32, lpOverlapped: ?ptr) bool;
//extern fn accept4(sockfd: i32, addr: ?libc_sockaddr, addrlen: ?ptr, flags: i32) i32;
extern fn shutdown(sockfd: uint, how: i32) i32;
extern fn bind(sockfd: uint, addr: libc_sockaddr, addrlen: u32) i32;
extern fn listen(sockfd: uint, backlog: i32) i32;

extern fn getsockopt(sockfd: uint, level: i32, optname: i32, optval: ptr, optlen: u32) i32;
extern fn setsockopt(sockfd: uint, level: i32, optname: i32, optval: ptr, optlen: u32) i32;
extern fn getaddrinfo(host: cstring, port: cstring, hints: libc_addrinfo_fix, res: ptr) i32;
extern fn freeaddrinfo(info: libc_addrinfo_fix) i32;

extern fn fork() i32;
extern fn vfork() i32;

extern fn execve(pathname: cstring, argv: ptr, envp: ptr) i32;
extern fn kill(pid: i32, sig: i32) i32;

extern fn _getcwd(buf: cstring, size: i32) ?cstring;
extern fn _chdir(path: cstring) i32;

extern fn rename(oldpath: cstring, newpath: cstring) i32;
extern fn _mkdir(pathname: cstring, mode: u32) i32;
extern fn _rmdir(pathname: cstring) i32;
extern fn link(oldpath: cstring, newpath: cstring) i32;
extern fn _unlink(pathname: cstring) i32;
extern fn symlink(target: cstring, linkpath: cstring) i32;
extern fn GetModuleFileNameA(hmodule: ?ptr, buf: ptr, len: u32) u32;
extern fn GetFileAttributesA(path: cstring) u32;
extern fn GetCurrentDirectory(buffer_size: u32, buffer: ptr) u32;
extern fn CreateSymbolicLinkA(link: cstring, target: cstring, flags: u32) BOOLEAN;
extern fn _fullpath(buf: ptr, path: cstring, maxlen: uint) cstring;

extern fn chmod(pathname: cstring, mode: u32) i32;
extern fn fchmod(fd: i32, mode: u32) i32;
extern fn chown(pathname: cstring, owner: u32, group: u32) i32;
extern fn fchown(fd: i32, owner: u32, group: u32) i32;
extern fn lchown(pathname: cstring, owner: u32, group: u32) i32;

extern fn umask(mask: u32) u32;

extern fn _flushall() void;

extern fn gettid() i32;

extern fn exit(status: i32) void $exit;
extern fn signal(signum: i32, handler: ?fnptr(i32)()) void;
extern fn raise(sig: i32) i32;
extern fn _get_errno(int_ref: ptr) ptr;

extern fn CreateThread(lpThreadAttributes: ?ptr, dwStackSize: uint, lpStartAddress: ptr, lpParameter: ?ptr, dwCreationFlags: u32, lpThreadId: ?ptr) HANDLE;
extern fn TerminateThread(handle: ptr, exit_code: i32) bool;
extern fn WaitForSingleObject(handle: ptr, timeout_ms: u32) u32;
extern fn CloseHandle(handle: HANDLE) bool;

extern fn CreateMutexA(lpMutexAttributes: ?ptr, bInitialOwner: bool, lpName: ?cstring) HANDLE;
extern fn ReleaseMutex(mutex: HANDLE) void;

// Time
extern fn GetSystemTimeAsFileTime(ft: libc_FILETIME) void;
extern fn CreateWaitableTimerExW(lpTimerAttributes: ?ptr, name: ?ptr, flags: u32, dwDesiredAccess: u32) ?HANDLE;
extern fn SetWaitableTimer(hTimer: HANDLE, due: &i64, lPeriod: i64, pfnCompletionRoutine: ?ptr, lpArgToCompletionRoutine: ?ptr, fResume: bool) bool;

