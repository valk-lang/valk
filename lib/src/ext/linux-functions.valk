
#if OS == linux
extern global errno: i32;
extern shared stderr: ?FILE;
extern shared stdin: ?FILE;
extern shared stdout: ?FILE;

alias FILE for ptr;
alias DIR for ptr
alias libc_addrinfo_fix for libc_gen_addrinfo

extern fn malloc(size: uint) ptr;
extern fn free(adr: ptr) i32;

extern fn exit(code: i32) void $exit;
extern fn signal(signum: i32, handler: ?fnptr(i32)()) void;
extern fn raise(sig: i32) i32;
extern fn __errno_location() ptr;
extern fn getenv(key: cstring) ?cstring;
extern fn sysconf(name: i32) int;

extern fn sync() void;
extern fn read(fd: i32, buf: ptr, size: uint) int;
extern fn write(fd: i32, data: ptr, length: uint) i32;
extern fn open(path: ptr, flags: i32, @infinite) i32;
extern fn close(fd: i32) i32;

extern fn getcwd(buf: cstring, size: uint) ?cstring;
extern fn chdir(path: cstring) i32;

extern fn recv(fd: i32, buf: ptr, len: uint, flags: i32) int;
extern fn send(fd: i32, buf: ptr, len: uint, flags: i32) int;

extern fn pipe(fds: &[i32 x 2]) i32;
extern fn fcntl(fd: i32, action: i32, @infinite) i32;

extern fn socket(domain: i32, type: i32, protocol: i32) i32;
extern fn connect(sockfd: i32, addr: libc_sockaddr, addrlen: u32) i32;
extern fn accept(sockfd: i32, addr: ?libc_sockaddr, addrlen: ?ptr) i32;
extern fn accept4(sockfd: i32, addr: ?libc_sockaddr, addrlen: ?ptr, flags: i32) i32;
extern fn shutdown(sockfd: i32, how: i32) i32;
extern fn bind(sockfd: i32, addr: libc_sockaddr, addrlen: u32) i32;
extern fn listen(sockfd: i32, backlog: i32) i32;

extern fn getsockopt(sockfd: i32, level: i32, optname: i32, optval: ptr, optlen: u32) i32;
extern fn setsockopt(sockfd: i32, level: i32, optname: i32, optval: ptr, optlen: u32) i32;
extern fn getaddrinfo(host: ptr, port: ptr, hints: libc_addrinfo, res: ptr) i32;
extern fn freeaddrinfo(info: libc_addrinfo) i32;

extern fn poll(fds: ptr, nfds: u32, timeout: i32) i32;

extern fn epoll_create(size: i32) i32;
extern fn epoll_wait(epfd: i32, events: ptr, maxevents: i32, timeout: i32) i32;
extern fn epoll_ctl(epfd: i32, op: i32, fd: i32, event: libc_epoll_event) i32;

extern fn nanosleep(req: libc_timespec, rem: libc_timespec) i32;
extern fn srand(seed: u32);
extern fn rand() i32;

// Files
extern fn stat(path: cstring, stat_buf: libc_stat) i32;
extern fn fstat(fd: i32, stat_buf: libc_stat) i32;
extern fn lstat(path: cstring, stat_buf: libc_stat) i32;
extern fn access(path: cstring, mode: i32) i32;

extern fn opendir(name: cstring) ?DIR;
extern fn readdir(dirp: DIR) ?libc_dirent;
extern fn closedir(dirp: DIR) i32;
extern fn mkdir(pathname: cstring, mode: u32) i32;
extern fn rmdir(pathname: cstring) i32;
extern fn realpath(dir: ptr, buf: ptr) cstring;

extern fn rename(oldpath: cstring, newpath: cstring) i32;
extern fn link(oldpath: cstring, newpath: cstring) i32;
extern fn unlink(pathname: cstring) i32;
extern fn symlink(target: cstring, linkpath: cstring) i32;
extern fn readlink(pathname: cstring, buf: ptr, bufsiz: uint) int;

// Process
extern fn popen(cmd: cstring, type: cstring) ?FILE;
extern fn pclose(stream: FILE) i32;
extern fn fgets(buffer: cstring, size: i32, stream: FILE) ?cstring;

// Time
extern fn gettimeofday(tv: libc_timeval, tz: ?libc_timezone) i32;
extern fn settimeofday(tv: libc_timeval, tz: ?libc_timezone) i32;

extern fn eventfd(initval: u32, flags: i32) i32;
#end
