
#if OS == macos
extern shared errno: i32;
extern shared stderr : ?ptr;
extern shared stdin : ?ptr;
extern shared stdout : ?ptr;

alias FILE for ptr;
alias DIR for ptr
alias libc_addrinfo_fix for libc_addrinfo

value SEEK_SET (0) // set file offset to offset

// pid_t = i32
// socklen_t = u32
// mode_t = u32
// uid_t = u32
// gid_t = u32

extern fn __error() ptr;
extern fn malloc(size: uint) ptr;
extern fn free(adr: ptr) void;

extern fn getenv(key: cstring) ?cstring;

extern fn sync() void;
extern fn read(fd: i32, buf: cstring, size: uint) int;
extern fn write(fd: i32, buf: cstring, size: uint) int;
extern fn open(path: cstring, flags: i32, @infinite) i32;
extern fn close(fd: i32) i32;
extern fn lseek(fd: i32, offset: int, flags: u32) int;

extern fn getcwd(buf: cstring, size: uint) ?cstring;
extern fn chdir(path: cstring) i32;

extern fn recv(fd: i32, buf: ptr, len: uint, flags: i32) int;
extern fn send(fd: i32, buf: ptr, len: uint, flags: i32) int;

extern fn fcntl(fd: i32, action: i32, @infinite) i32;

// Files
extern fn stat(path: cstring, stat_buf: libc_stat) i32;
extern fn fstat(fd: i32, stat_buf: libc_stat) i32;
extern fn lstat(path: cstring, stat_buf: libc_stat) i32;
extern fn access(path: cstring, mode: i32) i32;

extern fn opendir(name: cstring) ?ptr;
extern fn readdir(dirp: ptr) ?libc_dirent;
extern fn closedir(dirp: ptr) i32;

// OS
extern fn popen(command: cstring, type: cstring) ?ptr;
extern fn fgets(s: cstring, n: i32, stream: ptr) ?cstring;
extern fn pclose(stream: ptr) i32;
extern fn system(cmd: cstring) i32;

extern fn nanosleep(req: libc_timespec, rem: libc_timespec) i32;
extern fn srand(seed: u32);
extern fn rand() i32;

// Poll
extern fn poll(fds: ptr, nfds: u32, timeout: i32) i32;

extern fn pipe(pipefd: &[i32 x 2]) i32;
//int select(int nfds, fd_set restrict readfds, fd_set restrict writefds, fd_set restrict exceptfds, struct timeval restrict timeout);
extern fn dup(old_fd: i32) i32;
extern fn dup2(old_fd: i32, new_fd: i32) i32;

extern fn socket(domain: i32, type: i32, protocol: i32) i32;
extern fn connect(sockfd: i32, addr: libc_sockaddr, addrlen: u32) i32;
extern fn accept(sockfd: i32, addr: ?libc_sockaddr, addrlen: ?ptr) i32;
//extern fn accept4(sockfd: i32, addr: ?libc_sockaddr, addrlen: ?ptr, flags: i32) i32;
extern fn shutdown(sockfd: i32, how: i32) i32;
extern fn bind(sockfd: i32, addr: libc_sockaddr, addrlen: u32) i32;
extern fn listen(sockfd: i32, backlog: i32) i32;

extern fn getsockopt(sockfd: i32, level: i32, optname: i32, optval: ptr, optlen: u32) i32;
extern fn setsockopt(sockfd: i32, level: i32, optname: i32, optval: ptr, optlen: u32) i32;
extern fn getaddrinfo(host: cstring, port: cstring, hints: libc_addrinfo, res: ptr) i32;
extern fn freeaddrinfo(info: libc_addrinfo) i32;

//int clone(int (fn)(void *), void stack, int flags, void arg, .../* pid_t parent_tid, void tls, pid_t child_tid */ );
extern fn fork() i32;
extern fn vfork() i32;

extern fn execve(pathname: cstring, argv: ptr, envp: ptr) i32;

//extern fn wait3(wstatus: i32[1], options: i32, struct rusage rusage) i32;
//extern fn wait4(pid: i32, wstatus: i32[1], options: i32, struct rusage rusage) i32;

extern fn kill(pid: i32, sig: i32) i32;
//extern fn uname(struct utsname buf) i32;

extern fn rename(oldpath: cstring, newpath: cstring) i32;
extern fn mkdir(pathname: cstring, mode: u32) i32;
extern fn rmdir(pathname: cstring) i32;
extern fn link(oldpath: cstring, newpath: cstring) i32;
extern fn unlink(pathname: cstring) i32;
extern fn symlink(target: cstring, linkpath: cstring) i32;
extern fn readlink(pathname: cstring, buf: ptr, bufsiz: uint) int;

extern fn chmod(pathname: cstring, mode: u32) i32;
extern fn fchmod(fd: i32, mode: u32) i32;
extern fn chown(pathname: cstring, owner: u32, group: u32) i32;
extern fn fchown(fd: i32, owner: u32, group: u32) i32;
extern fn lchown(pathname: cstring, owner: u32, group: u32) i32;

extern fn umask(mask: u32) u32;

extern fn gettid() i32;

extern fn exit(status: i32) void $exit;
extern fn signal(signum: i32, handler: ?fnptr(i32)()) void;
extern fn raise(sig: i32) i32;

extern fn _NSGetExecutablePath(buf: ptr, len_u32_ptr: ptr) i32;
extern fn realpath(dir: ptr, buf: ptr) cstring;

// Time
extern fn gettimeofday(tv: &<libc_timeval>, tz: ?libc_timezone) i32;
extern fn settimeofday(tv: &<libc_timeval>, tz: ?libc_timezone) i32;
#end
