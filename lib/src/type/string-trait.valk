
use mem
use gc

trait StringTrait {
    // Properties
    ~ bytes: uint

    // Layouts
    + get utf8 : StringUtf8 $to {
        return this @as StringUtf8
    }
    + get ascii : String $to {
        return this @as String
    }

    //
    + fn data_ptr() ptr {
        return this @as ptr + size_of(<SELF>)
    }
    + fn data_cstring() cstring {
        return this.data_ptr() @as cstring
    }

    /////////////////////
    // Start / Ends
    /////////////////////

    + fn starts_with(part: SELF) bool {
        if part.bytes > this.bytes : return false
        return mem:equal(this.data_ptr(), part.data_ptr(), part.bytes)
    }
    + fn ends_with(part: SELF) bool {
        if part.bytes > this.bytes : return false
        return mem:equal(@offset(this.data_ptr(), u8,  this.bytes - part.bytes), part.data_ptr(), part.bytes)
    }

    /////////////////////
    // Trim
    /////////////////////

    + fn trim(part: SELF, limit: uint (0)) SELF {
        let res = this.ltrim(part, limit)
        return res.rtrim(part, limit)
    }

    + fn rtrim(part: SELF, limit: uint (0)) SELF {

        let part_bytes = part.bytes
        let part_data = part.data_ptr()

        let data = this.data_ptr()
        let len = this.bytes
        let data_end = data + len
        let offset : uint = 0
        let count : uint = 0
        while (offset + part_bytes <= len) && mem:equal(data_end - offset - part_bytes, part_data, part_bytes) {
            offset += part_bytes
            count++
            if count == limit : break
        }
        if offset == 0 : return this

        return SELF.make_from_ptr(data, len - offset)
    }

    + fn ltrim(part: SELF, limit: uint (0)) SELF {
        let part_bytes = part.bytes
        let part_data = part.data_ptr()

        let data = this.data_ptr()
        let len = this.bytes
        let offset : uint = 0
        let count : uint = 0
        while (offset + part_bytes <= len) && mem:equal(data + offset, part_data, part_bytes) {
            offset += part_bytes
            count++
            if count == limit : break
        }
        if offset == 0 : return this

        return SELF.make_from_ptr(data + offset, len - offset)
    }

    /////////////////////
    // Convert
    /////////////////////

    // fn to_uint() uint !invalid {
    //     let i = this.bytes
    //     let result : uint = 0
    //     let mult : uint = 1
    //     while i > 0 {
    //         let ch = this.byte(--i) - '0'
    //         if ch > 9 : throw invalid
    //         result += ch @as uint * mult
    //         mult *= 10
    //     }
    //     return result
    // }
    + fn to_uint() uint !invalid {
        return this.data_ptr().read_uint_value(this.bytes) ! throw invalid
    }
    + fn to_int() int !invalid {
        if this.to(String).get(0) == '-' : return (((this.data_ptr() + 1) @as ptr).read_uint_value(this.bytes - 1) ! throw invalid) @as int * -1
        return (this.data_ptr().read_uint_value(this.bytes) ! throw invalid) @as int
    }

    + fn hex_to_uint() uint !invalid {
        return this.data_ptr().read_hex_value(this.bytes) ! throw invalid
    }
    + fn hex_to_int() int !invalid {
        if this.to(String).get(0) == '-' : return (((this.data_ptr() + 1) @as ptr).read_hex_value(this.bytes - 1) ! throw invalid) @as int * -1
        return (this.data_ptr().read_hex_value(this.bytes) ! throw invalid) @as int
    }

    + fn octal_to_uint() uint !invalid {
        return this.data_ptr().read_octal_value(this.bytes) ! throw invalid
    }
    + fn octal_to_int() int !invalid {
        if this.to(String).get(0) == '-' : return (((this.data_ptr() + 1) @as ptr).read_octal_value(this.bytes - 1) ! throw invalid) @as int * -1
        return (this.data_ptr().read_octal_value(this.bytes) ! throw invalid) @as int
    }

    + fn to_float() f64 !invalid {

        let result : f64 = 0
        let sign : f64 = 1
        let i : uint = 0
        let len = this.bytes
        let has_dot = false
        let decimals = 0
        let ascii = this.to(String)

        if i == len : throw invalid
        if ascii.get(0) == '-' {
            sign = -1
            i++
            if i == len : throw invalid
        }

        while i < len {
            let ch = ascii.get(i++)
            if ch.is_number() {
                result = result * 10 + (ch - '0');
                if has_dot : decimals++
            } else if ch == '.' {
                if has_dot : throw invalid
                has_dot = true
            } else {
                throw invalid
            }
        }

        while decimals-- > 0 {
            result = result / 10
        }

        return result * sign
    }

    + fn to_lower() SELF {
        let len = this.bytes
        let data = this.data_ptr()
        let new_str = SELF.make_empty(len)
        let new_data = new_str.data_ptr()
        while len-- > 0 {
            let ch = @ptrv(data, u8, len)
            if ch > 64 && ch < 91 : ch += 32
            @ptrv(new_data, u8, len) = ch
        }
        return new_str
    }

	/////////////////////
	// Syntax
	/////////////////////

    + fn is_alpha(allow_extra_bytes: SELF ("")) bool {
		let i : uint = 0
		let len = this.bytes
		let data = this.data_ptr()
		while i < len {
			let ch = @ptrv(data, u8, i++)
			if (ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z') {
				if !allow_extra_bytes.contains_byte(ch) : return false
			}
		}
		return true
	}
    + fn is_alpha_numeric(allow_extra_bytes: SELF ("")) bool {
		let i : uint = 0
		let len = this.bytes
		let data = this.data_ptr()
		while i < len {
			let ch = @ptrv(data, u8, i++)
			if (ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z') && (ch < '0' || ch > '9') {
				if !allow_extra_bytes.contains_byte(ch) : return false
			}
		}
		return true
	}

    /////////////////////
    // Internals
    /////////////////////

    fn add(add: SELF) SELF $add {
        let this_len = this.bytes
        let add_len = add.bytes
        let len = this_len + add_len
        if len == 0 : return "".to(SELF)
        let s = SELF.make_empty(len)
        let data = s.data_ptr()
        mem:copy(this.data_ptr(), data, this_len)
        mem:copy(add.data_ptr(), @offset(data, u8, this_len), add_len + 1) // + 1 for 0 byte
        return s
    }

    /////////////////////
    // Compare
    /////////////////////

    fn equals(cmp: SELF) bool $eq {
        if this.bytes != cmp.bytes : return false 
        return mem:equal(this.data_ptr(), cmp.data_ptr(), this.bytes)
    }

    fn lt(cmp: SELF) bool $lt {
        let len1 = this.bytes
        let len2 = cmp.bytes
        let len = len1 <= len2 ? len1 : len2
        let data1 = this.data_ptr()
        let data2 = cmp.data_ptr()
        let i : uint = 0
        while i < len {
            let ch1 = @ptrv(data1, u8, i)
            let ch2 = @ptrv(data2, u8, i++)
            if ch1 != ch2 : return ch1 < ch2
        }
        return len1 <= len2
    }
    fn gt(cmp: SELF) bool $gt {
        let len1 = this.bytes
        let len2 = cmp.bytes
        let len = len1 <= len2 ? len1 : len2
        let data1 = this.data_ptr()
        let data2 = cmp.data_ptr()
        let i : uint = 0
        while i < len {
            let ch1 = @ptrv(data1, u8, i)
            let ch2 = @ptrv(data2, u8, i++)
            if ch1 != ch2 : return ch1 > ch2
        }
        return len1 > len2
    }
    fn lte(cmp: SELF) bool $lte {
        return this == cmp || this < cmp
    }
    fn gte(cmp: SELF) bool $gte {
        return this == cmp || this > cmp
    }

    /////////////////////
    // Create
    /////////////////////

    fn clone() SELF {
        return SELF.make_from_ptr(this.data_ptr(), this.bytes)
    }

    + static fn make_empty(length: uint) SELF {
        if length == 0 : return "".to(SELF)
        let d = gc:alloc(size_of(<SELF>) + length + 1) @as SELF
        @ptrv(@ref(d.bytes), uint) = length
        @ptrv(d @as ptr, u8, length + size_of(<SELF>)) = 0
        return d
    }

    + static fn make_from_ptr(data: ptr, length: uint) SELF {
        if length == 0 : return "".to(SELF)
        let s = SELF.make_empty(length)
        let str_data = s.data_ptr()
        mem:copy(data, str_data, length)
        @ptrv(str_data, u8, length) = 0 // TODO: remove line
        return s
    }
}
