
use core
use mem
use gc

+ class Array[T: PROP_TYPE] {
    ~ size: uint
    ~ length: uint (0)
    ~ data: gc:GcPtr

    + static fn new(start_size: uint (2)) SELF {
        if start_size < 2 {
            start_size = 2
        }
        let d = gc:alloc(start_size * size_of(T))

        let res = SELF {
            size: start_size
            data: d
        }
        return res
    }

    fn lock() {
        core:race_lock()
    }
    fn unlock() {
        core:race_unlock()
    }

    ////////////////
    // Macros
    ////////////////

    + macro "{" suggest(T) repeat(items, V:v1 ws optional(","), "}") <{
        let a = SELF.new()
        #loop macro_values items as item
        a.append(item.v1)
        #end
        return a
    }

    ////////////////
    // Append
    ////////////////

    + fn append(item: T, unique: bool (false)) SELF {
        if this.$is_shared : this.lock()
        if unique {
            this.nolock_index_of(item) ! this.nolock_append_item(item)
            if this.$is_shared : this.unlock()
            return this
        }
        this.nolock_append_item(item)
        if this.$is_shared : this.unlock()
        return this
    }

    - fn nolock_append_item(item: T) {
        let size = this.size
        let length = this.length
        this.fit_index(length)
        let data = this.data

        @property_init(this, @ptrv(data, T, length), item)

        this.length = length + 1
    }

    + fn append_many(items: SELF) SELF {
        each items as item {
            this.append(item)
        }
        return this
    }

    ////////////////
    // Prepend
    ////////////////

    + fn prepend(item: T, unique: bool (false)) SELF {
        if this.$is_shared : this.lock()
        if unique {
            this.nolock_index_of(item) ! this.nolock_prepend_item(item)
            if this.$is_shared : this.unlock()
            return this
        }
        this.nolock_prepend_item(item)
        if this.$is_shared : this.unlock()
        return this
    }
    - fn nolock_prepend_item(item: T) {
        let size = this.size
        let length = this.length
        this.fit_index(length)
        let data = this.data

        let to_pos = length
        while to_pos > 0 {
            @ptrv(data, T, to_pos) = @ptrv(data, T, to_pos - 1)
            to_pos--
        }

        @property_init(this, @ptrv(data, T, 0), item)

        this.length = length + 1
    }

    + fn prepend_many(items: SELF) SELF {
        let ilen = items.length
        if ilen == 0 : return this
        if items.length == 0 : return items
        if this.$is_shared : this.lock()
        // Adjust size
        let new_len = this.length + ilen
        this.fit_index(new_len - 1)
        let data = this.data
        let items_data = items.data

        let bytes = ilen * size_of(T)
        mem:copy(data, data.@offset(bytes), bytes)

        let i : uint = 0
        while i < ilen {
            @property_init(this, @ptrv(data, T, i), @ptrv(items_data, T, i))
            i++
        }

        this.length += ilen
        if this.$is_shared : this.unlock()
        return this
    }

    ////////////////
    // 
    ////////////////

    + fn merge(items: SELF) SELF $add {
        return this.copy().append_many(items)
    }

    + fn intersect(with: SELF) SELF {
        let len = this.length
        if with.length < len : len = with.length
        let result = SELF.new(len)
        each this as item {
            if with.contains(item) : result.append(item, true)
        }
        return result
    }

    + fn range(start: uint, end: uint, inclusive: bool (true)) SELF {
        end = end + (inclusive).to(uint)
        if start >= end : return SELF.new()
        return this.part(start, end-start)
    }

    + fn part(start: uint, amount: uint) SELF {
        if this.$is_shared : this.lock()
        if start >= this.length {
            if this.$is_shared : this.unlock()
            return SELF.new()
        }
        let remain = this.length - start
        if amount > remain : amount = remain
        let new = SELF.new(amount)
        let from = this.data.@cast(ptr) + start * size_of(T)
        mem:copy(from, new.data, amount * size_of(T))
        new.length = amount
        #if is_gc_type(T)
        while amount-- > 0 {
            let item = @property_get(@ptrv(new.data, T, amount))
            @property_init(new, @ptrv(new.data, T, amount), item)
        }
        #end
        if this.$is_shared : this.unlock()
        return new
    }

    + fn fit_index(index: uint) {
        let size = this.size
        if index >= size {
            while index >= size : size *= 2
            this.increase_size(size)
        }
    }

    + fn increase_size(new_size: uint) gc:GcPtr {
        let data = this.data
        let size = this.size
        if size >= new_size : return data

        let new_data = gc:alloc(new_size * size_of(T))
        mem:copy(data, new_data, size * size_of(T))

        this.data = new_data
        this.size = new_size

        return new_data
    }

    + fn get(index: uint) T !not_found $offset {
        if this.$is_shared : this.lock()
        if index >= this.length {
            if this.$is_shared : this.unlock()
            throw not_found
        }
        let v = @property_get(@ptrv(this.data, T, index))
        if this.$is_shared : this.unlock()
        return v
    }

    + fn set(index: uint, value: T) !out_of_range $offset_assign {
        if this.$is_shared : this.lock()
        if index > this.length {
            if this.$is_shared : this.unlock()
            throw out_of_range
        }
        if index == this.length {
            this.nolock_append_item(value);
            if this.$is_shared : this.unlock()
            return
        }
        @property_update(this, @ptrv(this.data, T, index), value)
        if this.$is_shared : this.unlock()
    }

    + fn set_expand(index: uint, value: T, filler_value: T) {
        if this.$is_shared : this.lock()
        this.fit_index(index)
        let len = this.length
        if index >= len : this.length = index + 1
        let data = this.data

        // fill
        let i = len
        while i < index {
            @property_init(this, @ptrv(data, T, i++), filler_value)
        }

        // Set index
        if index < len {
            @property_update(this, @ptrv(data, T, index), value)
        } else {
            @property_init(this, @ptrv(data, T, index), value)
        }
        if this.$is_shared : this.unlock()
    }

    + fn contains(value: T) bool {
        this.index_of(value) ! return false
        return true
    }

    + fn remove(index: uint) SELF {
        if this.$is_shared : this.lock()
        let len = this.length
        if index >= len {
            if this.$is_shared : this.unlock()
            return this
        }
        let data : ptr = this.data
        let after_count = len - (index + 1)

        @property_clear(this, @ptrv(data, T, index))

        if after_count > 0 {
            mem:copy(data + (index + 1) * size_of(T), data + index * size_of(T), after_count * size_of(T))
        }

        this.length--
        if this.$is_shared : this.unlock()
        return this
    }

    + fn remove_value(value: T) SELF {
        let index = this.index_of(value) ! return this
        this.remove(index)
        return this
    }

    + fn pop_last() T !empty {
        if this.$is_shared : this.lock()
        if this.length > 0 {

            let index = --this.length
            let data = this.data

            let item = @property_get(@ptrv(data, T, index))
            @property_clear(this, @ptrv(data, T, index))

            if this.$is_shared : this.unlock()
            return item
        }
        if this.$is_shared : this.unlock()
        throw empty
    }
    + fn pop_first() T !empty {
        if this.$is_shared : this.lock()
        if this.length > 0 {

            let data : ptr = this.data

            let item = @property_get(@ptrv(data, T, 0))
            @property_clear(this, @ptrv(data, T, 0))

            this.length--
            mem:copy(data + size_of(T), data, this.length * size_of(T))

            if this.$is_shared : this.unlock()
            return item
        }
        if this.$is_shared : this.unlock()
        throw empty
    }

    + fn swap(index_a: uint, index_b: uint) {
        if this.$is_shared : this.lock()
        let len = this.length
        if index_a >= len {
            if this.$is_shared : this.unlock()
            return
        }
        if index_b >= len {
            if this.$is_shared : this.unlock()
            return
        }
        let data = this.data
        let a = @ptrv(data, T, index_a)
        let b = @ptrv(data, T, index_b)
        @ptrv(data, T, index_a) = b
        @ptrv(data, T, index_b) = a
        if this.$is_shared : this.unlock()
    }

    + fn index_of(item: T) uint !not_found {
        if this.$is_shared : this.lock()
        let i = this.nolock_index_of(item) ! {
            if this.$is_shared : this.unlock()
            throw not_found
        }
        if this.$is_shared : this.unlock()
        return i
    }
    + fn nolock_index_of(item: T) uint !not_found {
        let index : uint = 0
        let adr = this.data
        let len = this.length
        while index < len {
            let x = @property_get(@ptrv(adr, T, index))
            if x == item : return index
            index++
        }
        throw not_found
    }

    + fn clear() SELF {
        if this.$is_shared : this.lock()
        #if is_gc_type(T)
        let data = this.data
        let i = this.length
        while i-- > 0 : @property_clear(this, @ptrv(data, T, i))
        #end

        this.length = 0
        this.data = gc:alloc(2 * size_of(T))
        this.size = 2
        if this.$is_shared : this.unlock()
        return this
    }

    + fn sort(func: ?Fn(T, T)(bool) (null)) SELF {
        if this.$is_shared : this.lock()
        let len_ = this.length
        if len_ < 2 {
            if this.$is_shared : this.unlock()
            return this
        }

        let v = true
        let i : uint = 0
        let len = len_ - 1
        while i < len && v {
            v = false
            let j : uint = 0
            let until = len - i
            while j < until {
                let item = this.get(j) ! { break }
                let next = this.get(j + 1) ! { break }
                if isset(func) {
                    if func(item, next) {
                        this.swap(j, j + 1)
                        v = true
                    }
                } else if item > next {
                    this.swap(j, j + 1)
                    v = true
                }
                j++
            }
            i++
        }
        if this.$is_shared : this.unlock()
        return this
    }

    + fn reverse() SELF {
        if this.$is_shared : this.lock()
        let len_ = this.length
        if len_ < 2 {
            if this.$is_shared : this.unlock()
            return this
        }
        let last = len_ - 1
        let first : uint = 0
        while len_ > 1 {
            this.swap(first, last)
            first++
            last--
            len_ -= 2
        }
        if this.$is_shared : this.unlock()
        return this
    }

    + fn equal(array: SELF) bool $eq {
        if this.$is_shared : this.lock()
        if this.length != array.length {
            if this.$is_shared : this.unlock()
            return false
        }
        each this as v, i {
            let v2 = array.get(i) ! {
                if this.$is_shared : this.unlock()
                return false
            }
            if v != v2 {
                if this.$is_shared : this.unlock()
                return false
            }
        }
        if this.$is_shared : this.unlock()
        return true
    }

    + fn equal_ignore_order(array: SELF) bool {
        if this.$is_shared : this.lock()
        if this.length != array.length {
            if this.$is_shared : this.unlock()
            return false
        }
        let copy = array.copy()
        each this as v, i {
            let i2 = copy.index_of(v) ! {
                if this.$is_shared : this.unlock()
                return false
            }
            copy.remove(i2)
        }
        if this.$is_shared : this.unlock()
        return true
    }

    ////////////////
    // Filtering
    ////////////////

    #if is_nullable_type(T)
    - static fn filter_null(i: T) bool {
        return !isset(i)
    }
    #end

    + fn filter(func: ?Fn(T)(bool) (null)) SELF {
        if this.length == 0 : return this
        if !isset(func) {
            #if type_has_method(T, default_array_filter)
            func = T.default_array_filter
            #elif is_nullable_type(T)
            func = SELF.filter_null
            #else
            return this
            #end
        }

        if this.$is_shared : this.lock()
        let result : ?SELF = null
        let removals : uint = 0
        each this as v, i {
            if func(v) {
                if !isset(result) : result = this.copy()
                result.remove(i - removals++)
            }
        }
        if this.$is_shared : this.unlock()
        if !isset(result) : return this
        return result
    }

    + fn unique() SELF {
        if this.$is_shared : this.lock()
        let insert_i : uint = 0
        let data = this.data
        each this as find, i {
            let found = false
            each this as item, o {
                if o == insert_i : break
                if find == item {
                    found = true
                    break
                }
            }
            if found : @property_clear(this, @ptrv(data, T, i))
            else : @ptrv(data, T, insert_i++) = find
        }
        this.length = insert_i
        if this.$is_shared : this.unlock()
        return this
    }

    ////////////////
    // Exceptions
    ////////////////

    #if is_type_of_class(T, String)
    + fn join(divider: String) String {
        if this.$is_shared : this.lock()
        let str = ""
        let count : uint = 0
        each this as part, i {
            #if is_nullable_type(T)
            if !isset(part) : continue
            #end
            if count++ > 0 : str += divider
            str += part
        }
        if this.$is_shared : this.unlock()
        return str
    }
    #end

    ////////////////
    // Internals
    ////////////////

    + fn copy() SELF {
        let arr = SELF.new(this.length)
        each this as item {
            arr.append(item)
        }
        return arr
    }

    fn each_get(index: uint) T !end {
        let v = this.get(index) ! throw end
        return v
    }

    ////////////////
    // Gc
    ////////////////

    #if is_gc_type(T)

        fn gc_action(action: fn(ptr, ptr)()) {
            let data = this.data
            let x = this.length
            while x-- > 0 {
                action(this, data.@offset(x, ptr))
            }
        }

    #end

    fn clone() SELF {
        let new = SELF.new(this.size)
        each this as item, i {
            new.append(item)
        }
        return new.@cast(SELF)
    }
}
