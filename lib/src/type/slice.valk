
use gc
use mem

slice Slice[T] {

    static fn new(length: uint) SELF {
        let size = length * size_of(T)
        let data = gc:alloc(size)
        mem:clear(data, size)
        let s = SELF {
            length: length
            data: data
        }
        return s
    }

    + macro "{" suggest(T) repeat(items, V:v1 ws optional(","), "}") <{
        let s = SELF.new(items.$length)
        let data = s.data
        let i : uint = 0
        #loop macro_values items as item
            @property_init(s, @ptrv(data, T, i++), item.v1)
        #end
        return s
    }

    + fn get(index: uint) T !not_found $offset {
        if index >= this.length : throw not_found
        return @property_get(@ptrv(this.data, T, index))
    }

    + fn set(index: uint, value: T) !out_of_range $offset_assign {
        if index >= this.length : throw out_of_range
        @property_update(this, @ptrv(this.data, T, index), value)
    }
    + fn set_all(value: T) {
        let i = this.length
        let data = this.data
        while i-- > 0 {
            @property_update(this, @ptrv(data, T, i), value)
        }
    }

    #if is_gc_type(T)
    fn _props(list: gc:Lifo) {
        let data : uint = this.data.@cast(uint)
        let end : uint = data + (this.length * size_of(T))
        while data < end {
            list.add(data.@cast(ptr))
            data += size_of(T)
        }
    }
    #end
}