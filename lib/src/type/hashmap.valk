
class HashMap[K, T] {
    - zones: Array[?KeyMap[K, T]] (Array[?KeyMap[K, T]].new(32))

    + static fn new() SELF {
        return SELF{}
    }

    + get length : uint {
        let total : uint = 0
        each this.zones as zone {
            if isset(zone) : total += zone.length
        } 
        return total
    }
    + fn keys() Array[K] {
        let keys = Array[K].new(this.length)
        each this.zones as zone {
            if isset(zone) : keys.append_many(zone._keys)
        } 
        return keys
    }
    + fn values() Array[T] {
        let values = Array[T].new(this.length)
        each this.zones as zone {
            if isset(zone) : values.append_many(zone._values)
        } 
        return values
    }

    static fn zone_index(key: K) uint {
        return key.@cast(uint) % 32
    }
    fn zone(key: K) KeyMap[K, T] {
        let i = SELF.zone_index(key)
        let zone = this.zones.get(i) !? null
        if !isset(zone) {
            let z = KeyMap[K, T].new()
            this.zones.set_expand(i, z, null)
            return z
        }
        return zone
    }

    + mut fn set(key: K, value: T) SELF $offset_assign {
        let zone = this.zone(key)
        zone.set(key, value)
        return this
    }

    + mut fn set_many(map: SELF) SELF {
        each map as v, k {
            this.set(k, v)
        }
        return this
    }

    + mut fn set_unique(key: K, value: T) SELF !not_unique {
        let zone = this.zone(key)
        zone.set_unique(key, value) _
        return this
    }

    + fn get(key: String) T !not_found $offset {
        let zone = this.zone(key)
        return zone.get(key) ! throw not_found
    }

    + fn has(key: String) bool {
        let zone = this.zone(key)
        return zone.has(key)
    }
    + fn has_value(value: T) bool {
        each this.zones as zone {
            if isset(zone) && zone.has_value(value) : return true
        }
        return false
    }

    + mut fn remove(key: String) SELF {
        let zone = this.zone(key)
        zone.remove(key)
        return this
    }

    + mut fn clear() SELF {
        this.zones.clear()
        return this
    }

    + fn merge(map: SELF) SELF $add {
        each map as v, k : this.set(k, v)
        return this
    }

    + fn copy() SELF {
        return SELF{
            zones: this.zones.copy()
        }
    }

    fn each_get(index: uint) (T, String) !end {
        each this.zones as zone {
            if !isset(zone) : continue
            if index >= zone.length {
                index -= zone.length
                continue
            }
            let k = zone._keys.get(index) ! throw end
            let v = zone._values.get(index) ! throw end
            return v, k
        }
        throw end
    }
}
