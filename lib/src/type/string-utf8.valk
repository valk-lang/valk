
use mem
use utils

struct CharStep {
    data: ptr
    bytes: uint
    pos: uint

    fn set(str: String) {
        this.data = str.data_ptr()
        this.bytes = str.bytes
        this.pos = 0
    }
    fn skip_bytes(len: uint) {
        this.pos += len
    }

    fn next() u8 !end {
        let pos = this.pos
        let bytes = this.bytes
        let data = this.data
        if pos == bytes : throw end
        let byte : u8 = @ptrv(data, u8, pos)
        let bytec : u8 = 1
        if((byte & 128) > 0){
            byte = byte << 1
            while (byte & 128) > 0 {
                bytec++
                byte = byte << 1
            }
            if bytec > 4 : bytec = 1
            if pos + bytec > bytes : bytec -= (pos + bytec - bytes) @as u8
        }
        this.pos = pos + bytec
        return bytec
    }
}

class StringUtf8 imut {

    use StringTrait

    + get length : uint {
        let step = @stack(<CharStep>)
        step.set(this)
        let count : uint = 0
        while true {
            step.next() ! return count
            count++
        }
        return 0
    }

    /////////////////////
    // Index of
    /////////////////////

    + fn index_of(part: String, start_index: uint (0)) uint !not_found {
        if part.bytes > this.bytes : throw not_found
        let step = @stack(<CharStep>)
        step.set(this)
        let count : uint = 0
        let offset : uint = 0
        let adr = this.data_ptr()
        let part_adr = part.data_ptr()
        let part_bytes = part.bytes
        let last_offset = this.bytes - part_bytes
        while count < start_index {
            offset += step.next() ! throw not_found
            if offset > last_offset : throw not_found
            count++
        }
        while true {
            if mem:equal(@offset(adr, u8, offset), part_adr, part_bytes) : return count
            offset += step.next() ! throw not_found
            if offset > last_offset : throw not_found
            count++
        }
        return 0
    }

    + fn contains(part: String) bool {
        this.index_of(part) ! return false
        return true
    }
    + fn contains_byte(byte: u8) bool {
        this.ascii.index_of(byte) ! return false
        return true
    }


    /////////////////////
    // Partials
    /////////////////////
    
    + fn byte(index: uint) u8 {
        if index >= this.bytes : return 0
        return @ptrv(this.data_ptr(), u8, index)
    }
    + fn byte_end(index: uint) u8 {
        if index >= this.bytes : return 0
        return @ptrv(this.data_ptr(), u8, this.bytes - index - 1)
    }
    + fn get(index: uint) String {
        return this.sub_str(index, 1)
    }
    + fn get_end(index: uint) String {
        let len = this.length
        if index >= len : return ""
        return this.sub_str(len - index - 1, 1)
    }

    + fn byte_sub_str(start_index: uint, length: uint) String {
        let this_bytes = this.bytes
        if start_index > this_bytes : return ""
        if (start_index + length) > this_bytes {
            length = this_bytes - start_index
        }
        if length == 0 : return ""
        let from = @offset(this.data_ptr(), u8,  start_index)
        let res = String.make_empty(length)
        mem:copy(from, res.data_ptr(), length)
        return res
    }

    + fn sub_str(start_index: uint, length: uint) String {

        if length == 0 : return ""
        let this_bytes = this.bytes
        if start_index > this_bytes : return ""

        let step = @stack(<CharStep>)
        step.set(this)

        let count : uint = 0
        let offset : uint = 0
        let data = this.data_ptr()
        while count < start_index {
            offset += step.next() ! return ""
            count++
        }
        let start = offset
        count = 0
        while count++ < length {
            offset += step.next() ! break
            if offset >= this_bytes : break
        }
        if offset > this_bytes : offset = this_bytes
        return String.make_from_ptr(@offset(data, u8, start), offset - start)
    }

    + fn split(on: String) Array[String] {
        let result = Array[String].new()
        let on_bytes = on.bytes
        let this_bytes = this.bytes
        if on_bytes > this_bytes || on_bytes == 0 {
            result.push(this)
            return result
        }

        let step = @stack(<CharStep>)
        step.set(this)

        let offset : uint = 0
        let start : uint = 0

        let data = this.data_ptr()
        let on_data = on.data_ptr()
        let last_offset = this_bytes - on_bytes
        while offset <= last_offset {
            if mem:equal(@offset(data, u8, offset), on_data, on_bytes) {
                result.push(String.make_from_ptr(@offset(data, u8, start), offset - start))
                offset += on_bytes
                start = offset
                step.skip_bytes(on_bytes)
                continue
            }
            offset += step.next() ! break
        }
        if offset > this_bytes : offset = this_bytes
        result.push(String.make_from_ptr(@offset(data, u8, start), offset - start))
        return result
    }

    /////////////////////
    // Misc
    /////////////////////

    // Convert escaped characters
    + fn unescape() String {
        let bytes = this.bytes
        if bytes == 0 : return ""
        let data = this.data_ptr()
        let buf = utils:ByteBuffer.new(bytes)
        //
        let i : uint = 0
        while i < bytes {
            let ch = @ptrv(data, u8, i++)
            if (ch == '\\') {
                let ch = @ptrv(data, u8, i++)
                ch = ch.unescape()
                buf.append_byte(ch)
                continue
            }
            buf.append_byte(ch)
        }
        return buf.to_string()
    }

}
