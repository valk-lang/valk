
use mem
use utils
use io

// struct CharStep {
//     data: ptr
//     bytes: uint
//     pos: uint

//     fn set(str: String) {
//         this.data = str.data_ptr()
//         this.bytes = str.bytes
//         this.pos = 0
//     }
//     fn skip_bytes(len: uint) {
//         this.pos += len
//     }

//     fn next() u8 !end {
//         let pos = this.pos
//         let bytes = this.bytes
//         let data = this.data
//         if pos == bytes : throw end
//         let byte : u8 = @ptrv(data, u8, pos)
//         let bytec : u8 = 1
//         if((byte & 128) > 0){
//             byte = byte << 1
//             while (byte & 128) > 0 {
//                 bytec++
//                 byte = byte << 1
//             }
//             if bytec > 4 : bytec = 1
//             if pos + bytec > bytes : bytec -= (pos + bytec - bytes) @as u8
//         }
//         this.pos = pos + bytec
//         return bytec
//     }
// }

struct String {
    readonly bytes: uint
    readonly data: ptr

    pub fn data_ptr() ptr {
        return this.data
    }

    // fn _add(add: String) String {
    //     let this_len = this.bytes
    //     let add_len = add.bytes
    //     let len = this_len + add_len
    //     if len == 0 : return ""
    //     let s = String.make_empty(len)
    //     let data = s.data
    //     mem:copy(this.data, data, this_len)
    //     mem:copy(add.data, @ptr_offset(data, this_len), add_len + 1) // + 1 for 0 byte
    //     return s
    // }

    static fn make_empty(length: uint) String {
        if length == 0 : return ""
        let d = mem:alloc(length + 1)
        let str = String {
            data: d
            bytes: length
        }
        return str
    }

    static fn make_from_ptr(data: ptr, length: uint) String {
        if length == 0 : return ""
        let s = String.make_empty(length)
        mem:copy(data, s.data_ptr(), length)
        return s
    }

    fn _gc_free() {
        mem:free(this.data)
    }
}
