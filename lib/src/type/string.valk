
use mem
use utils
use io
use gc

class String imut {

    use StringTrait

    + get length : uint {
        return this.bytes
    }

    /////////////////////
    // Index of
    /////////////////////

    + fn index_of(part: String, start_index: uint (0)) uint !not_found {
        let part_bytes = part.bytes
        if part_bytes > this.bytes : throw not_found
        let index = start_index
        let len = this.bytes - part_bytes + 1
        let data = this.data_ptr()
        let part_data = part.data_ptr()
        while index < len {
            if mem:equal(@offset(data, u8, index), part_data, part_bytes) : return index
            index++
        }
        throw not_found
    }

    + fn index_of_byte(byte: u8, start_index: uint (0)) uint !not_found {
        let index = start_index
        let len = this.bytes
        let data = this.data_ptr()
        while index < len {
            let ch = @ptrv(data, u8, index)
            if ch == byte : return index
            index++
        }
        throw not_found
    }

    + fn contains(part: String) bool {
        this.index_of(part) ! return false
        return true
    }
    + fn contains_byte(byte: u8) bool {
        this.index_of(byte) ! return false
        return true
    }

    /////////////////////
    // Partials
    /////////////////////
    
    + fn get(index: uint) u8 {
        if index >= this.bytes : return 0
        return @ptrv(this.data_ptr(), u8, index)
    }
    + fn get_end(index: uint) u8 {
        if index >= this.bytes : return 0
        return @ptrv(this.data_ptr(), u8, this.bytes - index - 1)
    }

    + fn sub_str(start_index: uint, length: uint) String {
        let this_bytes = this.bytes
        if start_index > this_bytes : return ""
        if (start_index + length) > this_bytes {
            length = this_bytes - start_index
        }
        if length == 0 : return ""
        let from = @offset(this.data_ptr(), u8,  start_index)
        let res = String.make_empty(length)
        mem:copy(from, res.data_ptr(), length)
        return res
    }

    + fn split(on: String) Array[String] {
        let result = Array[String].new()
        let start : uint = 0
        let on_len = on.bytes
        if on_len == 0 {
            let this_len = this.length
            let i : uint = 0
            while i < this_len {
                result.push(this.sub_str(i++, 1))
            }
        } else {
            while true {
                let index = this.index_of(on, start) ! break
                let part = this.sub_str(start, index - start)
                result.push(part)
                start = index + on_len
            }
            let part = this.sub_str(start, this.bytes - start)
            result.push(part)
        }
        return result
    }

    fn split_on_first_occurance_of_byte(byte: u8) (String, String) !not_found {
        let pos = this.index_of_byte(byte) ! throw not_found
        let p2 = this.sub_str(pos + 1, this.bytes - pos - 1)
        let p1 = this.sub_str(0, pos)
        return p1, p2
    }

    /////////////////////
    // Misc
    /////////////////////

    // Convert escaped characters
    + fn unescape() String {
        let bytes = this.bytes
        if bytes == 0 : return ""
        let data = this.data_ptr()
        let buf = utils:ByteBuffer.new(bytes)
        //
        let i : uint = 0
        while i < bytes {
            let ch = @ptrv(data, u8, i++)
            if (ch == '\\') {
                let ch = @ptrv(data, u8, i++)
                ch = ch.unescape()
                buf.append_byte(ch)
                continue
            }
            buf.append_byte(ch)
        }
        return buf.to_string()
    }
}
