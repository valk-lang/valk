
use mem

global float_str_buf : ?ptr (null)

trait FloatNumber {

    fn to_string() String $to {
        return this.to_str()
    }

    + fn to_str(decimals: uint (2)) String {
        if this == 0 : return "0.00"
        if decimals == 0 : return (this @as int).to_str() + ".00"

        // Get buffer
        if float_str_buf == null {
            // Todo, use stack buffer
            float_str_buf = mem:alloc(64)
        }
        
        let value = this
        let negative = value < 0
        if negative {
            value *= -1
        }
        let buf = float_str_buf @as ptr
        let offset : uint = 0
        if negative {
            @ptrv(buf, u8, 0) = '-'
            offset++
        }

        //
        let ipart = value @as int 
        let ilen = ipart.to_base_to_ptr(10, buf + offset)
        offset += ilen
        @ptrv(buf, u8, offset) = '.'
        offset++
        
        // Get decimals by multiplying with 10^{amount of decimals}
        let x = 1
        let d = decimals
        while d-- > 0 {
            x *= 10
        }
        let fpart = value - ipart @as SELF 
        fpart = fpart * x 

        let tail = fpart @as int
        let tails = tail.to_str()
        let missing = decimals - tails.bytes
        while missing-- > 0 {
            @ptrv(buf, u8, offset) = '0'
            offset++
        }
        mem:copy(tails.data_ptr(), buf + offset, tails.bytes)

        return String.make_from_ptr(buf, tails.bytes + offset)
    }

    fn eq_str(str: String) bool {
        let v = str.to_float() ! return false
        return this == v
    }
}
