
use ext

use mem
use coro

#if OS == win
global cport_instance: ext:HANDLE
struct OverlapBase {
    sys: <ext:OVERLAPPED>
    coro: ?ptr
}
struct OverlapData {
    base: <OverlapBase>
}
// AcceptEx
struct OverlapAcceptEx {
    base: <OverlapBase>
    socket: ext:SOCKET
    addressBuffer: [u8 x 128]
    bytesReceived: u32
}
// ConnectEx
struct OverlapConnectEx {
    base: <OverlapBase>
    sent: u32
}
// Recv
struct OverlapRecv {
    base: <OverlapBase>
    buflen: uint
    buf: ptr
    rcvd: u32
    flags: u32
}
// Send
struct OverlapSend {
    base: <OverlapBase>
    buflen: uint
    buf: ptr
    sent: u32
}

fn iocp() ext:HANDLE {
    let p = cport_instance
    if p != 0 : return p
    let res = ext:CreateIoCompletionPort(ext:INVALID_HANDLE_VALUE, null, 0, 0)
    if res == 0 : panic("Failed to create IO Completion Port")
    cport_instance = res
    // ext:SetFileCompletionNotificationModes(res, ext:FILE_SKIP_COMPLETION_PORT_ON_SUCCESS)
    // ext:SetFileCompletionNotificationModes(res, ext:FILE_SKIP_SET_EVENT_ON_HANDLE)
    return res
}

macro overlap "[" T:T "]" <{
    let data : <T> = @undefined
    let ov = @stableRef(data)
    mem:clear(ov, size_of(<T>))
    ov.base.coro = coro:current_coro
    return ov
}

#end
