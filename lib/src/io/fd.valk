
header "sys" as sys

use core
use coro

alias FD for int

// #if OS == win
// macro valk_fd (V:fd) : <{ return ((fd == -1.@cast(uint)) ? -1 : fd.@cast(int)) }
// macro os_fd (V:fd) : <{ return fd.@cast(uint) }
// #else
// macro valk_fd (V:fd) : <{ return fd.@cast(i32) }
// macro os_fd (V:fd) : <{ return fd.@cast(i32) }
// #end

#if OS == win
+ fn valk_fd(fd: int) FD { return ((fd == -1) ? -1 : fd.to(FD)) }
+ fn os_fd(fd: FD) uint { return fd.to(uint) }
#else
+ fn valk_fd(fd: int) FD { return fd.to(FD) }
+ fn os_fd(fd: FD) i32 { return fd.to(i32) }
#end

+ fn set_non_block(fd: FD, value: bool) {
    let ofd = os_fd(fd)
    #if OS == win
    let nonblock : uint = value ? 1 : 0
    let err = sys:ioctlsocket(ofd, sys:FIONBIO, @ref(nonblock))
    #else
    let flags = sys:fcntl(ofd, sys:F_GETFL, 0)
    let max : i32 = -1
    let v : i32 = value ? (flags | sys:O_NONBLOCK) : flags & (max - sys:O_NONBLOCK)
    let err = sys:fcntl(ofd, sys:F_SETFL, v)
    #end
    if err == -1 {
        #if OS == win
        err = sys:WSAGetLastError()
        if err == sys:WSAEINTR : set_non_block(fd, value) // Repeat
        #else
        err = sys:errno
        if err == sys:EINTR : set_non_block(fd, value) // Repeat
        #end

        // TODO: handle all errors
    }
}

+ fn close(fd: FD) {
    #if OS == win
    let ok = sys:CloseHandle(fd)
    if !ok {
        // TODO:
    }
    #else
    let err = sys:close(fd.to(i32))
    if err == -1 {
        // TODO:
    }
    #end
}
