
header "sys" as sys

use coro
use core
use mem

+ enum MODE {
    text
    binary
}

+ fn set_mode(fd: FD, mode: MODE) {
    #if OS == win
    if mode == MODE.text {
        sys:_setmode(fd.to(i32), sys:O_TEXT)
    } else if mode == MODE.binary {
        sys:_setmode(fd.to(i32), sys:O_BINARY)
    }
    #end
}

// Read
+ fn read(fd: FD, buf: ByteBuffer, amount: uint, offset: uint) uint !fail {
    buf.minimum_free_space(amount)
    let res = read_to_ptr(fd, buf.data.@offset(buf.length), amount, offset) !>
    buf.length += res
    return res
}
+ fn read_to_ptr_sync(fd: FD, buf: ptr, amount: uint, offset: uint) uint !fail {
    let rcvd = sys:read(fd.to(i32), buf, amount.to(u32))
    if rcvd < 0 : throw fail
    return rcvd
}
+ fn read_to_ptr(fd: FD, buf: ptr, amount: uint, offset: uint) uint !fail {

    let coro = coro:current_coro
    if !isset(coro) : return read_to_ptr_sync(fd, buf, amount, offset) !>

    #if OS == linux
    let sqe = sqe(coro) ! throw fail
    io_uring_prep_read(sqe, fd.@cast(i32), buf, amount.to(u32), offset)

    #elif OS == win
    let ov = overlap[OverlapRecv]
    ov.buflen = amount
    ov.buf = buf
    ov.base.sys.Offset = (offset & 0xFFFFFFFF).to(u32)
    ov.base.sys.OffsetHigh = (offset >> 32).to(u32)

    let ok = sys:ReadFile(fd, buf, amount.to(u32), null, ov)
    if !ok && sys:GetLastError() != sys:ERROR_IO_PENDING : throw fail
    coro:yield()

    ok = sys:GetOverlappedResult(fd, ov, &ov.rcvd, true)
    if !ok || ov.base.sys.Internal != 0 {
        throw fail
    }

    let rcvd = ov.rcvd
    if rcvd == 0 : throw fail
    return rcvd

    #elif OS == macos
    while true {
        let res = sys:read(fd, buf, amount.to(u32))
        if res < 0 {
            if sys:errno == sys:EAGAIN {
                let ev = await_fd(fd, true, false)
                if ev.is_closed() || !ev.is_readable() : throw fail
                continue
            }
            throw fail
        }
        return res.to(uint)
    }
    return 0

    #elif OS == bsd
    let cb = aio()
    cb.fd = fd
    cb.offset = offset.to(i64)
    cb.buf = buf
    cb.len = amount.to(i64)

    let kq = kqueue()
    cb.sig.kq = kq
    cb.sig.kevent_flags = EV_ADD | EV_ENABLE | EV_ONESHOT
    cb.sig.notify = SIGEV_KEVENT

    sys:aio_read(cb)

    #else
    #error "IO read: Unsupported OS"
    #end

    coro:yield()
    #if OS == bsd
    let rcvd = sys:aio_return(cb)
    aio_free(cb)
    #else
    let rcvd = coro.completion_res
    #end
    if rcvd < 0 : throw fail
    return rcvd.@cast(uint)
}

// Write
+ fn write(fd: FD, buf: ByteBuffer, amount: uint) uint !fail {
    if amount > buf.length : amount = buf.length
    return write_from_ptr(fd, buf.data, amount) !>
}
+ fn write_string(fd: FD, str: String) uint !fail {
    return write_from_ptr(fd, str.data, str.length) !>
}
+ fn write_from_ptr_sync(fd: FD, buf: ptr, amount: uint) uint !fail {
    let sent = sys:write(fd.to(i32), buf, amount.to(u32))
    if sent < 0 : throw fail
    return sent
}
+ fn write_from_ptr(fd: FD, buf: ptr, amount: uint) uint !fail {

    let coro = coro:current_coro

    #if OS == linux
    if !isset(coro) {
        let sent = sys:write(fd, buf, amount.to(u32))
        if sent < 0 : throw fail
        return sent
    }
    //
    let sqe = sqe(coro) ! throw fail
    io_uring_prep_write(sqe, fd.@cast(i32), buf, amount.to(u32), -1)
    coro:yield()
    let sent = coro.completion_res
    if sent < 0 : throw fail
    return sent.@cast(uint)

    #elif OS == win

    let ov = overlap[OverlapSend]
    ov.buflen = amount
    ov.buf = buf
    ov.base.sys.Offset = 0xFFFFFFFF
    ov.base.sys.OffsetHigh = 0xFFFFFFFF

    let ok = sys:WriteFile(fd, buf, amount.to(u32), null, ov)
    if !ok && sys:GetLastError() != sys:ERROR_IO_PENDING {
        throw fail
    }
    coro:yield()

    ok = sys:GetOverlappedResult(fd, ov, &ov.sent, true)
    if !ok || ov.base.sys.Internal != 0 {
        throw fail
    }

    let sent = ov.sent
    return sent

    #elif OS == macos
    let sent = sys:write(fd, buf, amount.to(u32))
    if sent < 0 : throw fail
    return sent.@cast(uint)

    #else
    #error "IO write: Unsupported OS"
    #end
}


+ fn await_fd(fd: FD, read: bool, write: bool) PollEvent {

    if !read && !write : return 0

    let coro = coro:current_coro
    if !isset(coro) {
        panic("Polling outside coroutine")
    }

    #if OS == linux
    let sqe = sqe(coro) ! return sys:POLLERR
    let events : u32 = sys:POLLERR | sys:POLLHUP | sys:POLLRDHUP
    if read : events = events | sys:POLLIN
    if write : events = events | sys:POLLOUT
    io_uring_prep_poll_add(sqe, fd.@cast(i32), events)

    #elif OS == macos
    let kq = kqueue()
    let ev : <sys:kEvent> = @undefined

    if read {
        EV_SET(@ref(ev), fd, EVFILT_READ, EV_ADD | EV_ENABLE | EV_ONESHOT, 0, 0, coro);
        sys:kevent(kq, @ref(ev), 1, null, 0, null);
    } else if write {
        EV_SET(@ref(ev), fd, EVFILT_WRITE, EV_ADD | EV_ENABLE | EV_ONESHOT, 0, 0, coro);
        sys:kevent(kq, @ref(ev), 1, null, 0, null);
    }

    #elif OS == win
    let port = iocp()
    let ov = overlap[OverlapData]

    if read {
        sys:ReadFile(fd, null.@cast(ptr), 0, null, ov)
        coro.poll_event = sys:POLLIN
    }
    else if write {
        sys:WriteFile(fd, null.@cast(ptr), 0, null, ov)
        coro.poll_event = sys:POLLOUT
    }

    #else
    #error "IO poll: Unsupported OS"
    #end

    coro.yield()
    return coro.poll_event
}

+ fn await_socket_fd(fd: FD, read: bool, write: bool) PollEvent {

    #if OS != win
    return await_fd(fd, read, write)
    #else

    if !read && !write : return 0

    let coro = coro:current_coro
    if !isset(coro) {
        panic("Polling outside coroutine")
    }

    let port = iocp()
    let ov = overlap[OverlapData]

    let event : PollEvent = 0
    if read {
        sys:WSARecv(fd, null, 0, null, null, ov, null)
        event = event | sys:POLLIN
    }
    else if write {
        sys:WSASend(fd, null, 0, null, 0, ov, null)
        event = event | sys:POLLOUT
    }
    coro.poll_event = event
    coro.yield()
    return coro.poll_event
    #end
}

