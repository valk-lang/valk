
header "sys" as sys

use utils
use coro
use core

// Read
+ fn read(fd: FD, buf: utils:ByteBuffer, amount: uint, offset: uint) uint !fail {
    buf.minimum_free_space(amount)
    let res = read_to_ptr(fd, buf.data.offset(buf.length), amount, offset) !>
    buf.length += res
    return res
}
+ fn read_to_ptr_sync(fd: FD, buf: ptr, amount: uint, offset: uint) uint !fail {
    let rcvd = sys:read(fd.to(i32), buf, amount.to(u32))
    if rcvd < 0 : throw fail
    return rcvd
}
+ fn read_to_ptr(fd: FD, buf: ptr, amount: uint, offset: uint) uint !fail {

    let coro = coro:current_coro
    if !isset(coro) : return read_to_ptr_sync(fd, buf, amount, offset) !>

    #if OS == linux
    let sqe = sqe(coro) ! throw fail
    io_uring_prep_read(sqe, fd.@cast(i32), buf, amount.to(u32), offset)

    #elif OS == win
    let ov = overlap[OverlapRecv]()
    ov.buflen = amount
    ov.buf = buf
    ov.base.sys.Offset = (offset & 0xFFFFFFFF).to(u32)
    ov.base.sys.OffsetHigh = (offset >> 32).to(u32)

    let ok = sys:ReadFile(fd, buf, amount.to(u32), null, ov)
    if !ok && sys:GetLastError() != sys:ERROR_IO_PENDING : throw fail
    coro:block()

    ok = sys:GetOverlappedResult(fd, ov, &ov.rcvd, true)
    if !ok || ov.base.sys.Internal != 0 {
        free_ov(ov)
        throw fail
    }

    let rcvd = ov.rcvd
    free_ov(ov)
    return rcvd

    #elif OS == macos
    let rcvd = sys:read(fd.to(i32), buf, amount.to(u32))
    if rcvd < 0 : throw fail
    return rcvd.@cast(uint)

    #elif OS == bsd
    let cb = aio()
    cb.fd = fd.to(i32)
    cb.offset = offset.to(i64)
    cb.buf = buf
    cb.len = amount.to(i64)

    let kq = coro.get_kq()
    cb.sig.kq = kq
    cb.sig.kevent_flags = EV_ADD | EV_ENABLE | EV_ONESHOT
    cb.sig.notify = SIGEV_KEVENT

    sys:aio_read(cb)

    #else
    #error "IO read: Unsupported OS"
    #end

    coro:block()
    #if OS == bsd
    let rcvd = sys:aio_return(cb)
    aio_free(cb)
    #else
    let rcvd = coro.completion_res
    #end
    if rcvd < 0 : throw fail
    return rcvd.@cast(uint)
}

// Receive
+ fn recv(fd: FD, buf: utils:ByteBuffer, amount: uint) uint !fail !again {
    buf.minimum_free_space(amount)
    let res = recv_to_ptr(fd, buf.data.offset(buf.length), amount) !>
    buf.length += res
    return res
}
+ fn recv_to_ptr(fd: FD, buf: ptr, amount: uint) uint !fail !again {

    let coro = coro:current_coro.@cast(coro:Coro)

    #if OS == linux
    let sqe = sqe(coro) ! throw fail
    io_uring_prep_recv(sqe, fd.@cast(i32), buf, amount.to(u32), 0)

    coro:block()
    let rcvd = coro.completion_res
    if rcvd <= 0 : throw fail
    return rcvd.@cast(uint)

    #elif OS == win
    let ov = overlap[OverlapRecv]()
    ov.buflen = amount
    ov.buf = buf

    let res = sys:WSARecv(fd, @ref(ov.buflen), 1, null, &ov.flags, ov, null)
    coro:block()

    let ok = sys:WSAGetOverlappedResult(fd, ov, &ov.rcvd, true, &ov.flags)
    if ov.base.sys.Internal != 0 {
        free_ov(ov)
        throw fail
    }

    let rcvd = ov.rcvd
    free_ov(ov)
    return rcvd

    #elif OS == macos
    let rcvd = sys:read(fd.to(i32), buf, amount.to(u32))
    if rcvd <= 0 {
        let err = core:socket_errno()
        if err == sys:EAGAIN : throw again
        if err != sys:EINTR : return 0 // Ignore interrupts
        throw fail
    }
    return rcvd.@cast(uint)

    #else
    #error "IO recv: Unsupported OS"
    #end
}


// Write
+ fn write(fd: FD, buf: utils:ByteBuffer, amount: uint) uint !fail {
    if amount > buf.length : amount = buf.length
    return write_from_ptr(fd, buf.data, amount) !>
}
+ fn write_string(fd: FD, str: String) uint !fail {
    return write_from_ptr(fd, str.data, str.length) !>
}
+ fn write_from_ptr_sync(fd: FD, buf: ptr, amount: uint) uint !fail {
    let sent = sys:write(fd.to(i32), buf, amount.to(u32))
    if sent < 0 : throw fail
    return sent
}
+ fn write_from_ptr(fd: FD, buf: ptr, amount: uint) uint !fail {

    let coro = coro:current_coro

    #if OS == linux
    if !isset(coro) {
        let sent = sys:write(fd.to(i32), buf, amount.to(u32))
        if sent < 0 : throw fail
        return sent
    }
    //
    let sqe = sqe(coro) ! throw fail
    io_uring_prep_write(sqe, fd.@cast(i32), buf, amount.to(u32), -1)
    coro:block()
    let sent = coro.completion_res
    if sent < 0 : throw fail
    return sent.@cast(uint)

    #elif OS == win

    let ov = overlap[OverlapSend]()
    ov.buflen = amount
    ov.buf = buf
    ov.base.sys.Offset = 0xFFFFFFFF
    ov.base.sys.OffsetHigh = 0xFFFFFFFF

    let ok = sys:WriteFile(fd, buf, amount.to(u32), null, ov)
    if !ok && sys:GetLastError() != sys:ERROR_IO_PENDING : throw fail
    coro:block()

    ok = sys:GetOverlappedResult(fd, ov, &ov.sent, true)
    if !ok || ov.base.sys.Internal != 0 {
        free_ov(ov)
        throw fail
    }

    let sent = ov.sent
    free_ov(ov)
    return sent

    #elif OS == macos
    let sent = sys:write(fd.to(i32), buf, amount.to(u32))
    if sent < 0 : throw fail
    return sent.@cast(uint)

    #else
    #error "IO write: Unsupported OS"
    #end
}

// Receive
+ fn send(fd: FD, buf: utils:ByteBuffer, amount: uint) uint !fail !again {
    if amount > buf.length : amount = buf.length
    return send_from_ptr(fd, buf.data, amount) !>
}
+ fn send_string(fd: FD, str: String) uint !fail !again {
    return send_from_ptr(fd, str.data, str.length) !>
}
+ fn send_from_ptr(fd: FD, buf: ptr, amount: uint) uint !fail !again {

    let coro = coro:current_coro.@cast(coro:Coro)

    #if OS == linux
    let sqe = sqe(coro) ! throw fail
    io_uring_prep_send(sqe, fd.@cast(i32), buf, amount.to(u32), 0)

    coro:block()
    let sent = coro.completion_res
    if sent <= 0 : throw fail
    return sent.@cast(uint)

    #elif OS == win
    let ov = overlap[OverlapSend]()
    ov.buflen = amount
    ov.buf = buf

    let res = sys:WSASend(fd, @ref(ov.buflen), 1, null, 0, ov, null)
    coro:block()

    let flags : u32 = 0
    let ok = sys:WSAGetOverlappedResult(fd, ov, &ov.sent, true, &flags)
    if ov.base.sys.Internal != 0 {
        free_ov(ov)
        throw fail
    }

    let sent = ov.sent
    free_ov(ov)
    return sent

    #elif OS == macos
    let sent = sys:write(fd.to(i32), buf, amount.to(u32))
    if sent <= 0 {
        let err = core:socket_errno()
        if err == sys:EAGAIN : throw again
        if err != sys:EINTR : return 0 // Ignore interrupts
        throw fail
    }
    return sent.@cast(uint)

    #else
    #error "IO send: Unsupported OS"
    #end
}


+ fn await_fd(fd: FD, read: bool, write: bool) PollEvent {

    if !read && !write : return 0

    let coro = coro:current_coro
    if !isset(coro) {
        panic("Polling outside coroutine")
    }

    #if OS == linux
    let sqe = sqe(coro) ! return sys:POLLERR
    let events : u32 = sys:POLLERR | sys:POLLHUP | sys:POLLRDHUP
    if read : events = events | sys:POLLIN
    if write : events = events | sys:POLLOUT
    io_uring_prep_poll_add(sqe, fd.@cast(i32), events)

    #elif OS == macos
    let kq = coro.get_kq()
    let ev : <sys:kEvent> = @undefined

    if read {
        EV_SET(@ref(ev), fd, EVFILT_READ, EV_ADD | EV_ENABLE | EV_ONESHOT, 0, 0, coro);
        sys:kevent(kq, @ref(ev), 1, null, 0, null);
    } else if write {
        EV_SET(@ref(ev), fd, EVFILT_WRITE, EV_ADD | EV_ENABLE | EV_ONESHOT, 0, 0, coro);
        sys:kevent(kq, @ref(ev), 1, null, 0, null);
    }

    #elif OS == win
    let port = iocp()
    let data = overlap[OverlapData]()
    let bytes : u32 = 0
    let flags : u32 = 0
    if read {
        sys:ReadFile(fd, null.@cast(ptr), 0, &bytes, data)
        coro.poll_event = sys:POLLIN
    }
    else if write {
        sys:WriteFile(fd, null.@cast(ptr), 0, &bytes, data)
        coro.poll_event = sys:POLLOUT
    }

    #else
    #error "IO poll: Unsupported OS"
    #end

    coro.block()
    return coro.poll_event
}

+ fn await_socket_fd(fd: uint, read: bool, write: bool) PollEvent {

    #if OS != win
    return await_fd(fd, read, write)
    #else

    if !read && !write : return 0

    let coro = coro:current_coro
    if !isset(coro) {
        panic("Polling outside coroutine")
    }

    let port = iocp()
    let ov = overlap[OverlapData]()

    let bytes : u32 = 0
    let flags : u32 = 0
    let event : PollEvent = 0
    if read {
        sys:WSARecv(fd, null, 0, null, null, ov, null)
        event = event | sys:POLLIN
    }
    else if write {
        sys:WSASend(fd, null, 0, &bytes, 0, ov, null)
        event = event | sys:POLLOUT
    }
    coro.poll_event = event

    coro.block()

    free_ov(ov)
    return coro.poll_event
    #end
}

