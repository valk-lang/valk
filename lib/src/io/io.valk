
header "sys" as sys

use utils
use coro
use core

// Read
+ fn read(fd: FD, buf: utils:ByteBuffer, amount: uint) uint !fail {
    buf.minimum_free_space(amount)
    let res = read_to_ptr(fd, buf.data.offset(buf.length), amount) !>
    buf.length += res
    return res
}
+ fn read_to_ptr(fd: FD, buf: ptr, amount: uint) uint !fail {

    let coro = coro:current_coro
    if !isset(coro) {
        let rcvd = sys:read(fd.to(i32), buf, amount.to(u32))
        if rcvd < 0 : throw fail
        return rcvd
    }

    #if OS == linux
    let sqe = sqe(coro) ! throw fail
    io_uring_prep_read(sqe, fd.@cast(i32), buf, amount.to(u32), -1)

    #elif OS == win
    let rcvd = sys:read(fd.to(i32), buf, amount.to(u32))
    if rcvd < 0 : throw fail
    return rcvd

//     let ov = overlap[OverlapRecv]()
//     ov.buflen = amount
//     ov.buf = buf

//     let ok = sys:ReadFile(fd, @ref(ov.buflen), 1, null, ov)
//     if !ok {
//         let err = sys:GetLastError()
//         println("ERR: " + err)
//         if err == sys:ERROR_IO_PENDING {
//             println("RF >")
//             coro:block()
//             println("RF <")
//         }
//     }

//     ok = sys:WSAGetOverlappedResult(fd, ov, &ov.rcvd, true, &ov.flags)
//     if ov.base.sys.Internal != 0 {
//         free_ov(ov)
//         throw fail
//     }

//     let rcvd = ov.rcvd
// println("R: " + rcvd)
//     free_ov(ov)
//     return rcvd

    #elif OS == macos
    let rcvd = sys:read(fd.to(i32), buf, amount.to(u32))
    if rcvd < 0 : throw fail
    return rcvd.@cast(uint)

    #else
    #error "IO read: Unsupported OS"
    #end

    coro:block()
    let rcvd = coro.completion_res
    if rcvd < 0 : throw fail
    return rcvd.@cast(uint)
}

// Receive
+ fn recv(fd: FD, buf: utils:ByteBuffer, amount: uint) uint !fail !again {
    buf.minimum_free_space(amount)
    let res = recv_to_ptr(fd, buf.data.offset(buf.length), amount) !>
    buf.length += res
    return res
}
+ fn recv_to_ptr(fd: FD, buf: ptr, amount: uint) uint !fail !again {

    let coro = coro:current_coro.@cast(coro:Coro)

    #if OS == linux
    let sqe = sqe(coro) ! throw fail
    io_uring_prep_recv(sqe, fd.@cast(i32), buf, amount.to(u32), 0)

    coro:block()
    let rcvd = coro.completion_res
    if rcvd <= 0 : throw fail
    return rcvd.@cast(uint)

    #elif OS == win
    let ov = overlap[OverlapRecv]()
    ov.buflen = amount
    ov.buf = buf

    let res = sys:WSARecv(fd, @ref(ov.buflen), 1, null, &ov.flags, ov, null)
    coro:block()

    let ok = sys:WSAGetOverlappedResult(fd, ov, &ov.rcvd, true, &ov.flags)
    if ov.base.sys.Internal != 0 {
        free_ov(ov)
        throw fail
    }

    let rcvd = ov.rcvd
    free_ov(ov)
    return rcvd

    #elif OS == macos
    let rcvd = sys:read(fd.to(i32), buf, amount.to(u32))
    if rcvd <= 0 {
        let err = core:socket_errno()
        if err == sys:EAGAIN : throw again
        if err != sys:EINTR : return 0 // Ignore interrupts
        throw fail
    }
    return rcvd.@cast(uint)

    #else
    #error "IO recv: Unsupported OS"
    #end
}


// Write
+ fn write(fd: FD, buf: utils:ByteBuffer, amount: uint) uint !fail {
    if amount > buf.length : amount = buf.length
    return write_from_ptr(fd, buf.data, amount) !>
}
+ fn write_string(fd: FD, str: String) uint !fail {
    return write_from_ptr(fd, str.data, str.length) !>
}
+ fn write_from_ptr(fd: FD, buf: ptr, amount: uint) uint !fail {

    let coro = coro:current_coro

    #if OS == linux
    if !isset(coro) {
        let sent = sys:write(fd.to(i32), buf, amount.to(u32))
        if sent < 0 : throw fail
        return sent
    }
    //
    let sqe = sqe(coro) ! throw fail
    io_uring_prep_write(sqe, fd.@cast(i32), buf, amount.to(u32), -1)
    coro:block()
    let sent = coro.completion_res
    if sent < 0 : throw fail
    return sent.@cast(uint)

    #elif OS == win
    let sent = sys:write(fd.to(i32), buf, amount.to(u32))
    if sent < 0 : throw fail
    return sent

//     let ov = overlap[OverlapRecv]()
//     ov.buflen = amount
//     ov.buf = buf

//     let ok = sys:ReadFile(fd, @ref(ov.buflen), 1, null, ov)
//     if !ok {
//         let err = sys:GetLastError()
//         println("ERR: " + err)
//         if err == sys:ERROR_IO_PENDING {
//             println("RF >")
//             coro:block()
//             println("RF <")
//         }
//     }

//     ok = sys:WSAGetOverlappedResult(fd, ov, &ov.rcvd, true, &ov.flags)
//     if ov.base.sys.Internal != 0 {
//         free_ov(ov)
//         throw fail
//     }

//     let rcvd = ov.rcvd
// println("R: " + rcvd)
//     free_ov(ov)
//     return rcvd

    #elif OS == macos
    let sent = sys:write(fd.to(i32), buf, amount.to(u32))
    if sent < 0 : throw fail
    return sent.@cast(uint)

    #else
    #error "IO write: Unsupported OS"
    #end
}

// Receive
+ fn send(fd: FD, buf: utils:ByteBuffer, amount: uint) uint !fail !again {
    if amount > buf.length : amount = buf.length
    return send_from_ptr(fd, buf.data, amount) !>
}
+ fn send_string(fd: FD, str: String) uint !fail !again {
    return send_from_ptr(fd, str.data, str.length) !>
}
+ fn send_from_ptr(fd: FD, buf: ptr, amount: uint) uint !fail !again {

    let coro = coro:current_coro.@cast(coro:Coro)

    #if OS == linux
    let sqe = sqe(coro) ! throw fail
    io_uring_prep_send(sqe, fd.@cast(i32), buf, amount.to(u32), 0)

    coro:block()
    let sent = coro.completion_res
    if sent <= 0 : throw fail
    return sent.@cast(uint)

    #elif OS == win
    let ov = overlap[OverlapSend]()
    ov.buflen = amount
    ov.buf = buf

    let res = sys:WSASend(fd, @ref(ov.buflen), 1, null, 0, ov, null)
    coro:block()

    let flags : u32 = 0
    let ok = sys:WSAGetOverlappedResult(fd, ov, &ov.sent, true, &flags)
    if ov.base.sys.Internal != 0 {
        free_ov(ov)
        throw fail
    }

    let sent = ov.sent
    free_ov(ov)
    return sent

    #elif OS == macos
    let sent = sys:write(fd.to(i32), buf, amount.to(u32))
    if sent <= 0 {
        let err = core:socket_errno()
        if err == sys:EAGAIN : throw again
        if err != sys:EINTR : return 0 // Ignore interrupts
        throw fail
    }
    return sent.@cast(uint)

    #else
    #error "IO send: Unsupported OS"
    #end
}
