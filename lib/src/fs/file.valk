
use ext
use io

#if OS != win
use core
#end

value default_read_size (32 * 1024)

+ fn open(path: String, writable: bool, append_on_write: bool) FD !open {
    return open_extend(path, writable, append_on_write, false) ! throw open
}
+ fn open_extend(path: String, writable: bool, append_on_write: bool, create_file_if_doesnt_exist: bool (false), create_file_permissions: u32 (0c644)) FD !open !access {

    // let flags : i32 = (ext:O_RDONLY | ext:O_NONBLOCK).@cast(i32)
    #if OS == win
    let access : u32 = ext:GENERIC_READ
    if writable : access = access | ext:GENERIC_WRITE
    // Shade mode
    let share_mode : u32 = ext:FILE_SHARE_READ
    // dwCreationDisposition
    let despo : u32 = ext:OPEN_EXISTING
    if writable {
        despo = append_on_write ? ext:OPEN_EXISTING : ext:TRUNCATE_EXISTING
        if create_file_if_doesnt_exist : despo = append_on_write ? ext:OPEN_ALWAYS : ext:CREATE_ALWAYS
    }
    // Flags
    let flags : u32 = ext:FILE_FLAG_OVERLAPPED | ext:FILE_FLAG_SEQUENTIAL_SCAN
    //
    let fd = ext:CreateFileA(path.data_cstring, access, share_mode, null, despo, flags, 0)
    if fd == ext:INVALID_HANDLE_VALUE : throw open

    ext:CreateIoCompletionPort(fd, io:iocp(), 0, 0)

    #else
    let flags : i32 = ext:O_RDONLY.@cast(i32)
    if writable : flags = ext:O_RDWR

    if create_file_if_doesnt_exist : flags = flags | ext:O_CREAT
    if writable {
        flags = flags | (append_on_write ? ext:O_APPEND : ext:O_TRUNC)
    }

    let fd = ext:open(path.data_cstring, flags, create_file_permissions.to(i32))
    if fd < 0 {
        throw open
    }

    #end

    return fd.@cast(FD)
}

- fn stat(path: String, buf: ext:libc_stat) !fail {
    let res = ext:stat(path.data_cstring, buf)
    if res == -1 : throw fail
}
+ fn size(path: String) uint {
    let buf = @stack(<ext:libc_stat>)
    stat(path, buf) ! return 0
    return buf.st_size.@cast(uint)
}

+ fn sync() {
    ext:sync()
}

+ fn read(path: String) String !open !read !close {

	let fd = open(path, false, false) ! throw open
    let size : uint = size(path)
    let offset : uint = 0
    let buffer = ByteBuffer.new(default_read_size)

	while offset < size {
		let readcount = io:read(fd, buffer, default_read_size, offset) ! {
            io:close(fd)
            throw read
        }
        offset += readcount
	}

	io:close(fd)
	return buffer
}

+ fn write(path: String, content: String, append: bool (false)) !open !write {
    let fd = open_extend(path, true, append, true) ! throw open
    io:write_string(fd, content) ! {
        io:close(fd)
        throw write
    }
    io:close(fd)
}

+ fn write_from_ptr(path: String, data: ptr, size: uint, append: bool (false)) !open !write {
    let fd = open_extend(path, true, append, true) ! throw open
    io:write_from_ptr(fd, data, size) ! {
        io:close(fd)
        throw write
    }
    io:close(fd)
}

+ fn exists(path: String) bool {
	#if OS == win
	let dwAttrib = ext:GetFileAttributesA(path.data_cstring)
    return dwAttrib != ext:INVALID_FILE_ATTRIBUTES_fix
	#else
    return ext:access(path.data_cstring, ext:F_OK) == 0
    #end
}
+ fn delete(path: String) !delete {
    // ext:unlink(path.data_cstring)
    let res = ext:unlink(path.data_cstring)
    if res == -1 : throw delete
}
+ fn delete_recursive(path: String) {
    let isdir = is_dir(path)
    if isdir {
        let list = Array[String].new()
        files_in(path, true, true, false, null, list)
        each list as file {
            delete(file) _
        }
        list.clear()
        files_in(path, true, false, true, null, list)
        list.reverse()
        each list as file {
            rmdir(file) _
        }
        // Delete dir itself
        rmdir(path) _
    } else {
        delete(path) _
    }
}
+ fn move(from_path: String, to_path: String) !fail {
    let res = ext:rename(from_path.data_cstring, to_path.data_cstring)
    if res != 0 : throw fail
}

+ fn copy(from_path: String, to_path: String, recursive: bool (false)) !fail {
    if from_path == to_path : return
    let isdir = is_dir(from_path)
    if isdir {
        if !exists(to_path) : mkdir(to_path) ! throw fail
        else if !is_dir(to_path) : throw fail
        // Copy files
        let files = files_in(from_path, false, true, true, "")
        each files as fn {
            let from = add(from_path, fn)
            let to = add(to_path, fn)
            copy(from, to, recursive) ! throw fail
        }
    } else {

        let buf = ByteBuffer.new(32000)
        let in = open_extend(from_path, false, false) ! throw fail
        let out = open_extend(to_path, true, false, true) ! throw fail

        let offset : uint = 0

        while true {
            let rcount = io:read(in, buf, 32000, offset) ! {
                io:close(in)
                io:close(out)
                throw fail
            }
            if rcount == 0 {
                io:close(in)
                io:close(out)
                break
            }
            io:write(out, buf, buf.length) ! {
                io:close(in)
                io:close(out)
                throw fail
            }
            buf.clear()
            offset += rcount
            if rcount < 32000 {
                io:close(in)
                io:close(out)
                break
            }
        }
    }
}

+ fn mkdir(path: String, permissions: u32 (0c755)) !fail {
    if ext:mkdir(path.data_cstring, permissions) == -1 {
        throw fail
    }
}
+ fn rmdir(path: String) !fail {
    if ext:rmdir(path.data_cstring) == -1 : throw fail
}

+ fn is_file(path: String) bool {
    let buf = @stack(<ext:libc_stat>)
    stat(path, buf) ! return false
    return (buf.st_mode & ext:S_IFMT) == ext:S_IFREG
}
+ fn is_dir(path: String) bool {
    let buf = @stack(<ext:libc_stat>)
    stat(path, buf) ! return false
    return (buf.st_mode & ext:S_IFDIR) == ext:S_IFDIR
}
+ fn modified_time(path: String) uint !file_not_found {
    #if OS == win
    let ftMod = @stack(<ext:libc_FILETIME>)
    let hndl = ext:CreateFileA(path, ext:FILE_READ_ATTRIBUTES, ext:FILE_SHARE_READ | ext:FILE_SHARE_WRITE, null, ext:OPEN_EXISTING, ext:FILE_FLAG_BACKUP_SEMANTICS, 0)
    if hndl == ext:INVALID_HANDLE_VALUE : throw file_not_found
    if !ext:GetFileTime(hndl, null, null, &ftMod) : throw file_not_found
    // FILETIME = 100-ns ticks since 1601-01-01 UTC
    let ticks : u64 = (ftMod.dwHighDateTime.@cast(u64) << 32) | ftMod.dwLowDateTime
    // Subtract difference between 1601-01-01 and 1970-01-01
    let ns100 = ticks - 116444736000000000
    return ns100 * 100 // to nanoseconds
    #else
    let buf = @stack(<ext:libc_stat>)
    stat(path, buf) ! throw file_not_found
    #if OS == linux
    let ns = buf.st_mtim.tv_sec.to(u64) * 1_000_000_000 + buf.st_mtim.tv_nsec
    #elif OS == macos
    let ns = buf.st_mtimespec.tv_sec.to(u64) * 1_000_000_000 + buf.st_mtimespec.tv_nsec
    #end
    return ns
    #end
}

+ fn files_in(dir: String, recursive: bool (false), files: bool (true), dirs: bool (true), prefix: ?String (null), result: Array[String] (.{})) Array[String] {

    dir = resolve(dir)
    if !isset(prefix) : prefix = dir

    #if OS == win

    let glob : String = add(dir, "*")
    let pattern = glob.data_cstring
    let data = @stack(<ext:libc_WIN32_FIND_DATAA>)
    let hFind = ext:FindFirstFileA(pattern, data)
    if hFind != -1.@cast(ptr) {
        let loop = true
        while loop {
            let fn = data.cFileName.@cast(cstring).to_string()

            if fn.bytes < 3 && (fn == "." || fn == "..") {
                loop = ext:FindNextFileA(hFind, data)
                continue
            }

            let is_dir = (data.dwFileAttributes & 0x10) > 0
            let is_file = !is_dir
            let full = add(dir, fn)
            fn = prefix.length > 0 ? add(prefix, fn) : fn

            if (dirs && is_dir) || (files && is_file) {
                result.append(fn)
            }
            if is_dir && recursive {
                files_in(full, recursive, files, dirs, fn, result)
            }

            loop = ext:FindNextFileA(hFind, data)
        }
        ext:FindClose(hFind)
    }

    #else

    let d = ext:opendir(dir.data_cstring)

    if isset(d) {
        while true {
            let ent = ext:readdir(d)
            if isset(ent) {
                let fn = ent.d_name.@cast(cstring).to_string()

                if fn.bytes < 3 && (fn == "." || fn == ".." || fn == "") {
                    continue
                }

                let full = add(dir, fn)
                fn = prefix.length > 0 ? add(prefix, fn) : fn
                let _is_dir = is_dir(full)
                let _is_file = !_is_dir

                if (dirs && _is_dir) || (files && _is_file) {
                    result.append(fn)
                }

                if _is_dir && recursive {
                    files_in(full, recursive, files, dirs, fn, result)
                }

                continue
            }
            break

        }
        ext:closedir(d)
    }

    #end

    return result
}


+ fn symlink(link: String, target: String, is_directory: bool) !permissions !exists !other {
    #if OS == win
    let flag : u32 = ext:SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE
    if is_directory : flag = flag | ext:SYMBOLIC_LINK_FLAG_DIRECTORY
    if ext:CreateSymbolicLinkA(link.data_cstring, target.data_cstring, flag) == 1 : return
    let error = ext:GetLastError()
    if error == ext:ERROR_PRIVILEGE_NOT_HELD : throw permissions
    if error == ext:ERROR_ALREADY_EXISTS : throw exists
    #else
    if ext:symlink(target.data_cstring, link.data_cstring) == 0 : return
    let error = ext:errno
    if error == ext:EACCES : throw permissions
    if error == ext:EEXIST : throw exists
    #end

    throw other
}
