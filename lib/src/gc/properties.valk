
fn property_update(on_object: ptr, property_ref: ptr, new_value: ?ptr) {
    let data = (@offset(on_object, u8, -8)).@cast(GcData)
    let state = data.state
    if state > state_new {
        let old = @ptrv(property_ref, ptr)
        if old & 1 == 1 {
            let old_item : ptr = old - 1
            let data = (@offset(old_item, u8, -8)).@cast(GcData)
            data.state--

            let adr = gc.disconnect_list.get(size_of(ptr))
            @ptrv(adr, ptr) = old_item
        }
        // New value
        if isset(new_value) {
            if state == state_used {
                if !data.is_in_updates() {
                    data.set_in_updates()
                    let adr = gc.updated_list.get(size_of(ptr))
                    @ptrv(adr, ptr) = on_object
                }
            } else if state > state_used {
                share(new_value)
            }
        }
    }
    @ptrv(property_ref, ?ptr) = new_value
}

fn property_set(on_object: ptr, property_ref: ptr, value: ?ptr) {
    if isset(value) {
        let data = (@offset(on_object, u8, -8)).@cast(GcData)
        let state = data.state
        if state >= state_used {
            if state == state_used {
                if !data.is_in_updates() {
                    data.set_in_updates()
                    let adr = gc.updated_list.get(size_of(ptr))
                    @ptrv(adr, ptr) = on_object
                }
            } else {
                share(value)
            }
        }
    }
    @ptrv(property_ref, ?ptr) = value
}

fn property_get(property_ref: ptr) ptr {
    return @ptrv(property_ref, ?ptr) & -4.to(uint)
}

fn property_remove(on_object: ptr, property_ref: ptr) {
    let data = (@offset(on_object, u8, -8)).@cast(GcData)
    let value = @ptrv(property_ref, ptr)
    if value & 1 == 1 {
        let item : ptr = value - 1
        let data = (@offset(item, u8, -8)).@cast(GcData)
        data.state--

        let adr = gc.disconnect_list.get(size_of(ptr))
        @ptrv(adr, ptr) = item
    }
}

fn property_mark(on_object: GcItem, property_ref: ptr) {
    let value = @ptrv(property_ref, ?GcItem)
    if isset(value) && (value & 3 == 0) {
        let value_data = value.data()
        if value_data.state < state_used {
            mark_used(value)
            @ptrv(property_ref, ptr) = value | 1
        } else {
            // Co own
            let data = on_object.data()
            @ptrv(property_ref, ptr) = value | 2
            data.co_own()
            // if !data.is_in_updates() {
            //     data.set_in_updates()
            //     let adr = gc.reconnect_list.get(size_of(ptr))
            //     @ptrv(adr, ptr) = on_object
            // }
        }
    }
}

// fn property_disconnect(on_object: ptr, property_ref: ptr) {
//     let value = @ptrv(property_ref, ptr)
//     if value & 1 == 1 {
//         let base : ptr = value - 1
//         @ptrv(property_ref, ?ptr) = base

//         let data = (@offset(base, u8, -8)).@cast(GcData)

//         disconnect_rec(base)
//     }
// }


fn property_share(on_object: ptr, property_ref: ptr) {
    let item = @ptrv(property_ref, ?ptr)
    if isset(item) {
        share(item & -4.to(uint))
    }
}
fn property_share_update_age(on_object: ptr, property_ref: ptr) {
    let item = @ptrv(property_ref, ?ptr)
    if isset(item) {
        let base = item & -4.to(uint)
        let data = (@offset(base, u8, -8)).@cast(GcData)
        if data.state == state_shared_unused {
            share(base)
        }
    }
}

fn property_remove_co_owners(on_object: ptr, property_ref: ptr) {
    let item = @ptrv(property_ref, ?GcItem)
    if isset(item) {
                    if item & 3 == 3 : panic("IS3")
        if item & 1 == 1 {
            remove_co_owners(item - 1)
        } else if item & 2 == 2 {
            item = item - 2
            @ptrv(property_ref, ptr) = item
            item.data().dis_co_own()
        }
    }
}

fn property_check_co_owners(on_object: ptr, property_ref: ptr) {
    let sub = @ptrv(property_ref, GcItem)
                    if sub & 3 == 3 : panic("IS3")
    if sub & 1 == 1 {
        // Remove ownership
        sub = sub & -4.to(uint)
        @ptrv(property_ref, GcItem) = sub

        let sub_data = sub.data()
        if sub_data.state < state_shared_unused {
            check_co_owners(sub)
        // } else {
        }
            sub_data.state--
    }
}

fn property_retake_co_ownership(on_object: ptr, property_ref: ptr) {
    let sub = @ptrv(property_ref, ?GcItem)
    if isset(sub) {
                    if sub & 3 == 3 : panic("IS3")
        if (sub & 1 == 1) {
            retake_co_ownership(sub & -4.to(uint))
        } else {
            sub = sub & -4.to(uint)
            let sub_data = sub.data()
            if sub_data.state < state_used {
                // Take ownership
                @ptrv(property_ref, GcItem) = sub | 1
                mark_used(sub)
            } else {
                // Co own
                @ptrv(property_ref, GcItem) = sub | 2
                sub_data.co_own()
            }
        }
    }
}
