
fn property_update(on_object: ptr, property_ref: ptr, new_value: ?ptr) {
    let data = (@ptr_offset(on_object, -8)) @as GcData
    let old = @ptrv(property_ref, ptr)
    if old & 1 == 1 {
        let old_item : ptr = old - 1
        let data = (@ptr_offset(old_item, -8)) @as GcData
        // data.state = state_unused
        data.state--

        let adr = disconnect_list.get(sizeof(ptr))
        @ptrv(adr, ptr) = old_item
    }
    if data.state >= state_used {
        if isset(new_value) {
            if data.state == state_used {
                let in_list = data.in_list
                if in_list & in_list_reconnect == 0 {
                    data.in_list = in_list | in_list_reconnect

                    let adr = reconnect_list.get(sizeof(ptr))
                    @ptrv(adr, ptr) = on_object
                }
            } else {
                share(new_value)
            }
        }
    }
    @ptrv(property_ref, ?ptr) = new_value
}

fn property_set(on_object: ptr, property_ref: ptr, value: ?ptr) {
    if isset(value) {
        let data = (@ptr_offset(on_object, -8)) @as GcData
        let state = data.state
        if state >= state_used {
            if state == state_used {
                let in_list = data.in_list
                if in_list & in_list_reconnect == 0 {
                    data.in_list = in_list | in_list_reconnect
                    let adr = reconnect_list.get(sizeof(ptr))
                    @ptrv(adr, ptr) = on_object
                }
            } else {
                share(value)
            }
        }
    }
    @ptrv(property_ref, ?ptr) = value
}

fn property_get(property_ref: ptr) ptr {
    return @ptrv(property_ref, ?ptr) & -2
}

fn property_remove(on_object: ptr, property_ref: ptr) {
    let data = (@ptr_offset(on_object, -8)) @as GcData
    let old = @ptrv(property_ref, ptr)
    if old & 1 == 1 {
        let old_item : ptr = old - 1
        let data = (@ptr_offset(old_item, -8)) @as GcData
        // data.state = state_unused
        data.state--

        let adr = disconnect_list.get(sizeof(ptr))
        @ptrv(adr, ptr) = old_item
    }
}

//
fn property_mark(on_object: ptr, property_ref: ptr) {
    let value = @ptrv(property_ref, ?ptr)
    if isset(value) && (value & 1 == 0) {
        let value_data = (@ptr_offset(value, -8)) @as GcData
        if value_data.state < state_used {
            mark_used(value)
            @ptrv(property_ref, ?ptr) = value | 1
        } else {
            // Add to reconnect list
            let data = (@ptr_offset(on_object, -8)) @as GcData
            let in_list = data.in_list
            if in_list & in_list_reconnect == 0 {
                data.in_list = in_list | in_list_reconnect
                let adr = reconnect_list.get(sizeof(ptr))
                @ptrv(adr, ptr) = on_object
            }
        }
    }
}

fn property_disconnect(property_ref: ptr) {
    let value = @ptrv(property_ref, ptr)
    if value & 1 == 1 {
        let base : ptr = value & -2
        @ptrv(property_ref, ?ptr) = base

        let data = (@ptr_offset(base, -8)) @as GcData
        data.state--

        disconnect_rec(base)
    }
}

fn property_confirm_disconnect(property_ref: ptr) {
    let value = @ptrv(property_ref, ?ptr)
    if isset(value) && (value & 1 == 0) {
        free_disconnect_rec(value & -2)
    }
}


fn property_share(property_ref: ptr) {
    let item = @ptrv(property_ref, ?ptr)
    if isset(item) {
        share(item & -2)
    }
}