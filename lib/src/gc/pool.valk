
use core
use mem

global vtable_count: u32
global vtables: ptr

global pools: ptr

value POOL_DATA_OFFSET (sizeof(ptr) * 4)

value byte_color (0)
value byte_shared_age (2)
value byte_block_index (3)

value byte_color_rel (-4)
value byte_shared_age_rel (-6)
value byte_block_index_rel (-5)

fn pools_init() {
    pools = mem:calloc(64 * sizeof(ptr))
}
fn vtables_init() {
    vtables = mem:calloc((vtable_count @as uint + 1) * sizeof(ptr))
}

// fn pool_alloc(size: uint, vtable_index: uint (0)) ptr {
//     let pow: uint = 3
//     let value: uint = 8
//     while size > value {
//         value *= 2
//         pow++
//     }
//     let pool = @ptrv(pools, ?GcPool, pow)
//     if !isset(pool) {
//         let p = GcPool.init(value)
//         @ptrv(pools, ?GcPool, pow) = p
//         let item = p.get()
//         @ptrv(item, u16, -1) = vtable_index @as u16
//         return item
//     }
//     let item = pool.get()
//     @ptrv(item, u16, -1) = vtable_index @as u16
//     return item
// }

struct Pool {
    blockc: uint
    first: ptr
    block: ptr
    index: uint (0)
    isize: uint (0)

    pub static fn init[T]() Pool {
        let s = sizeof(<T>) + 8

        let mark = mark[T]
        // let demark = demark[T]

        return Pool {
            isize: s
            first: null @as ptr
            block: null @as ptr
            blockc: 1
        }
    }

    static fn create_block(size: uint, isize: uint) ptr {
        if size > 248 : size = 248
        let b = mem:alloc(size * isize + POOL_DATA_OFFSET)
        // Settings
        @ptrv(b, ?ptr, 0) = null // next block
        @ptrv(b, uint, 1) = size // count
        @ptrv(b, uint, 2) = 0 // used
        @ptrv(b, uint, 3) = 0 // usage percent
        // Set indexes
        let data = b + POOL_DATA_OFFSET
        let i : uint = 0
        while i < size {
            let item : ptr = data + i * isize
            @ptrv(item, u64) = 0
            @ptrv(item, u8, byte_shared_age) = 0
            @ptrv(item, u8, byte_block_index) = i @as u8
            i++
        }
        return b
    }

    fn get() ptr {

        let isize = this.isize
        if this.block == null {
            this.block = Pool.create_block(this.blockc * 2, isize)
            this.first = this.block
        }

        while true {
            let block = this.block
            if @ptrv(block, uint, 3) > 90 {
                this.set_next_block(block)
                continue
            }
            let index = this.index
            if index == @ptrv(block, uint, 1) {
                this.set_next_block(block)
                continue
            }
            this.index++
            let data = block + POOL_DATA_OFFSET
            let item = data + index * isize
            if @ptrv(item, u16, byte_color) != color_blank {
                continue
            }

            // Increase mem usage
            mem_new += isize

            return (item + 8)
        }
        println("Failed to allocate memory")
        core:exit(1)
    }

    fn set_next_block(block: ptr) {
        let next = @ptrv(block, ?ptr, 0)
        if isset(next) {
            this.set_block(next @as ptr)
        } else {
            // Create new block
            let blockc = ++this.blockc
            let new = Pool.create_block(blockc * blockc, this.isize)
            // Set next
            @ptrv(block, ptr, 0) = new
            this.set_block(new)
        }

        // Check mem usage
        update_usage()
    }

    fn set_block(block: ptr) {
        this.block = block
        this.index = 0
    }
}
