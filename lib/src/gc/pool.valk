
use core
use mem

global poolc: uint
global pools_bump: Bump (@undefined)
global pools: ptr

value POOL_DATA_OFFSET ((sizeof(ptr) * 4))

value byte_local (0)
value byte_share (1)
value byte_propc (2)

value byte_local_rel (-8)
value byte_share_rel (-7)
value byte_propc_rel (-6)

fn pools_init() {
    pools_bump = Bump.new()

    let i : uint = sizeof(ptr)
    let c : uint = 0
    while i <= 16 * sizeof(ptr) {
        let pool = Pool.init(i)
        @ptrv(pools_bump.data, Pool, c) = pool
        i += sizeof(ptr)
        c++
    }
    i = 16 * sizeof(ptr) * 2
    while i <= 4096 {
        let pool = Pool.init(i)
        @ptrv(pools_bump.data, Pool, c) = pool
        i *= 2
        c++
    }

    poolc = c
    pools = pools_bump.data
}

fn reset_pools() {
    let i : uint = 0
    let last = poolc
    while i < last {
        let pool = @ptrv(pools, Pool, i++)
        pool.reset()
    }
}

struct Pool {
    blockc: uint
    first: ptr
    block: ptr
    index: uint (0)
    isize: uint (0)

    + static fn init(size: uint) Pool {

        let p = Pool {
            isize: size + 8
            first: null @as ptr
            block: null @as ptr
            blockc: 1
        }

        return p
    }

    static fn create_block(size: uint, isize: uint) ptr {
        if size > 248 : size = 248
        let b = mem:alloc(size * isize + POOL_DATA_OFFSET)
        // Settings
        @ptrv(b, ?ptr, 0) = null // next block
        @ptrv(b, uint, 1) = size // count
        @ptrv(b, uint, 2) = 0 // used
        @ptrv(b, uint, 3) = 0 // usage percent
        // Set indexes
        let data = b + POOL_DATA_OFFSET
        let i : uint = 0
        while i < size {
            let item : ptr = data + i * isize
            @ptrv(item, u64) = 0
            @ptrv(item, u8, byte_local) = 0
            @ptrv(item, u8, byte_share) = 0
            i++
        }
        return b
    }

    static fn get_from_pool_index(index: uint) ptr {
        let pool = @ptrv(pools, Pool, index)
        return pool.get()
    }

    fn get() ptr {

        let isize = this.isize
        if this.block == null {
            this.block = Pool.create_block(this.blockc * 2, isize)
            this.first = this.block
        }

        while true {
            let block = this.block
            if @ptrv(block, uint, 3) > 90 {
                this.set_next_block(block)
                continue
            }
            let index = this.index
            if index == @ptrv(block, uint, 1) {
                this.set_next_block(block)
                continue
            }
            this.index++
            let data = block + POOL_DATA_OFFSET
            let item = data + index * isize

            if @ptrv(item, u16, byte_local) == local_age {
                continue
            }

            // Increase mem usage
            mem_new += isize

            return (item + 8)
        }
        // println("Failed to allocate memory")
        core:exit(1)
    }

    fn set_next_block(block: ptr) {
        let next = @ptrv(block, ?ptr, 0)
        if isset(next) {
            this.set_block(next)
        } else {
            // Create new block
            let blockc = ++this.blockc
            let new = Pool.create_block(blockc * blockc, this.isize)
            // Set next
            @ptrv(block, ptr, 0) = new
            this.set_block(new)
        }

        // Check mem usage
        update_usage()
    }

    fn set_block(block: ptr) {
        this.block = block
        this.index = 0
    }

    fn reset() {
        let block = this.first
        if block == null : return

        let current = this.block
        let isize = this.isize
        let age = local_age

        let reached_current = false
        let last : ?ptr = null
        let first_empty_block : ?ptr = null
        let last_empty_block : ?ptr = null

        while block != null {
            let b = block
            let total = @ptrv(b, uint, 1)
            let next = @ptrv(b, ptr, 0)
            @ptrv(b, ?ptr, 0) = null // clear next

            // Count used items
            let used : uint = 0

            if reached_current {
                used = @ptrv(b, uint, 2)
            } else {
                let data = b + POOL_DATA_OFFSET
                let i : uint = 0
                while i < total {
                    let item_age = @ptrv(data, u8, i * isize)
                    if item_age == age {
                        used++
                    } else {
                        @ptrv(data, u8, i * isize) = 0
                    }
                    i++
                }
                @ptrv(b, uint, 2) = used
            }

            //
            if used == 0 {
                if reached_current == false {
                    @ptrv(b, uint, 3) = 0
                    if isset(last_empty_block) {
                        @ptrv(last_empty_block, ptr, 0) = b
                        last_empty_block = b
                    } else {
                        first_empty_block = b
                        last_empty_block = b
                    }
                } else {
                    mem:free(b)
                    this.blockc--
                }
            } else {
                // Update usage percent
                @ptrv(b, uint, 3) = used * 100 / total
                //
                if isset(last) : @ptrv(last, ptr, 0) = b
                else : this.first = b
                last = b
            }
            if b == current : reached_current = true
            block = next
        }

        if isset(first_empty_block) {
            if isset(last)  {
                @ptrv(last, ptr, 0) = first_empty_block
            } else {
                this.first = first_empty_block
            }
        } else {
            if isset(last)  {
                @ptrv(last, ?ptr, 0) = null
            }
        }

        this.set_block(this.first)
    }
}
