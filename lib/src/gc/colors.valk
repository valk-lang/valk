
use mem

global colors: ColorBook

type color_type (u16)

value color_state_unused (0)
value color_state_used (1)
value color_state_unlinked (2)

value color_blank (0)
value color_unlink (1)
value color_const (2)
value color_shared_1 (3)
value color_shared_2 (4)
value color_custom (5)

shared share_color : color_type (color_shared_1)

struct ColorBook {
    pool: ptr
    state: ptr
    size: uint
    count: u16 (0)
    next: u16 (5)

    static fn init() {
        colors = ColorBook.new()
    }

    static fn new() ColorBook {
        let size: uint = 256 
        let state = mem:calloc(size + 5)
        @ptrv(state, u8, color_const) = color_state_used
        @ptrv(state, u8, color_shared_1) = color_state_used
        @ptrv(state, u8, color_shared_2) = color_state_used
        return ColorBook {
            pool: mem:alloc(size * sizeof(ptr))
            state: state
            size: size
        }
    }

    fn get() u16 {
        if this.count > 0 {
            let i = this.count - 1
            this.count = i
            let c = @ptrv(this.pool, u16, i)
            @ptrv(this.state, u8, c) = 1
            return c
        }
        let c = this.next++
        // Enable color
        @ptrv(this.state, u8, c) = 1
        // Allocate more colors if needed
        if c == this.size {
            let size = this.size
            let new_size = size * 2
            this.pool = mem:resized_clone_and_free(this.pool, size * sizeof(ptr), new_size * sizeof(ptr))
            this.state = mem:resized_clone_and_free(this.state, size, new_size)
            this.size = new_size
        }
        //
        return c
    }

    fn giveback(color: u16) {
        let i = this.count++
        @ptrv(this.pool, u16, i) = color
    }
}
