
use mem

global colors: ColorBook

type color_type (u32)

value color_state_unused (0)
value color_state_used (1)
value color_state_unlinked (2)

value color_blank (0)
value color_overwrite (1)
value color_const (2)
value color_shared (3)
value color_custom (5)

struct ColorBook {
    pool: ptr
    state: ptr
    size: uint
    count: color_type (0)
    next: color_type (5)

    static fn init() {
        colors = ColorBook.new()
    }

    static fn new() ColorBook {
        let size: uint = 256 
        let state = mem:calloc(size)
        @ptrv(state, u8, color_const) = color_state_used
        @ptrv(state, u8, color_shared) = color_state_used
        return ColorBook {
            pool: mem:alloc(size * sizeof(ptr))
            state: state
            size: size
        }
    }

    fn get() color_type {
        if this.count > 0 {
            let i = --this.count
            let c = @ptrv(this.pool, color_type, i)
            return c
        }
        let c = this.next++
        // Allocate more colors if needed
        if c == this.size {
            let size = this.size
            let new_size = size * 2
            this.pool = mem:resized_clone_and_free(this.pool, size * sizeof(ptr), new_size * sizeof(ptr))
            this.state = mem:resized_clone_and_free(this.state, size, new_size)
            this.size = new_size
        }
        //
        return c
    }

    fn giveback(color: color_type) {
        let i = this.count++
        @ptrv(this.pool, color_type, i) = color
    }
}
