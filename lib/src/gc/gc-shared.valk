
@ignore_access

use core

// Core
@shared lock: core:MutexStruct[void] (@undefined)
@shared gc_list: Array[Gc] (@undefined)
// Marks
@shared mark: u8 (2)
@shared mark_check: u8 (2)
// Shared - Counters
shared mem_shared: uint
shared mem_shared_trigger: uint

global running : bool (false)

fn collect_shared() {

    if gc.dont_stop : return
    if running {
        // print(".")
        return
        // println("Recursion shared gc")
        // core:raise(11)
    }

    gc.unlock()
    lock.lock()

    if !shared_trigger_reached {
        lock.unlock()
        gc.lock()
        return
    }

    if mark++ > 200 : mark = 2

    let mygc = gc
    running = true
    let gcs = gc_list

    each gcs as gcx {
        gcx.lock()
        if gcx.dont_stop : panic("GC stopped while calling share")
    }
    let msb = mem_shared / 1024

    // Collect will make sure all co_count are up-to-date
    // And update the marks of shared items on the stack
    each gcs as gcx {
        gc = gcx
        gcx.mark_shared = true
        gcx.collect()
    }
    //
    each gcs as gcx {
        gc = gcx
        gcx.test()
    }
    // We remove all items that have the wrong mark or co_count == 0 & !owned
    each gcs as gcx {
        gc = gcx
        gcx.clear_shared()
    }
    // Reset pools last
    each gcs as gcx {
        gc = gcx
        reset_pools(gcx.pools, gcx.poolc_ptr[0])
    }
    gc = mygc
    running = false

    let msa = mem_shared / 1024
    let tb = mem_shared_trigger / 1024
    update_shared_trigger()
    println("mark: #{mark} | msb: #{msb} | msa: #{msa} | freed: #{msb-msa} | tb: #{tb} | ta: #{mem_shared_trigger / 1024}")

    each gcs as gcx {
        gcx.unlock()
    }

    lock.unlock()
    gc.lock()
}

fn update_shared_trigger() {
    let high = mem_shared / 100 * 120 + mem_minimum_trigger
    let low = mem_shared_trigger / 100 * 90
    if low > high : high = low
    mem_shared_trigger = high
}
