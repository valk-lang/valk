
use thread
use core

@shared shared_gc: GcShared (GcShared.init())
@shared shared_mark: u8 (2)

class GcShared {
    lock: core:Mutex[void] (core:Mutex[void].new())
    local_gcs: Array[GcLocal] (Array[GcLocal].new())

    + static fn init() GcShared {
        let gc = GcShared {
        }
        gc.start_loop()
        return gc
    }

    fn add_gc(gc: GcLocal) {
        this.lock.lock()
        this.local_gcs.push(gc)
        this.lock.unlock()
    }
    fn remove_gc(gc: GcLocal) {
        this.lock.lock()
        this.local_gcs.remove_value(gc)
        this.lock.unlock()
    }

    + fn start_loop() {
        thread:Thread.start(GcShared.loop)
    }

    static fn loop() {
        let this = shared_gc
        this.update_age()

        while true {
            if !this.all_updated() {
                core:sleep_ms(500)
                continue;
            }

            this.clean_items()
            this.update_age()
            core:sleep_ms(500)
        }
    }

    fn all_updated() bool {
        this.lock.lock()
        each this.local_gcs => gc {
            if gc.update_shared {
                this.lock.unlock()
                return false
            }
        }
        this.lock.unlock()
        return true
    }

    fn clean_items() {
        this.lock.lock()
        each this.local_gcs => gc {

        }
        this.lock.unlock()
    }

    fn update_age() {
        if shared_mark == 2 {
            shared_mark = 4
        } else {
            shared_mark = 2
        }
        this.lock.lock()
        each this.local_gcs => gc {
            gc.update_shared = true
        }
        this.lock.unlock()
    }
}
