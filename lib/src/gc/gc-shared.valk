
@ignore_access

use thread
use core
use gc

~ @shared shared_gc: GcShared (GcShared.init())
@shared shared_mark: u8 (2)

value shared_state_idle (0)
value shared_state_mark (1)
value shared_state_clear (2)

class GcShared {
    lock: core:Mutex[void] (core:Mutex[void].new())
    local_gcs: Array[GcLocal] (Array[GcLocal].new())
    disable: bool (false)

    + static fn init() GcShared {
        let gc = GcShared {
        }
        return gc
    }

    fn add_gc(gc: GcLocal) {
        this.lock.lock()
        this.local_gcs.push(gc)
        this.lock.unlock()
    }
    fn remove_gc(gc: GcLocal) {
        this.lock.lock()
        this.local_gcs.remove_value(gc)
        this.lock.unlock()
    }

    + fn start_loop() {
        thread:Thread.start(GcShared.loop)
    }

    static fn loop() {

        // let this = shared_gc
        // this.update_age()
        // let state : u8 = shared_state_mark
        // core:sleep_ms(1000)

        // while true {
        //     if this.disable {
        //         core:sleep_ms(200)
        //         continue
        //     }

        //     run_if_threshold_reached()

        //     if !this.all_updated() {
        //         core:sleep_ms(200)
        //         continue;
        //     }

        //     if state == shared_state_mark {
        //         state = shared_state_clear
        //         this.set_state(state)
        //     } else {
        //         state = shared_state_mark
        //         this.update_age()
        //         this.mark_shared_globals()
        //         this.set_state(state)
        //     }

        //     core:sleep_ms(500)
        // }
    }

    fn mark_shared_globals() {
        #loop globals G T
        #if global_is_shared(G)
        #if is_gc_type(T)
        {
            let g = G
            if g.@cast(?ptr) != null {
                share(g)
            }
        }
        #end
        #end
        #end
    }

    fn all_updated() bool {
        this.lock.lock()
        each this.local_gcs as gc {
            if gc.shared_update {
                this.lock.unlock()
                return false
            }
        }
        this.lock.unlock()
        return true
    }

    fn set_state(state: u8) {
        this.lock.lock()
        each this.local_gcs as gc {
            if gc.shared_state == shared_state_idle && state == shared_state_clear : continue
            gc.shared_state = state
            gc.shared_update = true
        }
        this.lock.unlock()
    }

    fn update_age() {
        if shared_mark == 2 {
            shared_mark = 4
        } else {
            shared_mark = 2
        }
    }
}


fn run_shared_gc() {

    let sgc = shared_gc
    let lgcs = sgc.local_gcs

    mem_shared_lock.lock()
    mem_shared_running = true

    // Prevent double run
    if mem_shared < mem_shared_trigger {
        mem_shared_running = false
        mem_shared_lock.unlock()
        return
    }
    // print("RS.")

    // Change mark
    // shared_mark = shared_mark == 2 ? 4 : 2
    shared_mark++
    // let before = mem_shared

    //
    sgc.mark_shared_globals()

    // Run local gc (no lock)
    local_gc.shared_update = true
    local_gc.shared_state = shared_state_mark
    local_gc.run()

    // Run all other gc's (locked)
    each lgcs as gc {
        if gc == local_gc : continue
        gc.mutex.lock()
        // gc.shared_state = shared_state_mark
        // gc.shared_update = true
        // gc.run()
        gc.mutex.unlock()
    }

    // Clearing
    local_gc.shared_update = true
    local_gc.shared_state = shared_state_clear
    local_gc.run()

    each lgcs as gc {
        if gc == local_gc : continue
        // gc.shared_update = true
        // gc.shared_state = shared_state_clear
        // gc.run()
    }

    // Update trigger point
    let high = mem_shared / 100 * 130 + mem_minimum_trigger
    let high2 = mem_shared_trigger / 100 * 90
    if high2 > high : high = high2
    mem_shared_trigger = high

    // let a : int = mem_shared.to(int) - before.to(int)
    // println("diff: " + a + " (s: " + mem_shared + " | b: " + before + ")")
    // println(mem_marked)

    // Unlock
    mem_shared_running = false
    mem_shared_lock.unlock()
}
