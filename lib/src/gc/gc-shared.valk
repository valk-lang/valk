
@ignore_access

use thread
use core
use gc

~ @shared shared_gc: GcShared (GcShared.init())
@shared shared_mark: u8 (2)

shared mem_shared : uint
shared mem_shared_running : bool (false)
@shared mem_shared_runner_gc : ?GcLocal (null)
shared mem_shared_trigger : uint (256 * 1024)
shared mem_shared_lock : core:Mutex[void] (core:Mutex[void].new())

value shared_state_idle (0)
value shared_state_mark (1)
value shared_state_clear (2)

class GcShared {
    lock: core:Mutex[void] (core:Mutex[void].new())
    local_gcs: Array[GcLocal] (Array[GcLocal].new())
    disable: bool (false)

    + static fn init() GcShared {
        let gc = GcShared {
        }
        return gc
    }

    fn add_gc(gc: GcLocal) {
        mem_shared_lock.lock()
        this.local_gcs.push(gc)
        mem_shared_lock.unlock()
    }
    fn remove_gc(gc: GcLocal) {
        mem_shared_lock.lock()
        this.local_gcs.remove_value(gc)
        mem_shared_lock.unlock()
    }

    + fn start_loop() {
        thread:Thread.start(GcShared.loop)
    }

    static fn loop() {
        // TODO: Run shared gc every x seconds (optional)
    }

    fn mark_shared_globals() {
        #loop globals G T
        #if global_is_shared(G)
        #if is_gc_type(T)
        {
            let g = G
            if g.@cast(?ptr) != null {
                share(g)
            }
        }
        #end
        #end
        #end
    }

}

fn wait_for_shared_gc() {
    if mem_shared_runner_gc != local_gc {
        local_gc.mutex.unlock()
        mem_shared_lock.lock()
        mem_shared_lock.unlock()
        local_gc.mutex.lock()
    }
}

fn run_shared_gc() {

    let lgc = local_gc
    let sgc = shared_gc
    let lgcs = sgc.local_gcs
    let before_trigger = mem_shared_trigger

    lgc.mutex.unlock()
    mem_shared_lock.lock()

    // Prevent double run
    if mem_shared_trigger != before_trigger {
        lgc.mutex.lock()
        mem_shared_lock.unlock()
        return
    }

    // Run
    mem_shared_running = true
    mem_shared_runner_gc = lgc

    // Change mark
    // shared_mark = shared_mark == 2 ? 4 : 2
    shared_mark++

    each lgcs as gc {
        gc.mutex.lock()
    }

    //
    sgc.mark_shared_globals()

    // Run all gc's
    each lgcs as gc {
        local_gc = gc
        gc.shared_state = shared_state_mark
        gc.shared_update = true
        gc.run()
    }

    each lgcs as gc {
        local_gc = gc
        gc.shared_state = shared_state_clear
        gc.shared_update = true
        gc.run()
        gc.mutex.unlock()
    }

    // Update trigger point
    let high = mem_shared / 100 * 130 + mem_minimum_trigger
    let high2 = mem_shared_trigger / 100 * 90
    if high2 > high : high = high2
    mem_shared_trigger = high

    // Unlock
    local_gc = lgc
    mem_shared_runner_gc = null
    mem_shared_running = false
    lgc.mutex.lock()
    mem_shared_lock.unlock()
}
