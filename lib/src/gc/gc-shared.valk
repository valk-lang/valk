
use thread
use core

shared shared_gc: GcShared (@undefined)
shared shared_mark: u8 (@undefined)

class GcShared {
    lock: core:Mutex[void] (core:Mutex[void].new())
    local_gcs: Array[GcLocal] (Array[GcLocal].new())

    + static fn init() GcShared {
        let gc = GcShared {
        }

        shared_gc = gc
        shared_mark = 2
        return gc
    }

    fn add_gc(gc: GcLocal) {
        this.lock.lock()
        this.local_gcs.push(gc)
        this.lock.unlock()
    }
    fn remove_gc(gc: GcLocal) {
        this.lock.lock()
        this.local_gcs.remove_value(gc)
        this.lock.unlock()
    }

    + fn start_loop() {
        thread:Thread.start(GcShared.loop)
    }

    static fn loop() {
        let this = shared_gc
        while true {
            if shared_mark == 2 {
                shared_mark = 4
            } else {
                shared_mark = 2
            }
            this.lock.lock()
            each this.local_gcs => gc {
                gc.update_shared = true
            }
            this.lock.unlock()
            core:sleep_ms(1000)
        }
    }
}

// fn update_age[T](item: ptr, age: u8) {

//     let b = @ptrv(vtable, ptr, 2)
//     let item_ptr = item @as ptr
//     let item_age = @ptrv(item_ptr, u8, byte_shared_age_rel)
//     if item_age == age : return

//     @ptrv(item_ptr, u8, byte_shared_age_rel) = age

//     #loop properties item, T as prop, type
//     #if @is_gc_type(type)
//     {
//         // let p = prop
//         #if @is_nullable_type(type)
//         let p = prop @as ?ptr
//         if isset(p) {
//         #else
//         let p = prop @as ptr
//         #end
//             update_age[type](p, age)
//         #if @is_nullable_type(type)
//         }
//         #end
//     }
//     #end
//     #end

//     // Call _gc_mark hook
//     #if @type_has_method(T, _gc_update_age)
//     (item @as T)._gc_update_age(age)
//     #end
// }

// fn share_object(item: ptr) {
//     let vti = @ptrv(item, u16, -1)
//     if vti > 0 {
//         let share = @ptrv(vtable, fn(ptr)(), vti @as uint * VTABLE_COLS + VTABLE_COL_SHARE)
//         share(item)
//     }
// }

// fn share[T](item: ptr) {

//     let b = @ptrv(vtable, ptr, 2)
//     let item_ptr = item @as ptr
//     let item_color = @ptrv(item_ptr, u16, byte_color_rel)
//     if item_color == color_shared : return

//     @ptrv(item_ptr, u16, byte_color_rel) = color_shared
//     @ptrv(item_ptr, u8, byte_shared_age_rel) = share_age

//     if item_color == color_blank {
//         let size : uint = sizeof(<T>) + 8
//         let block_index = @ptrv(item_ptr, u8, byte_block_index_rel)
//         let block_start = item_ptr - 8 - block_index * size
//         @ptrv(block_start, uint, -2)++ // Increase used items count
//     }

//     let added = false
//     #loop properties item, T as prop, type
//     #if @is_gc_type(type)
//     {
//         // let p = prop
//         #if @is_nullable_type(type)
//         let p = prop @as ?ptr
//         if isset(p) {
//         #else
//         let p = prop @as ptr
//         #end
//             share[type](p)
//         #if @is_nullable_type(type)
//         }
//         #end
//     }
//     #end
//     #end

//     // Call _gc_mark hook
//     #if @type_has_method(T, _gc_share)
//     (item @as T)._gc_share()
//     #end
// }
