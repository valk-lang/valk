
@ignore_access

use core

// Core
@shared lock: core:Mutex[void] (@undefined)
@shared gc_list: Array[Gc] (@undefined)
global disable_shared : bool (@undefined)
// Marks
@shared mark: u8 (2)
@shared shared_id: u16
@shared shared_id_last: u16
@shared shared_run_count: uint
@shared shared_run_total: uint
// Shared - Counters
shared mem_shared: uint (0)
shared mem_shared_trigger: uint (mem_minimum_trigger)
// Shared - Lists
@shared shared_items: Bump (@undefined)


fn collect_shared() {
    if disable_shared : return
    if shared_id != shared_id_last {
        if shared_trigger_reached {
            lock.lock()
            if shared_trigger_reached : update_shared_trigger()
            lock.unlock()
        }
        return
    }
    let id = atomic_op(shared_id + 1)
    if id != shared_id_last : return
    //
    lock.lock()

    if mark++ > 200 : mark = 2

    let gcs = gc_list

    shared_run_count = 0
    shared_run_total = gcs.length

    each gcs as gc {
        gc.check_shared_ptr[0] = true
    }

    if shared_trigger_reached : update_shared_trigger()

    lock.unlock()
}

fn update_shared_trigger() {
    let high = mem_shared / 100 * 120 + mem_minimum_trigger
    let low = mem_shared_trigger / 100 * 90
    if low > high : high = low
    mem_shared_trigger = high
}

fn clean_shared() {

    lock.lock()

    // TODO - loop list & check if owned or co-owned
    // if so, update age recursive

    // Loop list again and free if mark doesnt match age

    shared_id_last = shared_id
    lock.unlock()
}
