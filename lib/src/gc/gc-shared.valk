
shared share_age: u8 (1)

struct GcShared {
    pub static fn init() GcShared {
        return GcShared {
        }
    }
}

fn update_age[T](item: ptr, age: u8) {

    let b = @ptrv(vtable, ptr, 2)
    let item_ptr = item @as ptr
    let item_age = @ptrv(item_ptr, u8, byte_shared_age_rel)
    if item_age == age : return

    @ptrv(item_ptr, u8, byte_shared_age_rel) = age

    #loop properties item, T as prop, type
    #if @is_gc_type(type)
    {
        // let p = prop
        #if @is_nullable_type(type)
        let p = prop @as ?ptr
        if isset(p) {
        #else
        let p = prop @as ptr
        #end
            update_age[type](p, age)
        #if @is_nullable_type(type)
        }
        #end
    }
    #end
    #end

    // Call _gc_mark hook
    #if @type_has_method(T, _gc_update_age)
    (item @as T)._gc_update_age(age)
    #end
}

fn share[T](item: ptr, color: u16) {

    let b = @ptrv(vtable, ptr, 2)
    let item_ptr = item @as ptr
    let item_color = @ptrv(item_ptr, u16, byte_color_rel)
    if item_color == color : return

    @ptrv(item_ptr, u16, byte_color_rel) = color

    if item_color == color_blank {
        let size : uint = sizeof(<T>) + 8
        let block_index = @ptrv(item_ptr, u8, byte_block_index_rel)
        let block_start = item_ptr - 8 - block_index * size
        @ptrv(block_start, uint, -2)++ // Increase used items count
    }

    let added = false
    #loop properties item, T as prop, type
    #if @is_gc_type(type)
    {
        // let p = prop
        #if @is_nullable_type(type)
        let p = prop @as ?ptr
        if isset(p) {
        #else
        let p = prop @as ptr
        #end
            share[type](p, color)
        #if @is_nullable_type(type)
        }
        #end
    }
    #end
    #end

    // Call _gc_mark hook
    #if @type_has_method(T, _gc_share)
    (item @as T)._gc_share(color)
    #end
}
