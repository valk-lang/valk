
use coro
use core
use mem

value mem_minimum_trigger (256 * 1024)

// Lists
@shared stack_items: Bump (Bump.new())
@shared dis_owned_list: Bump (Bump.new())
@shared re_own_list: Bump (Bump.new())
@shared mark_list: Lifo (Lifo.new())
// Counters
shared mem_marked: uint (0)
shared mem_trigger: uint (mem_minimum_trigger)
shared mem_suggestion: uint (mem_minimum_trigger)
shared mem_new: uint (0)

fn wait_for_gc() {
    if runner_thread != thread {
        thread.unlock()
        lock.lock()
        lock.unlock()
        thread.lock()
    }
}

struct Gc {
    //
    disable: bool (true)
    did_shutdown: bool (false)

    + static fn init() Gc {
        return Gc {}
    }

    fn collect() {

        if running : wait_for_gc()
        if this.disable : return

        let before = mem_minimum_trigger
        thread.unlock()
        lock.lock()
        if mem_minimum_trigger != before {
            lock.unlock()
            thread.lock()
            return
        }
        running = true
        runner_thread = thread
        this.disable = true

        // Lock all threads
        each threads as t {
            // print("WANT: #{ t.mutex.@cast(ptr) }\n")
            t.lock()
        }

        // 
        this.loop_stack_items(Gc.mark_on_stack)

        // Check if items have dissapeared from the stack
        this.loop_previous_stack_items()

        // Mark stack items
        this.loop_stack_items(Gc.mark_stack_item)

        // 3 phases to dis-own
        this.loop_dis_own()
        this.loop_re_own()
        // this.dis_own_remove_co_owners()
        // this.dis_own_check_co_owners()
        // this.dis_own_still_co_owned()

        // Reconnect to disconnected items
        this.loop_updates()

        this.check_blanks()

        // Reset pools
        each threads as t {
            reset_pools(t.pools, t.poolc_ptr[0])
        }

        // Reset mem_new
        mem_new = mem_marked

        // Update trigger point
        let high = mem_marked / 100 * 120 + mem_minimum_trigger
        let high_sug = mem_marked / 100 * 110 + mem_minimum_trigger
        let high2 = mem_trigger / 100 * 90
        if high2 > high : high = high2
        if high2 > high_sug : high_sug = high2
        mem_trigger = high
        mem_suggestion = high_sug

        // Release all locks
        each threads as t {
            t.unlock()
        }

        //
        this.disable = false
        running = false
        runner_thread = null
        thread.lock()
        lock.unlock()
    }

    static fn mark_on_stack(item: GcItem) {
        item.data().set_on_stack()
    }

    static fn mark_stack_item(item: ptr) {
        let data = (@offset(item, u8, -8)).@cast(GcData)
        if data.state < state_used {
            mark_used(item)
            stack_items.add_ptr(item)
        }
        data.remove_on_stack()
    }

    fn loop_previous_stack_items() {

        let discs = dis_owned_list
        let list = stack_items
        let data = list.data
        let adr = data
        let end = adr + list.index
        list.reset()

        while adr < end {
            let item = @ptrv(adr, ptr)
            let data = (@offset(item, u8, -8)).@cast(GcData)
            adr += size_of(ptr)

            if data.is_on_stack() {
                let adr = list.get(size_of(ptr))
                @ptrv(adr, ptr) = item
            } else {
                let adr = discs.get(size_of(ptr))
                @ptrv(adr, ptr) = item

                data.state--
            }
        }
    }

    // fn dis_own_remove_co_owners() {

    //     let list = dis_owned_list
    //     let data = list.data
    //     let adr = data
    //     let end = adr + list.index
    //     list.reset()

    //     while adr < end {
    //         let item = @ptrv(adr, ptr)
    //         let data = (@offset(item, u8, -8)).@cast(GcData)
    //         adr += size_of(ptr)

    //         if data.state == state_unused {
    //             // Re-add to list
    //             let adr = list.get(size_of(ptr))
    //             @ptrv(adr, ptr) = item
    //             //
    //             // disconnect_rec(item)
    //             remove_co_owners(item)
    //         }
    //     }
    // }
    // fn dis_own_check_co_owners() {

    //     let list = dis_owned_list
    //     let data = list.data
    //     let adr = data
    //     let end = adr + list.index
    //     list.reset()

    //     while adr < end {
    //         let item = @ptrv(adr, GcItem)
    //         adr += size_of(ptr)

    //         check_co_owners(item)
    //     }
    // }
    // fn dis_own_still_co_owned() {

    //     let list = still_co_owned
    //     let data = list.data
    //     let adr = data
    //     let end = adr + list.index
    //     list.reset()

    //     while adr < end {
    //         let item = @ptrv(adr, ptr)
    //         adr += size_of(ptr)

    //         retake_co_ownership(item)
    //     }
    // }

    fn loop_dis_own() {

        let list = dis_owned_list
        let data = list.data
        let adr = data
        let end = adr + list.index
        list.reset()

        while adr < end {
            let item = @ptrv(adr, ptr)
            let data = (@offset(item, u8, -8)).@cast(GcData)
            adr += size_of(ptr)

            if data.state == state_unused {
                dis_own_rec(item)
            }
        }
    }

    fn loop_re_own() {

        let list = re_own_list
        let data = list.data
        let adr = data
        let end = adr + list.index
        list.reset()

        while adr < end {
            let item = @ptrv(adr, ptr)
            let data = (@offset(item, u8, -8)).@cast(GcData)
            adr += size_of(ptr)

            if data.state == state_new && data.co_count > 0 {
                mark_used(item)
                data.set_still_co_owned()
            }
        }
    }

    fn loop_updates() {

        each threads as t {
            let list = t.updated_list
            let data = list.data
            let adr = data
            let end = adr + list.index
            list.reset()

            let ml = mark_list

            while adr < end {
                let item = @ptrv(adr, GcItem)
                adr += size_of(ptr)

                let data = item.data()
                data.remove_in_updates()

                if data.state == state_used {
                    ml.add(item)
                }
            }
        }

        mark_used(null)
    }

    fn check_blanks() {

        each threads as t {
            let list = t.blanks
            let data = list.data
            let adr = data
            let end = adr + list.index
            list.reset()

            while adr < end {
                let item = @ptrv(adr, GcItem)
                adr += size_of(ptr)

                let data = item.data()
                data.remove_in_blanks()
                if data.state != state_new : continue

                free_blank(item)
            }
        }
    }

    //////////////////////////
    // Loop stack
    //////////////////////////

    fn loop_stack_items(func: fnRef(ptr)()) {

        each threads as t {
            // Globals
            let g_adr = t.globals.data
            let g_end_adr = g_adr + t.globals.index
            while g_adr < g_end_adr {
                let ref = @ptrv(g_adr, ptr)
                let item = @ptrv(ref, ?ptr)
                if isset(item) {
                    func(item)
                }
                g_adr += size_of(ptr)
            }

            // Stack
            let adr = t.stack_root
            let top = t.stack_top_ptr[0]
            while adr < top {
                let item = @ptrv(adr, ?ptr)
                if isset(item) {
                    func(item)
                }
                adr += size_of(ptr)
            }

            // Backup
            adr = t.stack_backup
            let size = t.stack_backup_size_ptr[0]
            top = adr + size
            while adr < top {
                let item = @ptrv(adr, ?ptr)
                if isset(item) {
                    func(item)
                }
                adr += size_of(ptr)
            }

            let coros = @ptrv(t.coros_ptr, Array[?coro:Coro])
            each coros as coro {
                if isset(coro) {
                    let adr = coro.stack
                    if isset(adr) {
                        let top = adr + coro.stack_size
                        while adr < top {
                            let item = @ptrv(adr, ?ptr)
                            if isset(item) {
                                func(item)
                            }
                            adr += size_of(ptr)
                        }
                    }
                }
            }
        }
    }

    //////////////////////////
    // Shutdown
    //////////////////////////

    // + fn shutdown() {
    //     this.did_shutdown = true
    //     this.collect()
    //     this.mutex.unlock()
    //     remove_gc(this)

    //     // Free blocks or store them in unused-block-list if they still contain items
    //     shutdown_lock.lock()
    //     loop_all_blocks(fn(block: Block)() {
    //         if block.used == 0 {
    //             mem:free(block)
    //         } else {
    //             add_unused_block(block)
    //         }
    //     })
    //     shutdown_lock.unlock()

    //     dump_shared(this.shared_items)

    //     //
    //     this.mutex.free()
    //     this.stack_items.free()
    //     this.mark_list.free()
    //     mem:free(this)

    //     // Free pools
    //     pools_free()
    // }
}
