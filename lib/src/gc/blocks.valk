
use mem
use core

@shared unused_blocks: [ptr x 128]
shared pool_lock : core:SyncMutex (core:SyncMutex.new())

value b_next (0)
value b_slots_total (1)
value b_slots_used_percent (2)
value b_isize (3)
value b_slots_used (4)
value b_props (5)
value b_onfree (6)

struct Block {
    next: ?ptr
    slots_total: uint
    slots_used_percent: uint
    // Mini
    isize: uint
    slots_used: uint
    props: ?fnptr(ptr, Lifo)()
    onfree: ?fnptr(ptr)()
}

struct BlockMini {
    isize: uint
    slots_used: uint
    props: ?fnptr(ptr, Lifo)()
    onfree: ?fnptr(ptr)()
}

fn loop_all_blocks(func: fnptr(Block)()) {
    // let i : uint = 0
    // let last = poolc
    // while i < last {
    //     let pool = @ptrv(pools, Pool, i++)
    //     let block : ?Block = pool.first.@cast(?Block)
    //     while isset(block) {
    //         let next = block.next.@cast(?Block)
    //         func(block)
    //         block = next
    //     }
    // }
    let adr = alc_list.data
    let end = adr + alc_list.index
    while adr < end {
        let alc = @ptrv(adr, Pool)
        adr += size_of(ptr)
        let block : ?Block = alc.first.@cast(?Block)
        while isset(block) {
            let next = block.next.@cast(?Block)
            func(block)
            block = next
        }
    }
}

fn add_unused_block(block: Block) {
    block.next = null
    let index = get_pool_index_for_size(block.isize)
    let list = @ptrv(unused_blocks, ?Bump, index)
    if !isset(list) {
        list = Bump.new(32)
        @ptrv(unused_blocks, ?Bump, index) = list
    }
    list.add_ptr(block)
}

fn get_unused_block(isize: uint) ptr !none {
    let index = get_pool_index_for_size(isize)
    let list = @ptrv(unused_blocks, ?Bump, index)
    if !isset(list) : throw none
    if list.index == 0 : throw none
    pool_lock.lock()
    if list.index == 0 {
        pool_lock.unlock()
        throw none
    }
    list.index -= size_of(ptr)
    let block = @ptrv(list.data, Block, list.index / size_of(ptr))
    pool_lock.unlock()
    return block.@cast(ptr)
}

fn free_empty_unused_blocks() {
    pool_lock.lock()
    let i : uint = 0
    while i < 128 {
        let list = @ptrv(unused_blocks, ?Bump, i++)
        if !isset(list) : continue
        let start = list.data
        let end = list.data.$offset(list.index)
        list.reset()
        while start < end {
            let block = @ptrv(start, Block)
            if block.slots_used == 0 {
                mem:free(block)
            } else {
                list.add_ptr(block)
            }
            start = start.$offset(size_of(ptr))
        }
    }
    pool_lock.unlock()
}
