
use coro

global local_gc : GcLocal (@undefined)

global stack_main : Stack (@undefined)
global stack_active : Stack (@undefined)

global stack_items_old : Bump (@undefined)
global stack_items_new : Bump (@undefined)

global mem_new : uint
global mem_trigger : uint
global mem_suggestion : uint
global mem_marked : uint

value mem_minimum_trigger (8192)

fn update_usage() {
    // Calculate mem usage
    if mem_new > mem_trigger : gc()
}

+ fn gc() {
    local_gc.gc()
}

+ fn gc_suggestion() {
    if mem_new > mem_suggestion {
        local_gc.gc()
    }
}

struct GcLocal {
    globals: Bump (Bump.new())
    update_shared: bool (true)

    + static fn init() GcLocal {

        stack_main = Stack.new()
        stack_active = stack_main

        ColorBook.init()
        pools_init()

        stack_items_old = Bump.new()
        stack_items_new = Bump.new()

        mem_trigger = mem_minimum_trigger
        mem_suggestion = mem_minimum_trigger

        let gcl = GcLocal {
        }
        local_gc = gcl

        // TODO: Add gc to gc list for the shared gc

        return gcl
    }

    fn add_global(ref: ptr) {
        let adr = this.globals.get(sizeof(ptr))
        @ptrv(adr, ptr) = ref
    }

    fn gc() {
        // this.lock.lock()
        print("-")

        let si_new = stack_items_new
        stack_items_new = stack_items_old
        stack_items_old = si_new
        stack_items_new.reset()

        this.mark_on_stack(1)
        this.disable_previous_colors()

        mem_marked = mem_minimum_trigger
        this.mark_stacks()

        this.mark_on_stack(0)
        reset_pools()

        mem_trigger = mem_new / 10 * 12

        // let max = mem_trigger / 100 * 90 // reduce 10%
        // let current_usage = mem_marked + mem_minimum_trigger
        // let max_marked = current_usage / 100 * 130 // increase 30%
        // if max_marked > max : max = max_marked
        // mem_trigger = max
        // mem_suggestion = current_usage / 10 * 11
        // mem_new = mem_marked

        if this.update_shared {
            // this.mark_shared()
            this.update_shared = false
        }

        // Mark shared
        // if shared_age != this.shared_age {
        //     let age = shared_age
        //     this.mark_stack_shared_age(age)
        //     this.shared_age = age
        // }

        // this.lock.unlock()
        // print(".")
    }

    fn mark_on_stack(val: u8) {

        // Globals
        let g_adr = this.globals.data
        let g_end_adr = g_adr + this.globals.index
        while g_adr < g_end_adr {
            let ref = @ptrv(g_adr, ptr)
            let item = @ptrv(ref, ptr)
            if item != null {
                @ptrv(item, u8, byte_on_stack_rel) = val
            }
            g_adr += sizeof(ptr)
        }

        // Stack
        let stack = stack_main
        let adr = stack.base
        let top = stack.adr
        while adr < top {
            let item = @ptrv(adr, ptr, 0)
            if item != null {
                @ptrv(item, u8, byte_on_stack_rel) = val
            }
            adr += sizeof(ptr)
        }

        each coro:g_coros => coro {
            if isset(coro) {
                let adr = coro.stack.base
                let top = coro.stack.adr
                while adr < top {
                    let item = @ptrv(adr, ptr)
                    if item != null {
                        @ptrv(item, u8, byte_on_stack_rel) = val
                    }
                    adr += sizeof(ptr)
                }
            }
        }
    }

    fn disable_previous_colors() {
        let si_old = stack_items_old
        let state = colors.state

        let data = si_old.data
        let data_end = data + si_old.index

        while data < data_end {
            let item = @ptrv(data, ptr)
            let color = @ptrv(data, ptr, 1) @as color_type

            if @ptrv(item, u8, byte_on_stack_rel) == 0 {
                @ptrv(state, u8, color) = color_state_unused
            }

            data += sizeof(ptr) * 2
        }
    }

    fn mark_stacks() {

        // Globals
        let g_adr = this.globals.data
        let g_end_adr = g_adr + this.globals.index
        while g_adr < g_end_adr {
            let ref = @ptrv(g_adr, ptr)
            let item = @ptrv(ref, ptr)
            if item != null {
                this.mark_item(item)
            }
            g_adr += sizeof(ptr)
        }

        // Stack
        let stack = stack_main
        let adr = stack.base
        let top = stack.adr
        while adr < top {
            let item = @ptrv(adr, ptr, 0)
            if item != null {
                this.mark_item(item)
            }
            adr += sizeof(ptr)
        }

        each coro:g_coros => coro {
            if isset(coro) {
                let adr = coro.stack.base
                let top = coro.stack.adr
                while adr < top {
                    let item = @ptrv(adr, ptr)
                    if item != null {
                        this.mark_item(item)
                    }
                    adr += sizeof(ptr)
                }
            }
        }
    }

    fn mark_item(item: ptr) {
        let item_color = @ptrv(item, color_type, byte_color_rel)
        if @ptrv(colors.state, u8, item_color) == color_state_used : return
        let color = colors.get()
        let adr = stack_items_new.get(sizeof(ptr) * 2)
        @ptrv(adr, ptr, 0) = item
        @ptrv(adr, ptr, 1) = color
        @ptrv(colors.state, u8, color) = color_state_used
        mark(item, color)
    }

    // fn mark_shared() {
    //     let age = share_age

    //     // Globals
    //     let g_adr = this.globals.data
    //     let g_end_adr = g_adr + this.globals.index
    //     while g_adr < g_end_adr {
    //         let ref = @ptrv(g_adr, ptr)
    //         let item = @ptrv(ref, ptr)
    //         if item != null {
    //             if @ptrv(item, u8, byte_shared_age_rel) != age {
    //                 let vti = @ptrv(item, u16, -1)
    //                 if vti > 0 {
    //                     let update = @ptrv(vtable, fn(ptr, u16)(), vti @as uint * VTABLE_COLS + VTABLE_COL_UPDATE_AGE)
    //                     update(item, age)
    //                 }
    //             }
    //         }
    //         g_adr += sizeof(ptr)
    //     }

    //     // Stack
    //     let stack = stack_main
    //     let adr = stack.base
    //     let top = stack.adr
    //     while adr < top {
    //         let item = @ptrv(adr, ptr, 0)
    //         if item != null {
    //             let vti = @ptrv(item, u16, -1)
    //             if vti > 0 {
    //                 let update = @ptrv(vtable, fn(ptr, u16)(), vti @as uint * VTABLE_COLS + VTABLE_COL_UPDATE_AGE)
    //                 update(item, age)
    //             }
    //         }
    //         adr += sizeof(ptr)
    //     }

    //     each coro:g_coros => coro {
    //         if isset(coro) {
    //             let adr = coro.stack.base
    //             let top = coro.stack.adr
    //             while adr < top {
    //                 let item = @ptrv(adr, ptr)
    //                 if item != null {
    //                     let vti = @ptrv(item, u16, -1)
    //                     if vti > 0 {
    //                         let update = @ptrv(vtable, fn(ptr, u16)(), vti @as uint * VTABLE_COLS + VTABLE_COL_UPDATE_AGE)
    //                         update(item, age)
    //                     }
    //                 }
    //                 adr += sizeof(ptr)
    //             }
    //         }
    //     }
    // }

    + fn shutdown() {
    }
}
