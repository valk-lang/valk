
use coro

global local_gc : GcLocal (@undefined)

global stack_main : Stack (@undefined)
global stack_active : Stack (@undefined)

global stack_items : Bump (@undefined)
global stack_hits : Bump (@undefined)
global reconnect_list : Bump (@undefined)
global reconnect_list_prev : Bump (@undefined)
global disconnect_list : Bump (@undefined)
global blanks : Bump (@undefined)

global mem_new : uint
global mem_trigger : uint
global mem_suggestion : uint
global mem_marked : uint

value mem_minimum_trigger (8192)

value FROZEN (255)

+ fn run_now() {
    local_gc.run()
}

+ fn run_if_threshold_reached() {
    if mem_new > mem_trigger || local_gc.update_shared {
        local_gc.run()
    }
}

+ fn run_suggestion() {
    if mem_new > mem_suggestion || local_gc.update_shared {
        local_gc.run()
    }
}
+ fn shutdown() {
    local_gc.shutdown()
}

fn thread_init() {
    stack_main = Stack.new()
    stack_active = stack_main
    pools_init()
}

struct GcLocal {
    globals: Bump (Bump.new())
    update_shared: bool (false)
    shared_mark_applied: u8 (0)
    disable: bool (false)

    + static fn init() GcLocal {

        stack_items = Bump.new()
        stack_hits = Bump.new()
        reconnect_list = Bump.new()
        reconnect_list_prev = Bump.new()
        disconnect_list = Bump.new()
        blanks = Bump.new()

        mem_new = 0
        mem_trigger = mem_minimum_trigger
        mem_suggestion = mem_minimum_trigger

        let gcl = GcLocal {
        }
        local_gc = gcl

        return gcl
    }

    fn add_global(ref: ptr) {
        let adr = this.globals.get(sizeof(ptr))
        @ptrv(adr, ptr) = ref
    }

    fn push_to_shared() {
        shared_gc.add_gc(this)
    }

    fn run() {

        if this.disable : return
        this.disable = true

        // this.lock.lock()
        // print("-")
        // print("-----------------------------\n")

        let s_mark = shared_mark

        let mem_marked_before = mem_marked
        let bytes_new = mem_new - mem_marked_before


        // 
        this.loop_stack_items(GcLocal.mark_on_stack)

        // Check if items have dissapeared from the stack
        this.loop_previous_stack_items()
        // stack_items.reset()

        // Mark stack items
        this.loop_stack_items(GcLocal.mark_stack_item)

        // Loop disconnects and disconnect sub pipes
        this.loop_disconnects()

        // Swap reconnect lists
        let list = reconnect_list_prev
        reconnect_list_prev = reconnect_list
        reconnect_list = list

        // Reconnect to disconnected items
        this.loop_reconnects()

        // Free items that are disconnected
        this.loop_disconnects_free()

        this.clear_stack_hits()

        this.check_blanks()

        this.loop_stack_items(GcLocal.mark_off_stack)

        // Clear lists
        blanks.reset()
        stack_hits.reset()
        reconnect_list_prev.reset()
        disconnect_list.reset()

        //
        let multiplier : uint = 0
        if mem_marked > mem_marked_before {
            let bytes_kept = mem_marked - mem_marked_before
            multiplier = bytes_kept * 100 / bytes_new
        }

        // Update gc trigger point
        mem_trigger = mem_marked / 100 * (120 + (35 * multiplier / 100)) + mem_minimum_trigger
        mem_suggestion = mem_marked / 100 * 115 + mem_minimum_trigger
        mem_new = mem_marked

        // Reset pools
        if multiplier < 95 : reset_pools()

        // Mark shared
        if this.update_shared && s_mark == shared_mark {
            this.update_shared = false
            this.shared_mark_applied = s_mark
        }

        this.disable = false
        // this.lock.unlock()
        // print(".")
    }

    static fn mark_on_stack(item: ptr) {
        let data = (@ptr_offset(item, -8)) @as GcData
        data.on_stack = 1
    }
    static fn mark_off_stack(item: ptr) {
        let data = (@ptr_offset(item, -8)) @as GcData
        data.on_stack = 0
    }

    static fn mark_stack_item(item: ptr) {
        let data = (@ptr_offset(item, -8)) @as GcData
        if data.used != 1 {
            mark_used(item, true)

            let li = stack_items.get(sizeof(ptr))
            @ptrv(li, ptr) = item
        }
    }

    fn loop_previous_stack_items() {

        let discs = disconnect_list

        let list = stack_items
        let data = list.data
        let adr = data
        let end = adr + list.index
        list.reset()

        while adr < end {
            let item = @ptrv(adr, ptr)
            let data = (@ptr_offset(item, -8)) @as GcData
            adr += sizeof(ptr)

            if data.on_stack == 0 {
                let adr = discs.get(sizeof(ptr))
                @ptrv(adr, ptr) = item

                data.used = 2
            } else {
                let adr = list.get(sizeof(ptr))
                @ptrv(adr, ptr) = item
            }
        }
    }

    fn loop_disconnects() {

        let list = disconnect_list
        let data = list.data
        let adr = data
        let end = adr + list.index

        while adr < end {
            let item = @ptrv(adr, ptr)
            let data = (@ptr_offset(item, -8)) @as GcData
            adr += sizeof(ptr)

            if data.used == 2 {
                // data.used = 1
                disconnect_rec(item)
            }
        }
    }

    fn loop_reconnects() {

        let list = reconnect_list_prev
        let data = list.data
        let adr = data
        let end = adr + list.index

        while adr < end {
            let item = @ptrv(adr, ptr)
            let data = (@ptr_offset(item, -8)) @as GcData
            adr += sizeof(ptr)

            if data.used == 1 {
                mark_properties_used(item, false)
            }
        }
    }

    fn loop_disconnects_free() {

        let list = disconnect_list
        let data = list.data
        let adr = data
        let end = adr + list.index

        while adr < end {
            let item = @ptrv(adr, ptr)
            // let data = (@ptr_offset(item, -8)) @as GcData
            adr += sizeof(ptr)

            // if data.used == 2 {
                free_disconnect_rec(item)
            // }
        }
    }

    fn clear_stack_hits() {

        let list = stack_hits
        let data = list.data
        let adr = data
        let end = adr + list.index

        while adr < end {
            let item = @ptrv(adr, ptr)
            let data = (@ptr_offset(item, -8)) @as GcData
            adr += sizeof(ptr)
            data.on_stack = 0
        }
    }

    fn check_blanks() {

        let list = blanks
        let data = list.data
        let adr = data
        let end = adr + list.index

        while adr < end {
            let item = @ptrv(adr, ptr)
            adr += sizeof(ptr)
            free_blank(item)
        }
    }

    //////////////////////////
    // Loop stack
    //////////////////////////

    fn loop_stack_items(func: fn(ptr)()) {

        // Globals
        let g_adr = this.globals.data
        let g_end_adr = g_adr + this.globals.index
        while g_adr < g_end_adr {
            let ref = @ptrv(g_adr, ptr)
            let item = @ptrv(ref, ?ptr)
            if isset(item) {
                func(item)
            }
            g_adr += sizeof(ptr)
        }

        // Stack
        let stack = stack_main
        let adr = stack.base
        let top = stack.adr
        while adr < top {
            let item = @ptrv(adr, ?ptr)
            if isset(item) {
                func(item)
            }
            adr += sizeof(ptr)
        }

        let coro_data = coro:g_coros.data
        let coro_count = coro:g_coros.length
        while coro_count-- > 0 {
            let coro = @ptrv(coro_data, ?ptr, coro_count)
            if isset(coro) {
                let adr = (coro @as coro:Coro).stack.base
                let top = (coro @as coro:Coro).stack.adr
                while adr < top {
                    let item = @ptrv(adr, ?ptr)
                    if isset(item) {
                        func(item)
                    }
                    adr += sizeof(ptr)
                }
            }
        }
    }

    //////////////////////////
    // Shutdown
    //////////////////////////

    + fn shutdown() {
        this.run()
        // TODO: pass blocks with shared memory to shared gc
    }
}
