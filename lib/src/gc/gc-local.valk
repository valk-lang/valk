
use coro
use core
use mem

value mem_minimum_trigger (8 * 1024)

// Core
global gc : Gc (@undefined)
// Local - Counters
global mem_marked: uint
global mem_trigger: uint
global mem_new: uint

struct Gc {
    mutex: core:MutexStruct[void] (core:MutexStruct[void].new())
    // Lists
    globals: Bump (Bump.new())
    stack_items: Bump (Bump.new())
    updated_list: Bump (Bump.new())
    blanks: Bump (Bump.new())
    dis_owned_list: Bump (Bump.new())
    re_own_list: Bump (Bump.new())
    shared_items: Bump (Bump.new())
    mark_list: Lifo (Lifo.new())
    // Refs
    stack_root: ptr (stack_root)
    stack_top_ptr: ptr[ptr] (@ref(stack_top))
    stack_backup: ptr (stack_backup)
    stack_backup_size_ptr: ptr[uint] (@ref(stack_backup_size))
    coros_ptr: ptr[Array[?coro:Coro]] (@ref(coro:g_coros))
    pools: ptr (pools)
    poolc_ptr: ptr[uint] (@ref(poolc))
    //
    mark_shared: bool (false)
    dont_stop: bool (false)
    disable: bool (true)
    did_shutdown: bool (false)

    + static fn init() Gc {
        mem_marked = mem_minimum_trigger
        return Gc {}
    }

    fn lock() { this.mutex.lock() }
    fn unlock() { this.mutex.unlock() }

    fn collect() {
        if this.dont_stop : panic("Started GC while adding shared memory (bug)")

        if this.disable : return
        this.disable = true

        // 
        if !this.did_shutdown : this.loop_stack_items(Gc.mark_on_stack)

        // Check if items have dissapeared from the stack
        this.loop_previous_stack_items()

        // Mark stack items
        if !this.did_shutdown : this.loop_stack_items(Gc.mark_stack_item)

        //
        this.loop_dis_own()
        if !this.did_shutdown : this.loop_re_own()

        // Reconnect to disconnected items
        if !this.did_shutdown : this.loop_updates()

        this.check_blanks()

        // Reset pools
        if this.mark_shared : this.mark_shared_items()
        else : reset_pools(this.pools, this.poolc_ptr[0])

        // Reset mem_new
        mem_new = mem_marked

        // Update trigger point
        let high = mem_marked / 100 * 120 + mem_minimum_trigger
        let low = mem_trigger / 100 * 90
        if low > high : high = low
        mem_trigger = high

        //
        this.disable = false
    }

    static fn mark_on_stack(item: GcItem) {
        gcdata(item).set_on_stack()
    }

    static fn mark_stack_item(item: ptr) {
        let data = (@offset(item, u8, -8)).@cast(GcData)
        if data.state < state_owned && !data.is_shared() {
            mark_used(item)
            gc.stack_items.add_ptr(item)
        }
        data.remove_on_stack()
    }

    fn loop_previous_stack_items() {

        let discs = this.dis_owned_list
        let list = this.stack_items
        let data = list.data
        let adr = data
        let end = adr + list.index
        list.reset()

        while adr < end {
            let item = @ptrv(adr, ptr)
            let data = (@offset(item, u8, -8)).@cast(GcData)
            adr += size_of(ptr)

            // A stack item can become shared
            if data.is_shared() : continue

            if data.is_on_stack() {
                let adr = list.get(size_of(ptr))
                @ptrv(adr, ptr) = item
            } else {
                let adr = discs.get(size_of(ptr))
                @ptrv(adr, ptr) = item
                data.state = state_no_owner
            }
        }
    }

    fn loop_dis_own() {

        let list = this.dis_owned_list
        let data = list.data
        let adr = data

        while adr < data + list.index {
            let item = @ptrv(adr, ptr)
            let data = (@offset(item, u8, -8)).@cast(GcData)
            adr += size_of(ptr)

            // A dis-owned item can become shared, so we need to make sure it's ignored
            if data.state == state_no_owner && !data.is_shared() {
                dis_own_rec(item)
            }
        }

        list.reset()
    }

    fn loop_re_own() {

        let list = this.re_own_list
        let data = list.data
        let adr = data
        let end = adr + list.index
        list.reset()

        while adr < end {
            let item = @ptrv(adr, ptr)
            let data = (@offset(item, u8, -8)).@cast(GcData)
            adr += size_of(ptr)

            // if data.is_shared() : panic("Shared re-own item")

            if data.state == state_new && data.co_count > 0 {
                mark_used(item)
                data.set_still_co_owned()
            }
        }
    }

    fn loop_updates() {

        let list = this.updated_list
        let data = list.data
        let adr = data
        let end = adr + list.index
        list.reset()

        let ml = this.mark_list

        while adr < end {
            let item = @ptrv(adr, GcItem)
            adr += size_of(ptr)

            let data = gcdata(item)
            data.remove_in_updates()

            if data.state == state_owned && !data.is_shared() {
                ml.add(item)
            }
        }

        mark_used(null)
    }

    fn check_blanks() {

        let list = this.blanks
        let data = list.data
        let adr = data
        let end = adr + list.index
        list.reset()

        while adr < end {
            let item = @ptrv(adr, GcItem)
            adr += size_of(ptr)

            let data = gcdata(item)
            data.remove_in_blanks()
            if data.state != state_new : continue

            free_blank(item)
        }
    }

    //////////////////////////
    // Loop stack
    //////////////////////////

    fn loop_stack_items(func: fnRef(ptr)()) {

        // Globals
        let g_adr = this.globals.data
        let g_end_adr = g_adr + this.globals.index
        while g_adr < g_end_adr {
            let ref = @ptrv(g_adr, ptr)
            let item = @ptrv(ref, ?ptr)
            if isset(item) {
                func(item)
            }
            g_adr += size_of(ptr)
        }

        // Stack
        let adr = this.stack_root
        let top = this.stack_top_ptr[0]
        while adr < top {
            let item = @ptrv(adr, ?ptr)
            if isset(item) {
                func(item)
            }
            adr += size_of(ptr)
        }

        // Backup
        adr = this.stack_backup
        let size = this.stack_backup_size_ptr[0]
        top = adr + size
        while adr < top {
            let item = @ptrv(adr, ?ptr)
            if isset(item) {
                func(item)
            }
            adr += size_of(ptr)
        }

        let coros = this.coros_ptr[0]
        each coros as coro {
            if isset(coro) {
                let adr = coro.stack
                if isset(adr) {
                    let top = adr + coro.stack_size
                    while adr < top {
                        let item = @ptrv(adr, ?ptr)
                        if isset(item) {
                            func(item)
                        }
                        adr += size_of(ptr)
                    }
                }
            }
        }
    }

    //////////////////////////
    // Shared
    //////////////////////////

    fn mark_shared_items() {
        this.mark_shared = false
        // Loop over stack items
        this.loop_stack_items(fn(item: GcItem) {
            let data = gcdata(item)
            // if data.is_shared() : update_mark(item)
            if data.is_shared() : share(item)
        })
    }

    fn update_marks() {
        let list = this.shared_items
        let data = list.data
        let adr = data
        let end = adr + list.index

        while adr < end {
            let item = @ptrv(adr, GcItem)
            adr += size_of(ptr)
            let data = gcdata(item)
            if data.state == state_owned || data.co_count > 0 {
                share(item)
            }
        }
    }

    // fn validate_shared() {
    //     let list = this.shared_items
    //     let data = list.data
    //     let adr = data
    //     let end = adr + list.index

    //     while adr < end {
    //         let item = @ptrv(adr, GcItem)
    //         adr += size_of(ptr)
    //         let data = gcdata(item)

    //         if !data.is_shared() : panic("Shared items contains non-shared")
    //         if data.state == state_new : panic("Shared items contains new_state")
    //     }
    // }

    fn clear_shared() {
        let list = this.shared_items
        let data = list.data
        let adr = data
        let end = adr + list.index
        list.reset()

        while adr < end {
            let item = @ptrv(adr, GcItem)
            adr += size_of(ptr)
            let data = gcdata(item)

            if data.mark == mark {
                list.add_ptr(item)
                continue
            }

            free_shared_item(item)
            // let has_vtable = data.has_vtable()
            // let vt = data.vtable
            // let offset = data.block_offset
            // @ptrv(data, u32) = 0
            // data.mark = 0

            // if offset > 0 {
            //     let block = item - offset
            //     @ptrv(block, uint, 2)--
            //     atomic_op(mem_shared - @ptrv(block, uint, 4))
            // }

            // if has_vtable {
            //     let func = @ptrv(vt, ?fnRef(ptr)(), 1)
            //     if isset(func) : func(item)
            // }
        }
    }

    //////////////////////////
    // Shutdown
    //////////////////////////

    + fn shutdown() {
        this.did_shutdown = true
        this.collect()

        // Free blocks or store them in unused-block-list if they still contain items
        pool_lock.lock()
        loop_all_blocks(fn(block: Block)() {
            if block.used == 0 {
                mem:free(block)
            } else {
                add_unused_block(block)
            }
        })
        pool_lock.unlock()

        lock.lock()
        dump_shared(this.shared_items)
        lock.unlock()

        //
        this.mutex.free()
        //
        this.globals.free()
        this.stack_items.free()
        this.updated_list.free()
        this.blanks.free()
        this.dis_owned_list.free()
        this.re_own_list.free()
        this.shared_items.free()
        this.mark_list.free()
        //
        mem:free(this)
    }
}
