
global local_gc : GcLocal (@undefined)

global stack_main : Stack (@undefined)
global stack_active : Stack (@undefined)

global mem_new : uint
global mem_trigger : uint
global mem_marked : uint

value mem_minimum_trigger (8192)

global prev_stack_items: Bump (@undefined)
global prev_stack_items_alt: Bump (@undefined)
global check_still_used: Bump (@undefined)
global remark_list: Bump (@undefined)
global remark_list_switch: Bump (@undefined)

fn update_usage() {
    // Calculate mem usage
    if mem_new > mem_trigger : gc()
}

pub fn gc() {
    local_gc.gc()
}

struct GcLocal {

    pub static fn init() GcLocal {
        // print("Init local gc\n")

        stack_main = Stack.new()
        stack_active = stack_main

        ColorBook.init()
        vtable_init()
        prev_stack_items = Bump.new()
        prev_stack_items_alt = Bump.new()
        check_still_used = Bump.new()
        remark_list = Bump.new()
        remark_list_switch = Bump.new()

        mem_trigger = mem_minimum_trigger

        let gcl = GcLocal {
        }
        local_gc = gcl

        // TODO: Add gc to gc list for the shared gc

        return gcl
    }

    pub static fn link(on: ptr, to: ptr) {
        let on_color = @ptrv(on, u16, byte_color_rel)
        let to_color = @ptrv(to, u16, byte_color_rel)

        if on_color != to_color {
            if on_color == color_shared {
                if to_color != color_shared {
                    // Mark shared
                    // TODO
                }
            } else {
                // Add on-item to remark list
                let adr = remark_list.get(sizeof(ptr))
                @ptrv(adr, ptr) = on
            }
        }
    }

    static fn unlink(from: ptr, item: ptr) {
        println("UNLINK")
        let from_color = @ptrv(from, u16, byte_color_rel)
        let item_color = @ptrv(item, u16, byte_color_rel)
        if from_color == item_color && item_color != color_unlink {
            @ptrv(colors.state, u8, item_color) = color_state_unlinked
            @ptrv(item, u16, byte_color_rel) = color_unlink

            let list = check_still_used
            let adr = list.get(sizeof(ptr) * 2)
            @ptrv(adr, ptr) = item
            @ptrv(adr, uint, 1) = item_color
        }
    }

    fn gc() {
        // this.lock.lock()
        print("-")

        let rem = remark_list
        remark_list = remark_list_switch
        remark_list_switch = rem

        // Swap prev color lists
        let pc = prev_stack_items
        prev_stack_items = prev_stack_items_alt
        prev_stack_items_alt = pc

        // pc.size.print(10)
        // print("<.")

        this.mark_on_stack(1)
        this.disable_previous_colors()

        this.handle_remark_list()
        this.mark_stack_items()

        let marked = mem_marked

        this.demark_previous_stack_items()
        this.check_still_used()

        this.mark_on_stack(0)

        let max = mem_trigger / 100 * 95 // reduce 5%
        let max_marked = (mem_marked + mem_minimum_trigger) / 100 * 120 // increase 20%
        if max_marked > max {
            max = max_marked
        }
        mem_trigger = max
        mem_new = mem_marked
        // mem_new = 0

        // reset_allocators()

        // Mark shared
        // if shared_age != this.shared_age {
        //     let age = shared_age
        //     this.mark_stack_shared_age(age)
        //     this.shared_age = age
        // }

        // this.lock.unlock()
    }

    fn mark_on_stack(val: u8) {

        // Globals
        // let globals = this.globals
        // let globalc = this.globalc
        // while globalc-- > 0 {
        //     let ref = @ptrv(globals, ptr, globalc)
        //     let item = @ptrv(ref, ptr)
        //     if item != null {
        //         @ptrv(item, u8, byte_block_index_rel) = (val > 0 ? 128 : 0) | (@ptrv(item, u8, byte_block_index_rel) & 127)
        //     }
        // }

        // Stack
        let stack = stack_main
        let adr = stack.base
        let top = stack.adr
        while adr < top {
            let item = @ptrv(adr, ptr, 0)
            if item != null {
                @ptrv(item, u8, byte_on_stack_rel) = val
            }
            adr += sizeof(ptr)
        }

        // core:Coro.mark_on_stack(val)
    }

    fn disable_previous_colors() {
        let list = prev_stack_items_alt
        let adr = list.data
        let end_adr = adr + list.index
        while adr < end_adr {
            let item = @ptrv(adr, ptr)
            let on_stack = @ptrv(item, u8, byte_on_stack_rel)
            if on_stack == 0 {
                let color = @ptrv(adr, uint, 1) @as u16
                @ptrv(colors.state, u8, color) = color_state_unlinked
            }

            adr += sizeof(ptr) * 2
        }
    }

    fn handle_remark_list() {
        let list = prev_stack_items_alt
        let adr = list.data
        let end_adr = adr + list.index
        while adr < end_adr {
            let item = @ptrv(adr, ptr)
            let on_stack = @ptrv(item, u8, byte_on_stack_rel)
            if on_stack == 0 {
                let color = @ptrv(adr, uint, 1) @as u16
                @ptrv(colors.state, u8, color) = color_state_unlinked
            }

            adr += sizeof(ptr) * 2
        }
    }

    fn mark_stack_items() {
        //
        let pc = prev_stack_items

        // Globals
        // let globals = this.globals
        // let globalc = this.globalc
        // while globalc-- > 0 {
        //     let ref = @ptrv(globals, ptr, globalc)
        //     let item = @ptrv(ref, ptr)
        //     if item != null {
        //         let color = @ptrv(item, u16, byte_color_rel)
        //         if @ptrv(colors.state, u8, color) != color_state_used {
        //             let c = colors.get()
        //             // Call item gc_mark[T]
        //             let vti = @ptrv(item, u32, -1)
        //             if vti > 0 {
        //                 let vt = @ptrv(gc_vtable_data, ptr, vti * GC_VTABLE_SIZE) @as fn(ptr, u16)()
        //             }

        //             // Set previous
        //             let prev = pc.get(sizeof(ptr) * 2)
        //             @ptrv(prev, ptr) = item
        //             @ptrv(prev, uint, 1) = c
        //         }
        //     }
        // }

        // Stack
        let stack = stack_main
        let adr = stack.base
        let top = stack.adr
        // print("a.")
        while adr < top {
            let item = @ptrv(adr, ptr)
            if item != null {
                let color = @ptrv(item, u16, byte_color_rel)
                if @ptrv(colors.state, u8, color) != color_state_used {
                    let c = colors.get()
                    // Call item gc_mark[T]
                    let vti = @ptrv(item, u16, -1)
                    if vti > 0 {
                        let mark = @ptrv(vtable, fn(ptr, u16)(), vti @as uint * VTABLE_COLS)
                        mark(item, c)
                    }

                    // Set previous
                    let prev = pc.get(sizeof(ptr) * 2)
                    @ptrv(prev, ptr) = item
                    @ptrv(prev, uint, 1) = c
                }
            }
            adr += sizeof(ptr)
        }
        // print("c.")

        // core:Coro.mark_stack_items()
    }

    fn demark_previous_stack_items() {
        let pc = prev_stack_items
        let list = prev_stack_items_alt

        let adr = list.data
        let end_adr = adr + list.index
        while adr < end_adr {
            let item = @ptrv(adr, ptr)
            let color = @ptrv(adr, uint, 1) @as u16
            adr += sizeof(ptr) * 2

            if @ptrv(colors.state, u8, color) == color_state_used {
                // Re-add
                let prev = pc.get(sizeof(ptr) * 2)
                @ptrv(prev, ptr) = item
                @ptrv(prev, uint, 1) = color
                continue;
            }

            // gc_demark(item, color)
            let vti = @ptrv(item, u16, -1)
            if vti > 0 {
                let demark = @ptrv(vtable, fn(ptr, u16)(), vti @as uint * VTABLE_COLS + 1)
                demark(item, color)
            }

            @ptrv(colors.state, u8, color) = color_state_unused
            colors.giveback(color)
        }

        prev_stack_items_alt.reset()
    }

    fn check_still_used() {
        let list = check_still_used
        let data = list.data
        let end = data + list.index

        while data < end {
            let item = @ptrv(data, ptr)
            let color = @ptrv(data, uint, 1) @as u16
            data += sizeof(ptr) * 2

            let item_color = @ptrv(item, u16, byte_color_rel)
            if item_color != color_unlink : continue

            @ptrv(item, u16, byte_color_rel) = color
            // gc_demark(item, color)
            let vti = @ptrv(item, u16, -1)
            if vti > 0 {
                let demark = @ptrv(vtable, fn(ptr, u16)(), vti @as uint * VTABLE_COLS + 1)
                demark(item, color)
            }

            if @ptrv(colors.state, u8, color) == color_state_unlinked {
                @ptrv(colors.state, u8, color) = color_state_unused
                colors.giveback(color)
            }
        }

        list.reset()
    }

    pub fn shutdown() {
    }
}
