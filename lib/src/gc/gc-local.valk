
use coro

global local_gc : GcLocal (@undefined)

global stack_main : Stack (@undefined)
global stack_active : Stack (@undefined)

global mem_new : uint
global mem_trigger : uint
global mem_suggestion : uint
global mem_marked : uint

value mem_minimum_trigger (8192)

fn update_usage() {
    // Calculate mem usage
    if mem_new > mem_trigger : gc()
}

+ fn gc() {
    local_gc.gc()
}

+ fn gc_suggestion() {
    if mem_new > mem_suggestion {
        local_gc.gc()
    }
}

struct GcLocal {
    globals: Bump (Bump.new())
    update_shared: bool (true)
    stop: bool (false)
    disable: bool (false)

    + static fn init() GcLocal {

        stack_main = Stack.new()
        stack_active = stack_main

        // ColorBook.init()
        pools_init()
        boxes_init()

        mem_trigger = mem_minimum_trigger
        mem_suggestion = mem_minimum_trigger

        let gcl = GcLocal {
        }
        local_gc = gcl

        // TODO: Add gc to gc list for the shared gc

        return gcl
    }

    fn add_global(ref: ptr) {
        let adr = this.globals.get(sizeof(ptr))
        @ptrv(adr, ptr) = ref
    }

    fn gc() {

        if this.disable : return
        this.disable = true

        // this.lock.lock()
        // print("-")

        this.mark_stacks()
        this.check_current_box()
        reset_pools()

        // Set next box
        box_current++
        if box_current == BOX_COUNT : box_current = 0
        box_insert = box_current + 1
        if box_insert == BOX_COUNT : box_insert = 0

        // Update gc trigger point
        mem_trigger = mem_marked / 10 * 13 + mem_minimum_trigger
        mem_new = mem_marked

        // Mark shared
        if this.update_shared {
            // this.mark_shared()
            this.update_shared = false
        }

        this.disable = false
        // this.lock.unlock()
        // print(".")
    }

    fn mark_stacks() {
        let current = box_current

        // Globals
        let g_adr = this.globals.data
        let g_end_adr = g_adr + this.globals.index
        while g_adr < g_end_adr {
            let ref = @ptrv(g_adr, ptr)
            let item = @ptrv(ref, ptr)
            if item != null {
                this.mark_item(item, current)
            }
            g_adr += sizeof(ptr)
        }

        // Stack
        let stack = stack_main
        let adr = stack.base
        let top = stack.adr
        while adr < top {
            let item = @ptrv(adr, ptr, 0)
            if item != null {
                this.mark_item(item, current)
            }
            adr += sizeof(ptr)
        }

        let coro_data = coro:g_coros.data
        let coro_count = coro:g_coros.length
        while coro_count-- > 0 {
            let coro = @ptrv(coro_data, ?ptr, coro_count)
            if isset(coro) {
                let adr = (coro @as coro:Coro).stack.base
                let top = (coro @as coro:Coro).stack.adr
                while adr < top {
                    let item = @ptrv(adr, ptr)
                    if item != null {
                        this.mark_item(item, current)
                    }
                    adr += sizeof(ptr)
                }
            }
        }
    }

    fn mark_item(item: ptr, box: u8) {
        if @ptrv(item, u8, byte_box_rel) == box && @ptrv(item, u8, byte_mark_rel) == 0 {
            mark(item, box)
        }
    }

    fn check_current_box() {
        let current = box_current
        let b = box_get(current)

        let adr = b.data
        let end = adr + b.index
        b.index = 0 // Clear box

        while adr < end {
            let item = @ptrv(adr, ptr)
            adr += sizeof(ptr)

            let item_box = @ptrv(item, u8, byte_box_rel)
            if item_box != current {
                // Move item to correct box
                let ib = box_get(item_box)
                ib.add_ptr(item)
                continue
            }

            // Check mark
            if @ptrv(item, u8, byte_mark_rel) == 0 {
                // Free item
                free_item(item)
                continue
            }
        }
    }


    + fn shutdown() {
        // this.stop = true
        // this.gc()
        // print("\n###\n")
        // println(stack_items_new.size)
        // println(stack_items_old.size)
        // println(colors.size)
        // println(mem_marked)
        // print("###\n")
    }
}
