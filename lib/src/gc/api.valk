
use core

value trigger_reached (gc.mem_new >= gc.mem_trigger)
value trigger_almost_reached (gc.mem_new >= gc.mem_trigger / 4 * 3)
value shared_trigger_reached (mem_shared >= mem_shared_trigger)
value shared_trigger_almost_reached (mem_shared >= mem_shared_trigger / 4 * 3)

~ shared mem_usage_shared : uint
~ shared mem_usage_peak : uint
+ shared verify : bool (@undefined)

+ fn collect() {
    gc.collect()
}

+ fn lock() {
    gc.lock()
}
+ fn unlock() $undefined {
    gc.unlock()
}

+ fn collect_if_threshold_reached() {
    if trigger_reached {
        if core:rlock_count > 0 : return
        if gc.disable : return
        gc.collect()
        if shared_trigger_reached {
            collect_shared()
        }
    }
}
+ fn collect_if_threshold_almost_reached() {
    if trigger_almost_reached {
        if core:rlock_count > 0 : return
        if gc.disable : return
        gc.collect()
        if shared_trigger_almost_reached {
            collect_shared()
        }
    }
}

+ fn collect_shared_if_threshold_reached() {
    if shared_trigger_reached {
        if gc.disable : return
        collect_shared()
    }
}

+ fn alloc(size: uint) GcPtr {
    if size == 0 : return null.@cast(.)
    let pool = get_pool_for_size(size)
    let item = pool.get()
    return item.@cast(GcPtr)
}
