
fn mark_item(item: ptr, color: color_type) {
    let vti = @ptrv(item, u16, byte_vtable_index_rel)
    let func = @ptrv(gc_tables, fn(ptr, color_type)(), vti * GC_TABLE_SIZE + vt_mark)
    func(item, color)
}

fn mark[T](item: ptr, color: color_type) $hot {
    let item_color = @ptrv(item, color_type, byte_color_rel)
    if item_color == color : return
    if @ptrv(color_state, u8, item_color) == color_state_used {
        color_disable_after = true
        if item_color == color_shared && local_gc.update_shared {
            share[T](item)
        }
        return
    }

    if item_color == color_blank {
        let index = @ptrv(item, u8, byte_block_index_rel) @as uint
        if index != 255 {
            let block = item - 8 - (index * size_of_pool(T)) - POOL_DATA_OFFSET
            @ptrv(block, uint, 2)++ // Increase block items-used
            mem_marked += @ptrv(block, uint, 4)
        }
    }

    // Set item color
    @ptrv(item, color_type, byte_color_rel) = color

    // Mark properties
    #loop properties item, T as prop, type
    #if @is_gc_type(type)
    {
        #if @is_nullable_type(type)
        let p = prop @as ?ptr
        if isset(p) {
        #else
        let p = prop @as ptr
        #end
            mark[notnull(type)](p, color)
        #if @is_nullable_type(type)
        }
        #end
    }
    #end
    #end

    // Call _gc_mark hook
    #if @type_has_method(T, _gc_mark)
    (item @as T)._gc_mark(color)
    #end
}

fn free_blank(item: ptr) $hot {
    if @ptrv(item, color_type, byte_color_rel) != color_blank : return
    
    let vti = @ptrv(item, u16, byte_vtable_index_rel)
    let func = @ptrv(gc_tables, ?fn(ptr)(), vti * GC_TABLE_SIZE + vt_free_hook)
    if isset(func) {
        func(item)
    }
}

fn free_item(item: ptr) {
    let vti = @ptrv(item, u16, byte_vtable_index_rel)
    let func = @ptrv(gc_tables, fn(ptr)(), vti * GC_TABLE_SIZE + vt_free)
    func(item)
}

fn free[T](item: ptr) {
    let item_color = @ptrv(item, color_type, byte_color_rel)
    if item_color == color_blank : return
    if @ptrv(color_state, u8, item_color) == color_state_used : return
    
    @ptrv(item, color_type, byte_color_rel) = color_blank

    let index = @ptrv(item, u8, byte_block_index_rel) @as uint
    if index != 255 {
        let block = item - 8 - (index * size_of_pool(T)) - POOL_DATA_OFFSET
        @ptrv(block, uint, 2)-- // Reduce block items-used
        mem_marked -= @ptrv(block, uint, 4)
    }

    // Free properties
    #loop properties item, T as prop, type
    #if @is_gc_type(type)
    {
        #if @is_nullable_type(type)
        let p = prop @as ?ptr
        if isset(p) {
        #else
        let p = prop @as ptr
        #end
            free[notnull(type)](p)
        #if @is_nullable_type(type)
        }
        #end
    }
    #end
    #end

    #if @type_has_method(T, _gc_free_properties)
    (item @as T)._gc_free_properties()
    #end

    #if @type_has_method(T, _gc_free)
    if index != 255 {
        (item @as T)._gc_free()
    }
    #end
}

fn share_item_null_check(item: ?ptr) {
    if !isset(item) : return
    share_item(item)
}

fn share_item(item: ptr) {
    let vti = @ptrv(item, u16, byte_vtable_index_rel)
    let func = @ptrv(gc_tables, fn(ptr)(), vti * GC_TABLE_SIZE + vt_share)
    func(item)
}

fn share[T](item: ptr) {
    let mark = @ptrv(item, u8, byte_mark_rel)
    let item_color = @ptrv(item, color_type, byte_color_rel)
    if item_color == color_shared {
        if mark & shared_mark != shared_mark {
            @ptrv(item, u8, byte_mark_rel) = (mark & 243) | shared_mark
        }
        return
    }
    @ptrv(item, color_type, byte_color_rel) = color_shared
    @ptrv(item, u8, byte_mark_rel) = (mark & 243) | shared_mark

    if item_color == color_blank {
        let index = @ptrv(item, u8, byte_block_index_rel) @as uint
        if index != 255 {
            let block = item - 8 - (index * size_of_pool(T)) - POOL_DATA_OFFSET
            @ptrv(block, uint, 2)++ // Increase block items-used
            mem_marked += @ptrv(block, uint, 4)
        }
    }

    // Share properties
    #loop properties item, T as prop, type
    #if @is_gc_type(type)
    {
        #if @is_nullable_type(type)
        let p = prop @as ?ptr
        if isset(p) {
        #else
        let p = prop @as ptr
        #end
            share[notnull(type)](p)
        #if @is_nullable_type(type)
        }
        #end
    }
    #end
    #end

    // Call _gc_share hook
    #if @type_has_method(T, _gc_share)
    (item @as T)._gc_share()
    #end
}
