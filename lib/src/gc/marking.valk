

fn mark(item: ptr, color: color_type) {
    let item_color = @ptrv(item, color_type, byte_color_rel)
    if @ptrv(colors.state, u8, item_color) == color_state_used : return
    // Update color
    @ptrv(item, color_type, byte_color_rel) = color
    if item_color == color_blank {
        mem_marked += 24
    }
    // 
    let has_vtable = (@ptrv(item, u8, byte_settings_rel) & 1) == 1
    let propc = @ptrv(item, u8, byte_propc_rel)
    // Mark properties
    if has_vtable {
        print("?")
        @ptrv(item, u8, byte_settings_rel).print(10)
        print(".")
        exit(1)
    }
    let prop_base = item + (has_vtable ? 0 : 0)
    while propc-- > 0 {
        let sub = @ptrv(prop_base, ?ptr, propc)
        if isset(sub) : mark(sub, color)
    }
}

// fn mark[T](item: ptr, color: u16) {

//     let b = @ptrv(vtable, ptr, 2)
//     let item_ptr = item @as ptr
//     let item_color = @ptrv(item_ptr, u16, byte_color_rel)
//     if @ptrv(colors.state, u8, item_color) == color_state_used : return

//     @ptrv(item_ptr, u16, byte_color_rel) = color

//     if item_color == color_blank {
//         let size : uint = sizeof(<T>) + 8
//         mem_marked += size

//         let block_index = @ptrv(item_ptr, u8, byte_block_index_rel)
//         let block_start = item_ptr - 8 - block_index * size
//         @ptrv(block_start, uint, -2)++ // Increase used items count
//     }

//     let added = false
//     #loop properties item, T as prop, type
//     #if @is_gc_type(type)
//     {
//         // let p = prop
//         #if @is_nullable_type(type)
//         let p = prop @as ?ptr
//         if isset(p) {
//         #else
//         let p = prop @as ptr
//         #end
//             mark[type](p, color)
//             // Check if linked to another color
//             if !added {
//                 let prop_ptr = p @as ptr
//                 let prop_color = @ptrv(prop_ptr, u16, byte_color_rel)
//                 if prop_color != color {
//                     // Add to remark list
//                     let adr = remark_list_new.get(sizeof(ptr))
//                     @ptrv(adr, ptr) = item_ptr
//                     added = true
//                 }
//             }
//         #if @is_nullable_type(type)
//         }
//         #end
//     }
//     #end
//     #end

//     // Call _gc_mark hook
//     #if @type_has_method(T, _gc_mark)
//     (item @as T)._gc_mark(color)
//     #end
// }

// fn demark[T](item: ptr, color: u16) {

//     let item_ptr = item @as ptr
    
//     if @ptrv(item_ptr, u16, byte_color_rel) != color : return
//     @ptrv(item_ptr, u16, byte_color_rel) = color_blank

//     let size : uint = sizeof(<T>) + 8
//     mem_marked -= size

//     let block_index = @ptrv(item_ptr, u8, byte_block_index_rel)
//     let block_start = item_ptr - 8 - block_index * size
//     @ptrv(block_start, uint, -2)-- // Increase used items count

//     #loop properties item, T as prop, type
//     #if @is_gc_type(type)
//     {
//         #if @is_nullable_type(type)
//         let p = prop @as ?ptr
//         if isset(p) {
//         #else
//         let p = prop @as ptr
//         #end
//             demark[type](p, color)
//         #if @is_nullable_type(type)
//         }
//         #end
//     }
//     #end
//     #end

//     // Call _gc_free
//     #if @type_has_method(T, _gc_free)
//     (item @as T)._gc_free()
//     #end
// }
