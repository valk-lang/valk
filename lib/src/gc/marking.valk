
fn mark_used(item: ptr, from_stack: bool) bool $hot {

    let data = (@ptr_offset(item, -8)) @as GcData

    let used = data.used
    if used == 1 {
        if from_stack && data.on_stack == 0 {
            data.on_stack = 1
            let adr = stack_hits.get(sizeof(ptr))
            @ptrv(adr, ptr, item)
        }
        return false
    }
    data.used = 1

    // Increase block counter
    if used == 0 {
        // New item
        let offset = data.block_offset
        if offset > 0 {
            let block = item - offset
            @ptrv(block, uint, 2)++ // Increase block items-used
            mem_marked += @ptrv(block, uint, 4)
        }
    }

    mark_properties_used(item, from_stack)

    return true
}

fn mark_properties_used(item: ptr, from_stack: bool) bool $hot {

    let data = (@ptr_offset(item, -8)) @as GcData

    // Props
    let has_vtable = data.has_vtable == 1
    let propc = data.propc
    if propc > 0 {
        // Mark properties
        let reconnect = false
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) && (sub & 1 == 0) {
                if mark_used(sub, from_stack) {
                    // Main pipe line
                    @ptrv(prop_base, ?ptr, propc) = sub | 1
                } else {
                    // Already connected to a pipe
                    // Add to reconnect_list
                    reconnect = true
                }
            }
        }
        if reconnect {
            let in_list = data.in_list
            if in_list & in_list_reconnect == 0 {
                data.in_list = in_list | in_list_reconnect
                let adr = reconnect_list.get(sizeof(ptr))
                @ptrv(adr, ptr, item)
            }
        }
    }

    // Call hook _gc_mark
    if has_vtable {
        let vt = data.vtable
        let func = @ptrv(vt, ?fn(ptr, color_type)(), 0)
        if isset(func) {
            func(item)
        }
    }
}

fn disconnect_rec(item: ptr) $hot {

    let data = (@ptr_offset(item, -8)) @as GcData

    let used = data.used
    if used != 1 : return
    data.used = 2
    if data.on_stack : return

    // Props
    let has_vtable = data.has_vtable == 1
    let propc = data.propc
    if propc > 0 {
        // Mark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) && (sub & 1 == 1) {
                disconnect_rec(sub & -2)
            }
        }
    }

    return
}

fn free_blank(item: ptr) $hot {
    let data = (@ptr_offset(item, -8)) @as GcData
    if data.used != 0 : return
    let vt = data.vtable
    let func = @ptrv(vt, ?fn(ptr)(), 2)
    if isset(func) {
        func(item)
    }
}

fn free_disconnect_rec(item: ptr) $hot {

    let data = (@ptr_offset(item, -8)) @as GcData
    let mark = data.marks

    if data.used != 2 : return
    data.used = 0

    let offset = data.block_offset
    if offset > 0 {
        let block = item - offset
        @ptrv(block, uint, 2)-- // Reduce block items-used
        mem_marked -= @ptrv(block, uint, 4)
    }

    let propc = data.propc
    let has_vtable = data.has_vtable == 1
    if propc > 0 {
        // Mark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) && (sub & 1 == 1) {
                free_disconnect_rec(sub & -2)
            }
        }
    }

    if has_vtable {
        let vt = data.vtable

        // _gc_free_properties
        let f1 = @ptrv(vt, ?fn(ptr)(), 1)
        if isset(f1) {
            f1(item)
        }

        if offset > 0 {
            // _gc_free
            let f2 = @ptrv(vt, ?fn(ptr)(), 2)
            if isset(f2) {
                f2(item)
            }
        }
    }
}

fn share_null_check(item: ?ptr) {
    if !isset(item) : return
    share(item)
}

fn share(item: ptr) {
    return

    // let data = (@ptr_offset(item, -8)) @as GcData
    // let item_color = data.color
    // let mark_ = data.mark

    // if item_color == color_shared {
    //     if mark_ & shared_mark != shared_mark {
    //         data.mark = (mark_ & 249) | shared_mark
    //     }
    //     return
    // }

    // data.color = color_shared
    // data.mark = (mark_ & 249) | shared_mark

    // if item_color == color_blank {
    //     let offset = data.block_offset
    //     if offset > 0 {
    //         let block = item - offset
    //         @ptrv(block, uint, 2)++ // Increase block items-used
    //         mem_marked += @ptrv(block, uint, 4)
    //     }
    // }

    // let has_vtable = (mark_ & mark_bit_has_vtable) != 0
    // let propc = data.propc
    // if propc > 0 {
    //     // Mark properties
    //     let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
    //     while propc-- > 0 {
    //         let sub = @ptrv(prop_base, ?ptr, propc)
    //         if isset(sub) {
    //             share(sub)
    //         }
    //     }
    // }

    // if has_vtable {
    //     let vt = data.vtable
    //     let func = @ptrv(vt, ?fn(ptr)(), 3)
    //     if isset(func) {
    //         func(item)
    //     }
    // }
}
