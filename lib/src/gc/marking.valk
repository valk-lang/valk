

fn mark(item: ptr, color: color_type) {
    let item_color = @ptrv(item, color_type, byte_color_rel)
    if @ptrv(colors.state, u8, item_color) == color_state_used : return
    // Update color
    @ptrv(item, color_type, byte_color_rel) = color
    if item_color == color_blank {
        let offset = @ptrv(item, u16, byte_pool_offset_rel)
        if offset > 0 {
            let base = item - 8 - offset
            mem_marked += @ptrv(base, uint, 4) // Add item size
            @ptrv(base, uint, 2)++ // Update block used count
        }
    }
    // 
    let has_vtable = (@ptrv(item, u8, byte_settings_rel) & 1) == 1
    let propc = @ptrv(item, u8, byte_propc_rel)
    if propc > 0 {
        // Mark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        let add_to_remark = false
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) {
                let sub_color = @ptrv(sub, color_type, byte_color_rel)
                if sub_color != color {
                    mark(sub, color)
                    if !add_to_remark && @ptrv(sub, color_type, byte_color_rel) != color && sub_color >= color_custom {
                        add_to_remark = true
                    }
                }
            }
        }
        if add_to_remark {
            add_to_remark_list(item)
        }
    }

    if has_vtable {
        let vt = @ptrv(item, ptr, 0)
        let func = @ptrv(vt, ?fn(ptr, color_type)(), 0)
        if isset(func) {
            func(item, color)
        }
    }
}

fn add_to_remark_list(item: ptr) {
    let settings = @ptrv(item, u8, byte_settings_rel)
    if settings & 4 == 0 {
        remark_list_new.add_ptr(item)
        @ptrv(item, u8, byte_settings_rel) = settings | 4
    }
}

fn unmark(item: ptr, color: color_type) {
    let item_color = @ptrv(item, color_type, byte_color_rel)
    if item_color != color : return

    // Load details
    let offset = @ptrv(item, u16, byte_pool_offset_rel)
    let has_vtable = (@ptrv(item, u8, byte_settings_rel) & 1) == 1
    let propc = @ptrv(item, u8, byte_propc_rel)

    // Clear details
    @ptrv(item, color_type, byte_color_rel) = color_blank
    @ptrv(item, u8, byte_settings_rel) = 0 // Clear settings

    // Update block
    if offset > 0 {
        let base = item - 8 - offset
        mem_marked -= @ptrv(base, uint, 4)
        @ptrv(base, uint, 2)-- // Reduce block used count
    }

    if propc > 0 {
        // Unmark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) : unmark(sub, color)
        }
    }

    if has_vtable {
        let vt = @ptrv(item, ptr, 0)

        let func = @ptrv(vt, ?fn(ptr, color_type)(), 1)
        if isset(func) {
            func(item, color)
        }

        if offset > 0 {
            let func = @ptrv(vt, ?fn(ptr)(), 2)
            if isset(func) {
                func(item)
            }
        }
    }

}

// fn mark[T](item: ptr, color: u16) {

//     let b = @ptrv(vtable, ptr, 2)
//     let item_ptr = item @as ptr
//     let item_color = @ptrv(item_ptr, u16, byte_color_rel)
//     if @ptrv(colors.state, u8, item_color) == color_state_used : return

//     @ptrv(item_ptr, u16, byte_color_rel) = color

//     if item_color == color_blank {
//         let size : uint = sizeof(<T>) + 8
//         mem_marked += size

//         let block_index = @ptrv(item_ptr, u8, byte_block_index_rel)
//         let block_start = item_ptr - 8 - block_index * size
//         @ptrv(block_start, uint, -2)++ // Increase used items count
//     }

//     let added = false
//     #loop properties item, T as prop, type
//     #if @is_gc_type(type)
//     {
//         // let p = prop
//         #if @is_nullable_type(type)
//         let p = prop @as ?ptr
//         if isset(p) {
//         #else
//         let p = prop @as ptr
//         #end
//             mark[type](p, color)
//             // Check if linked to another color
//             if !added {
//                 let prop_ptr = p @as ptr
//                 let prop_color = @ptrv(prop_ptr, u16, byte_color_rel)
//                 if prop_color != color {
//                     // Add to remark list
//                     let adr = remark_list_new.get(sizeof(ptr))
//                     @ptrv(adr, ptr) = item_ptr
//                     added = true
//                 }
//             }
//         #if @is_nullable_type(type)
//         }
//         #end
//     }
//     #end
//     #end

//     // Call _gc_mark hook
//     #if @type_has_method(T, _gc_mark)
//     (item @as T)._gc_mark(color)
//     #end
// }

// fn demark[T](item: ptr, color: u16) {

//     let item_ptr = item @as ptr
    
//     if @ptrv(item_ptr, u16, byte_color_rel) != color : return
//     @ptrv(item_ptr, u16, byte_color_rel) = color_blank

//     let size : uint = sizeof(<T>) + 8
//     mem_marked -= size

//     let block_index = @ptrv(item_ptr, u8, byte_block_index_rel)
//     let block_start = item_ptr - 8 - block_index * size
//     @ptrv(block_start, uint, -2)-- // Increase used items count

//     #loop properties item, T as prop, type
//     #if @is_gc_type(type)
//     {
//         #if @is_nullable_type(type)
//         let p = prop @as ?ptr
//         if isset(p) {
//         #else
//         let p = prop @as ptr
//         #end
//             demark[type](p, color)
//         #if @is_nullable_type(type)
//         }
//         #end
//     }
//     #end
//     #end

//     // Call _gc_free
//     #if @type_has_method(T, _gc_free)
//     (item @as T)._gc_free()
//     #end
// }
