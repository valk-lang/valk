

fn mark(item: ptr, box: u8) {

    if @ptrv(item, u8, byte_mark_rel) == 1 : return
    if @ptrv(item, u8, byte_box_rel) != box : return

    @ptrv(item, u8, byte_mark_rel) = 1

    // 
    let has_vtable = (@ptrv(item, u8, byte_settings_rel) & 1) == 1
    let propc = @ptrv(item, u8, byte_propc_rel)
    if propc > 0 {
        // Mark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) {
                mark(sub, box)
            }
        }
    }

    if has_vtable {
        let vt = @ptrv(item, ptr, 0)
        let func = @ptrv(vt, ?fn(ptr, u8)(), 0)
        if isset(func) {
            func(item, box)
        }
    }
}

fn free_item(item: ptr) {
    let has_vtable = (@ptrv(item, u8, byte_settings_rel) & 1) == 1

    let offset = @ptrv(item, u16, -1)
    let block = item - offset
    @ptrv(block, uint, 2)-- // Reduce block items-used
    @ptrv(item, u8, byte_box) = BOX_DEFAULT
    mem_new -= @ptrv(block, uint, 4)

    if has_vtable {
        let vt = @ptrv(item, ptr, 0)
        let func = @ptrv(vt, ?fn(ptr)(), 2)
        if isset(func) {
            func(item)
        }
    }
}

fn share(item: ptr) {
}
