
fn mark_used(item: ?GcItem) $hot {

    let ml = gc.mark_list
    let pl = gc.prop_list
    if isset(item) : ml.add(item)

    while true {
        let item = ml.pop() ! break
        let data = gcdata(item)
        let block = data.block()

        if data.is_new() {
            block.slots_used++
            gc.mem_marked += block.isize
        }
        #if GC_DEBUG
        if data.is_still_co_owned() : panic("double ownership")
        #end
        data.set_owned()

        let pf = block.props
        if isset(pf) : pf(item, pl.@cast(.))
        
        while true {
            let ref = pl.pop() ! break
            let sub = @ptrv(ref, ?ptr)
            if !isset(sub) : continue
            if sub & prop_mask == 0 {
                let sub_data = gcdata(sub)
                if sub_data.is_not_owned_not_shared() {
                    @ptrv(ref, ptr) = sub | prop_owned
                    if sub_data.is_new() {
                        let sub_block = sub_data.block()
                        sub_block.slots_used++
                        gc.mem_marked += sub_block.isize
                    }
                    sub_data.set_owned()
                    ml.add(sub)
                } else {
                    @ptrv(ref, ptr) = sub | prop_co_owned
                    sub_data.co_own()
                }
            }
        }
    }
}

fn free_blank(item: ptr) $hot {
    let data = gcdata(item)
    if data.is_not_new() : return

    // Call gc_free
    let block = data.block()
    let onfree = block.onfree
    if isset(onfree) : onfree(item)

    #if GC_DEBUG
    if data.co_count != 0 : panic("co_count not 0 before free")
    if data.flags != 0 {
        print("Flags: ")
        data.flags.print(10)
        print("\n")
        panic("GC error: Flags not 0 before free")
    }
    #end
}

fn dis_own_rec(item: ptr) {

    let ml = gc.mark_list
    let pl = gc.prop_list
    ml.add(item)

    while true {
        let item = (ml.pop() ! break).@cast(GcItem)
        let data = gcdata(item)

        #if GC_DEBUG
        if data.is_shared() : panic("removing ownership from shared item")
        if data.is_new() : panic("double ownership removal")
        if data.is_still_co_owned() : panic("unexpected ownership removal")
        #end

        if data.is_on_stack() {
            data.set_owned()
            gc.prev_stack_items.add_ptr(item)
            continue
        }

        let block = data.block()
        // if data.block_index != 0xFF {
            block.slots_used--
            gc.mem_marked -= block.isize
        // }

        gc.dis_own_count++
        data.set_new()
        if data.co_count > 0 : gc.re_own_list.add_ptr(item)

        // Props
        let pf = block.props
        if isset(pf) : pf(item, pl.@cast(.))
        
        while true {
            let ref = pl.pop() ! break
            let sub = @ptrv(ref, ?ptr)
            if !isset(sub) : continue
            if sub & prop_owned == prop_owned {
                let sub_item = sub - prop_owned
                @ptrv(ref, ptr) = sub_item
                let sub_data = gcdata(sub_item)
                sub_data.set_no_owner()
                if sub_data.is_shared() : continue
                ml.add(sub_item)
            } else if sub & prop_co_owned == prop_co_owned {
                let sub_item = sub - prop_co_owned
                @ptrv(ref, ptr) = sub_item
                let sub_data = gcdata(sub_item)
                atomic(sub_data.co_count - 1)
                if sub_data.is_still_co_owned() {
                    sub_data.remove_still_co_owned()
                    // Lets pretend we were the owner
                    ml.add(sub_item)
                }
            }
        }

        let onfree = block.onfree
        if isset(onfree) : gc.blanks.add_ptr(item)
    }
}


fn share_null_check(item: ?ptr) {
    if isset(item) {
        share(item)
    }
}

fn share(item: GcItem) {
    let ds = gc.dont_stop
    gc.dont_stop = true

    let ml = gc.mark_list
    let pl = gc.prop_list
    let start = ml.index
    ml.add(item)

    while true {
        if ml.index == start : break
        let item = (ml.pop() ! break).@cast(GcItem)
        let data = gcdata(item)

        if data.is_shared() : continue
        data.set_shared()
        // data.set_mark()

        let is_new = data.is_new()
        if is_new : data.set_no_owner()
        else if data.is_still_co_owned() {
            data.remove_still_co_owned()
            data.set_no_owner()
        }

        gc.shared_items.add_ptr(item)

        let block = data.block()
        // if data.block_index != 0xFF {
            let size = block.isize
            if is_new {
                block.slots_used++
            } else {
                gc.mem_marked -= size
            }
            // Increase mem shared
            atomic(mem_shared + size)
        // }

        // Props
        let pf = block.props
        if isset(pf) : pf(item, pl.@cast(.))
        
        while true {
            let ref = pl.pop() ! break
            let sub = @ptrv(ref, ?ptr)
            if !isset(sub) : continue
            let sub_item : GcItem = sub & -4.to(uint)
            let sub_data = gcdata(sub_item)
            if sub & prop_owned == prop_owned {
                // Remove ownership
                @ptrv(ref, ?GcItem) = sub_item
                sub_data.set_no_owner()
            } else if sub & prop_co_owned == prop_co_owned {
                // Remove co ownership
                @ptrv(ref, ?GcItem) = sub_item
                atomic(sub_data.co_count - 1)
            }

            ml.add(sub_item)
        }
    }

    gc.dont_stop = ds
}

fn update_mark(item: GcItem) {

    let ml = gc.mark_list
    let pl = gc.prop_list
    ml.add(item)

    while true {
        let item = (ml.pop() ! break).@cast(GcItem)
        let data = gcdata(item)

        if data.is_marked() : continue 
        data.set_mark()

        // Props
        let block = data.block()
        let pf = block.props
        if isset(pf) : pf(item, pl.@cast(.))
        
        while true {
            let ref = pl.pop() ! break
            let sub = @ptrv(ref, ?ptr)
            if !isset(sub) : continue
            let sub_item : GcItem = sub & -4.to(uint)
            let sub_data = gcdata(sub_item)
            if sub_data.is_marked() : continue 
            ml.add(sub_item)
        }
    }
}

fn mark_leak_rec(item: GcItem, on: bool) {

    let ml = gc.mark_list
    let pl = gc.prop_list
    ml.add(item)

    while true {
        let item = (ml.pop() ! break).@cast(GcItem)
        let data = gcdata(item)
        if data.is_shared() : continue
        if on {
            if data.has_leak_mark() : continue 
            data.set_leak_mark()
        } else {
            if !data.has_leak_mark() : continue 
            data.remove_leak_mark()
        }

        // Props
        let block = data.block()
        let pf = block.props
        if isset(pf) : pf(item, pl.@cast(.))
        
        while true {
            let ref = pl.pop() ! break
            let sub = @ptrv(ref, ?ptr)
            if !isset(sub) : continue
            let sub_item : ptr = sub & -4.to(uint)
            ml.add(sub_item)
        }
    }
}
