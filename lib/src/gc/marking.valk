

// fn mark(item: ptr, color: color_type) {

//     let item_color = @ptrv(item, color_type, byte_color_rel)
//     if item_color == color : return
//     if @ptrv(color_state, u8, item_color) == color_state_used {
//         color_disable_after = true
//         if item_color == color_shared && local_gc.update_shared {
//             share(item)
//         }
//         return
//     }

//     if item_color == color_blank {
//         let offset = @ptrv(item, u16, -1) @as uint
//         if offset > 0 {
//             let block = item - offset - 8
//             @ptrv(block, uint, 2)++ // Increase block items-used
//             mem_marked += @ptrv(block, uint, 4)
//         }
//     }

//     let has_vtable = @ptrv(item, u8, byte_vtable_rel) == 1

//     if has_vtable {
//         let vt = @ptrv(item, ptr, 0)
//         let func = @ptrv(vt, ?fn(ptr, color_type)(), 0)
//         if isset(func) {
//             func(item, color)
//         }
//     }

//     @ptrv(item, color_type, byte_color_rel) = color

//     // 
//     let propc = @ptrv(item, u8, byte_propc_rel)
//     if propc > 0 {
//         // Mark properties
//         let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
//         while propc-- > 0 {
//             let sub = @ptrv(prop_base, ?ptr, propc)
//             if isset(sub) {
//                 mark(sub, color)
//             }
//         }
//     }
// }

fn mark_item(item: ptr, color: color_type) {
    let vti = @ptrv(item, u16, byte_vtable_index_rel)
    let func = @ptrv(gc_tables, fn(ptr, color_type)(), vti * GC_TABLE_SIZE + vt_mark)
    func(item, color)
}

fn mark[T](item: ptr, color: color_type) {
    let item_color = @ptrv(item, color_type, byte_color_rel)
    if item_color == color : return
    if @ptrv(color_state, u8, item_color) == color_state_used {
        color_disable_after = true
        if item_color == color_shared && local_gc.update_shared {
            share[T](item)
        }
        return
    }
    // print(">")
    //             let vti = @ptrv(item, u16, byte_vtable_index_rel)
    //             print("vt index: " + vti + "\n")
    //             print("mark: " + @ptrv(item, u8, byte_mark_rel) + "\n")

    if item_color == color_blank {
        let index = @ptrv(item, u8, byte_block_index_rel) @as uint
        if index != 255 {
            let block = item - 8 - (index * size_of_pool(T)) - POOL_DATA_OFFSET
            // if @ptrv(block, uint, 4) != size_of_pool(T) {
            //     let vti = @ptrv(item, u16, byte_vtable_index_rel)
            //     print("mark: " + @ptrv(item, u8, byte_mark_rel) + "\n")
            //     print("item: 0x" + item + "\n")
            //     print("vt index: " + vti + "\n")
            //     panic("Diff: " + @ptrv(block, uint, 4) + " vs " + size_of_pool(T))
            // }
            @ptrv(block, uint, 2)++ // Increase block items-used
            mem_marked += @ptrv(block, uint, 4)
        }
    }

    // Call _gc_mark hook
    #if @type_has_method(T, _gc_mark)
    (item @as T)._gc_mark(color)
    #end

    // Set item color
    @ptrv(item, color_type, byte_color_rel) = color

    // Mark properties
    #loop properties item, T as prop, type
    #if @is_gc_type(type)
    {
        #if @is_nullable_type(type)
        let p = prop @as ?ptr
        if isset(p) {
        #else
        let p = prop @as ptr
        #end
            mark[notnull(type)](p, color)
        #if @is_nullable_type(type)
        }
        #end
    }
    #end
    #end
}

fn free_blank(item: ptr) {
    if @ptrv(item, color_type, byte_color_rel) != color_blank : return
    
    let vti = @ptrv(item, u16, byte_vtable_index_rel)
    let func = @ptrv(gc_tables, ?fn(ptr)(), vti * GC_TABLE_SIZE + vt_free_hook)
    if isset(func) {
        func(item)
    }

    // @ptrv(item, u8, byte_vtable_rel) = 0
    // let vt = @ptrv(item, ptr, 0)
    // let func = @ptrv(vt, ?fn(ptr)(), 2)
    // if isset(func) {
    //     func(item)
    // }
}

// fn free(item: ptr) {
//     let item_color = @ptrv(item, color_type, byte_color_rel)
//     if item_color == color_blank : return
//     if @ptrv(color_state, u8, item_color) == color_state_used : return
    
//     @ptrv(item, color_type, byte_color_rel) = color_blank

//     let offset = @ptrv(item, u16, -1) @as uint
//     if offset > 0 {
//         let block = item - offset - 8
//         @ptrv(block, uint, 2)-- // Reduce block items-used
//         mem_marked -= @ptrv(block, uint, 4)
//     }

//     let has_vtable = @ptrv(item, u8, byte_vtable_rel) == 1
//     let propc = @ptrv(item, u8, byte_propc_rel)
//     if propc > 0 {
//         // Mark properties
//         let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
//         while propc-- > 0 {
//             let sub = @ptrv(prop_base, ?ptr, propc)
//             if isset(sub) {
//                 free(sub)
//             }
//         }
//     }

//     if has_vtable {
//         @ptrv(item, u8, byte_vtable_rel) = 0

//         let vt = @ptrv(item, ptr, 0)

//         // _gc_free_properties
//         let f1 = @ptrv(vt, ?fn(ptr)(), 1)
//         if isset(f1) {
//             f1(item)
//         }

//         if offset > 0 {
//             // _gc_free
//             let f2 = @ptrv(vt, ?fn(ptr)(), 2)
//             if isset(f2) {
//                 f2(item)
//             }
//         }
//     }
// }

fn free_item(item: ptr) {
    let vti = @ptrv(item, u16, byte_vtable_index_rel)
    let func = @ptrv(gc_tables, fn(ptr)(), vti * GC_TABLE_SIZE + vt_free)
    func(item)
}

fn free[T](item: ptr) {
    let item_color = @ptrv(item, color_type, byte_color_rel)
    if item_color == color_blank : return
    if @ptrv(color_state, u8, item_color) == color_state_used : return
    
    @ptrv(item, color_type, byte_color_rel) = color_blank

    let index = @ptrv(item, u8, byte_block_index_rel) @as uint
    if index != 255 {
        let block = item - 8 - (index * size_of_pool(T)) - POOL_DATA_OFFSET
        @ptrv(block, uint, 2)-- // Reduce block items-used
        mem_marked -= @ptrv(block, uint, 4)
    }

    // Free properties
    #loop properties item, T as prop, type
    #if @is_gc_type(type)
    {
        #if @is_nullable_type(type)
        let p = prop @as ?ptr
        if isset(p) {
        #else
        let p = prop @as ptr
        #end
            free[notnull(type)](p)
        #if @is_nullable_type(type)
        }
        #end
    }
    #end
    #end

    #if @type_has_method(T, _gc_free_properties)
    (item @as T)._gc_free_properties()
    #end

    #if @type_has_method(T, _gc_free)
    if index != 255 {
        (item @as T)._gc_free()
    }
    #end
}

fn share_item_null_check(item: ?ptr) {
    if !isset(item) : return
    share_item(item)
}

// fn share(item: ptr) {
//     let mark = @ptrv(item, u8, byte_mark_rel)
//     let item_color = @ptrv(item, color_type, byte_color_rel)
//     if item_color == color_shared {
//         if mark & shared_mark != shared_mark {
//             @ptrv(item, u8, byte_mark_rel) = (mark & 249) | shared_mark
//         }
//         return
//     }
//     @ptrv(item, color_type, byte_color_rel) = color_shared
//     @ptrv(item, u8, byte_mark_rel) = (mark & 249) | shared_mark

//     if item_color == color_blank {
//         let offset = @ptrv(item, u16, -1) @as uint
//         if offset > 0 {
//             let block = item - offset - 8
//             @ptrv(block, uint, 2)++ // Increase block items-used
//             mem_marked += @ptrv(block, uint, 4)
//         }
//     }

//     let has_vtable = @ptrv(item, u8, byte_vtable_rel) == 1
//     let propc = @ptrv(item, u8, byte_propc_rel)
//     if propc > 0 {
//         // Mark properties
//         let prop_base = item + (has_vtable ? size_of_pool(ptr) : 0)
//         while propc-- > 0 {
//             let sub = @ptrv(prop_base, ?ptr, propc)
//             if isset(sub) {
//                 share(sub)
//             }
//         }
//     }

//     if has_vtable {
//         let vt = @ptrv(item, ptr, 0)
//         let func = @ptrv(vt, ?fn(ptr)(), 3)
//         if isset(func) {
//             func(item)
//         }
//     }
// }

fn share_item(item: ptr) {
    let vti = @ptrv(item, u16, byte_vtable_index_rel)
    let func = @ptrv(gc_tables, fn(ptr)(), vti * GC_TABLE_SIZE + vt_share)
    func(item)
}

fn share[T](item: ptr) {
    let mark = @ptrv(item, u8, byte_mark_rel)
    let item_color = @ptrv(item, color_type, byte_color_rel)
    if item_color == color_shared {
        if mark & shared_mark != shared_mark {
            @ptrv(item, u8, byte_mark_rel) = (mark & 243) | shared_mark
        }
        return
    }
    @ptrv(item, color_type, byte_color_rel) = color_shared
    @ptrv(item, u8, byte_mark_rel) = (mark & 243) | shared_mark

    if item_color == color_blank {
        let index = @ptrv(item, u8, byte_block_index_rel) @as uint
        if index != 255 {
            let block = item - 8 - (index * size_of_pool(T)) - POOL_DATA_OFFSET
            @ptrv(block, uint, 2)++ // Increase block items-used
            mem_marked += @ptrv(block, uint, 4)
        }
    }

    // Call _gc_share hook
    #if @type_has_method(T, _gc_share)
    (item @as T)._gc_share()
    #end

    // Share properties
    #loop properties item, T as prop, type
    #if @is_gc_type(type)
    {
        #if @is_nullable_type(type)
        let p = prop @as ?ptr
        if isset(p) {
        #else
        let p = prop @as ptr
        #end
            share[notnull(type)](p)
        #if @is_nullable_type(type)
        }
        #end
    }
    #end
    #end
}
