
use core

fn adjust_block(block: ptr, used: bool, gc: Gc) {
    if used {
        @ptrv(block, uint, 2)++
        gc.mem_marked += @ptrv(block, uint, 4)
    } else {
        @ptrv(block, uint, 2)--
        gc.mem_marked -= @ptrv(block, uint, 4)
    }
}

fn increase_block(item: ptr, gc: Gc) $hot {
    let data = (@offset(item, u8, -8)).@cast(GcData)
    let offset = data.block_offset
    if offset > 0 {
        let block = item - offset
        adjust_block(block, true, gc)
    }
}

fn mark_used(item: ?ptr) $hot {

    let _gc = gc
    let ml = _gc.mark_list
    if isset(item) : ml.add(item)

    while true {
        let item = ml.pop() ! break

        let data = (@offset(item, u8, -8)).@cast(GcData)
            // if data.is_still_co_owned() : panic("STILL COO (2)")
            if data.is_still_co_owned() : data.remove_still_co_owned()

        let state = data.state
        data.state = state_used

        // Increase block counter
        if state == state_new {
            // New item
            let offset = data.block_offset
            if offset > 0 {
                let block = item - offset
                adjust_block(block, true, _gc)
            }
        }

        // Props
        let has_vtable = data.has_vtable()
        let propc = data.propc
        if propc > 0 {
            // Mark properties
            let prop_base = item + size_of(ptr) * has_vtable.@cast(uint)
            while propc-- > 0 {
                let sub = @ptrv(prop_base, ?GcItem, propc)
                if isset(sub) && (sub & 3 == 0) {
                    let sub_data = sub.data()
                    if sub_data.state < state_used {
                        // Own
                        @ptrv(prop_base, ?ptr, propc) = sub | 1
                        if sub_data.state == state_new : increase_block(sub, _gc)
                        sub_data.state = state_used
                        // Mark sub properties
                        ml.add(sub)
                    } else {
                        // Co-own
                        @ptrv(prop_base, ?ptr, propc) = sub | 2
                        sub_data.co_own()
                    }
                }
            }
        }

        // Call hook gc_action
        if has_vtable {
            let vt = data.vtable
            let func = @ptrv(vt, ?fnRef(ptr, fnRef(ptr, ptr)())(), 0)
            if isset(func) {
                func(item, property_mark)
            }
        }
    }
}

// fn disconnect_rec(item: ptr) $hot {

//     let _gc = gc
//     let ml = _gc.mark_list
//     ml.add(item)

//     while true {
//         let item = ml.pop() ! break
//         let data = (@offset(item, u8, -8)).@cast(GcData)

//         let has_vtable = data.has_vtable()
//         let propc = data.propc
//         let offset = data.block_offset

//         if offset > 0 {
//             let block = item - offset
//             adjust_block(block, false, _gc)
//         }

//         data.state = state_new

//         // Props
//         if propc > 0 {
//             // Mark properties
//             let prop_base = item + size_of(ptr) * has_vtable.@cast(uint)
//             while propc-- > 0 {
//                 let sub = @ptrv(prop_base, ptr, propc)
//                 if sub & 1 == 1 {
//                     // Remove ownership
//                     let sub_item : GcItem = sub & -4.to(uint)
//                     @ptrv(prop_base, GcItem, propc) = sub_item

//                     let sub_data = sub_item.data()
//                     if sub_data.state < state_shared_unused {
//                         ml.add(sub_item)
//                     } else {
//                         sub_data.state--
//                     }
//                 } else if sub & 2 == 2 {
//                     // Remove co-ownership
//                     let sub_item : GcItem = sub & -4.to(uint)
//                     @ptrv(prop_base, GcItem, propc) = sub_item
//                     sub_item.data().dis_co_own()
//                 }
//             }
//         }

//         // Call hook gc_action
//         if has_vtable {
//             let vt = data.vtable
//             let func = @ptrv(vt, ?fnRef(ptr, fnRef(ptr, ptr)())(), 0)
//             if isset(func) {
//                 func(item, property_disconnect)
//             }

//             if !data.is_in_blanks() {
//                 data.set_in_blanks()
//                 let adr = _gc.blanks.get(size_of(ptr))
//                 @ptrv(adr, ptr) = item
//             }
//         }
//     }

//     return
// }

fn free_blank(item: ptr) $hot {
    let data = (@offset(item, u8, -8)).@cast(GcData)
    if data.state != state_new : return
    data.remove_has_vtable()
    let vt = data.vtable
    let func = @ptrv(vt, ?fnRef(ptr)(), 1)
    if isset(func) {
        func(item)
    }
}

fn share_null_check(item: ?ptr) {
    if !isset(item) : return
    share(item)
}

fn share(item: ptr) {

    let _gc = gc
    let ml = _gc.mark_list
    let i = ml.index
    ml.add(item)

    while true {
        if ml.index == i : break
        let item = ml.pop() ! break

        let data = (@offset(item, u8, -8)).@cast(GcData)
        if data.age == shared_mark : continue

        let state = data.state

        data.age = shared_mark

        if state < state_shared_unused {
            let is_new = state == state_new
            data.state = state + 2 + (is_new.@cast(u8))

            let offset = data.block_offset
            let block = item - offset

            _gc.shared_items.add_ptr(item)

            // Increase block counter
            if offset > 0 {
                atomic_op(mem_shared + @ptrv(block, uint, 4))
                if is_new {
                    @ptrv(block, uint, 2)++
                } else {
                    _gc.mem_marked -= @ptrv(block, uint, 4)
                }
            }
        }

        // Props
        let has_vtable = data.has_vtable()
        let propc = data.propc
        if propc > 0 {
            // Mark properties
            let prop_base = item + size_of(ptr) * has_vtable.@cast(uint)
            while propc-- > 0 {
                let sub = @ptrv(prop_base, ?GcItem, propc)
                if isset(sub) {
                    if sub & 3 == 3 : panic("IS3")
                    if sub & 1 == 1 {
                        // Remove all ownerships
                        sub = sub - 1
                        @ptrv(prop_base, ptr, propc) = sub
                        sub.data().state--
                    } else if sub & 2 == 2 {
                        // Remove all co-ownerships
                        sub = sub - 2
                        @ptrv(prop_base, ptr, propc) = sub
                        let sub_data = sub.data()
                        sub_data.remove_still_co_owned()
                        sub_data.dis_co_own()
                    }
                    ml.add(sub)
                }
            }
        }

        // Call hook gc_action
        if has_vtable {
            let vt = data.vtable
            let func = @ptrv(vt, ?fnRef(ptr, fnRef(ptr, ptr)())(), 0)
            if isset(func) {
                func(item, property_share)
            }
        }
    }

    if mem_shared > mem_shared_trigger && !mem_shared_running && mem_shared_trigger > 0 {
        collect_shared()
    }
}

fn remove_co_owners(item: ptr) {

    let _gc = gc
    let ml = _gc.mark_list
    ml.add(item)

    while true {
        let item = (ml.pop() ! break).@cast(GcItem)
        let data = item.data()

        if data.state > state_used : continue

        // Props
        let has_vtable = data.has_vtable()
        let propc = data.propc
        if propc > 0 {
            // Mark properties
            let prop_base = item + size_of(ptr) * has_vtable.@cast(uint)
            while propc-- > 0 {
                let sub = @ptrv(prop_base, ?GcItem, propc)
                if isset(sub) {
                    if sub & 3 == 3 : panic("IS3")
                    if sub & 1 == 1 {
                        ml.add(sub & -4.to(uint))
                    } else if sub & 2 == 2 {
                        sub = sub - 2
                        @ptrv(prop_base, ptr, propc) = sub
                        sub.data().dis_co_own()
                    }
                }
            }
        }

        // Call hook gc_action
        if has_vtable {
            let vt = data.vtable
            let func = @ptrv(vt, ?fnRef(ptr, fnRef(ptr, ptr)())(), 0)
            if isset(func) {
                func(item, property_remove_co_owners)
            }
        }
    }
}

fn check_co_owners(item: ptr) {

    let _gc = gc
    let ml = _gc.mark_list
    ml.add(item)

    while true {
        let item = (ml.pop() ! break).@cast(GcItem)
        let data = item.data()

        if data.state > state_used : continue
        if data.co_count > 0 {
            // Still has co owners
            data.set_still_co_owned()
            let adr = _gc.still_co_owned.get(size_of(ptr))
            @ptrv(adr, ptr) = item
            // State must become owned, even though nothing owns it
            // At some time, a co owner will be removed and because of the still_co_owned flag
            // the state will become dis_owned & it will be added to the dis_owned list
            // Which will cause this item to be in the 3 stages algorithm again and potentially cleared
            data.state = state_used
            continue
        }

        let offset = data.block_offset

        if offset > 0 {
            let block = item - offset
            adjust_block(block, false, _gc)
        }

        data.state = state_new

        // Props
        let has_vtable = data.has_vtable()
        let propc = data.propc
        if propc > 0 {
            // Mark properties
            let prop_base = item + size_of(ptr) * has_vtable.@cast(uint)
            while propc-- > 0 {
                let sub = @ptrv(prop_base, ?GcItem, propc)
                if isset(sub) {
                    if sub & 3 == 3 : panic("IS3")
                    if sub & 1 == 1 {
                        // Remove ownership
                        let sub_item : GcItem = sub & -4.to(uint)
                        @ptrv(prop_base, GcItem, propc) = sub_item

                        let sub_data = sub_item.data()
                        if sub_data.state < state_shared_unused {
                            ml.add(sub_item)
                        // } else {
                        }
                            sub_data.state--
                    }
                }
            }
        }

        // Call hook gc_action
        if has_vtable {
            let vt = data.vtable
            let func = @ptrv(vt, ?fnRef(ptr, fnRef(ptr, ptr)())(), 0)
            if isset(func) {
                func(item, property_check_co_owners)
            }

            if !data.is_in_blanks() {
                data.set_in_blanks()
                let adr = _gc.blanks.get(size_of(ptr))
                @ptrv(adr, ptr) = item
            }
        }
    }
}

fn retake_co_ownership(item: ?ptr) $hot {

    let _gc = gc
    let ml = _gc.mark_list
    if isset(item) : ml.add(item)

    while true {
        let item = ml.pop() ! break

        let data = (@offset(item, u8, -8)).@cast(GcData)
            // if data.is_still_co_owned() : panic("STILL COO (1)")

        // Props
        let has_vtable = data.has_vtable()
        let propc = data.propc
        if propc > 0 {
            // Mark properties
            let prop_base = item + size_of(ptr) * has_vtable.@cast(uint)
            while propc-- > 0 {
                let sub = @ptrv(prop_base, ?GcItem, propc)
                if isset(sub) {
                    if sub & 3 == 3 : panic("IS3")
                    if (sub & 1 == 1) {
                        ml.add(sub & -4.to(uint))
                    } else {
                        sub = sub & -4.to(uint)
                        let sub_data = sub.data()
                        if sub_data.state < state_used {
                            // Take ownership
                            @ptrv(prop_base, GcItem, propc) = sub | 1
                            mark_used(sub)
                        } else {
                            // Co own
                            @ptrv(prop_base, GcItem, propc) = sub | 2
                            sub_data.co_own()
                        }
                    }
                }
            }
        }

        // Call hook gc_action
        if has_vtable {
            let vt = data.vtable
            let func = @ptrv(vt, ?fnRef(ptr, fnRef(ptr, ptr)())(), 0)
            if isset(func) {
                func(item, property_retake_co_ownership)
            }
        }
    }
}