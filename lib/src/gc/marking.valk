

fn mark(item: ptr, color: color_type) {

    let item_color = @ptrv(item, color_type, byte_color_rel)
    if item_color == color : return
    if @ptrv(color_state, u8, item_color) == color_state_used {
        if item_color >= color_custom {
            color_disable_after = true
        }
        return
    }

    if item_color == color_blank {
        let offset = @ptrv(item, u16, -1) @as uint
        if offset > 0 {
            let block = item - offset - 8
            @ptrv(block, uint, 2)++ // Increase block items-used
            mem_marked += @ptrv(block, uint, 4)
        }
    }

    @ptrv(item, color_type, byte_color_rel) = color

    // 
    let has_vtable = @ptrv(item, u8, byte_vtable_rel) == 1
    let propc = @ptrv(item, u8, byte_propc_rel)
    if propc > 0 {
        // Mark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) {
                mark(sub, color)
            }
        }
    }

    if has_vtable {
        let vt = @ptrv(item, ptr, 0)
        let func = @ptrv(vt, ?fn(ptr, color_type)(), 0)
        if isset(func) {
            func(item, color)
        }
    }
}

fn free_blank(item: ptr) {
    if @ptrv(item, color_type, byte_color_rel) != color_blank : return
    @ptrv(item, u8, byte_vtable_rel) = 0
    let vt = @ptrv(item, ptr, 0)
    let func = @ptrv(vt, ?fn(ptr)(), 2)
    if isset(func) {
        func(item)
    }
}

fn free_item_rec(item: ptr) {
    let item_color = @ptrv(item, color_type, byte_color_rel)
    if item_color == color_blank : return
    if @ptrv(color_state, u8, item_color) == color_state_used : return
    
    @ptrv(item, color_type, byte_color_rel) = color_blank

    let offset = @ptrv(item, u16, -1) @as uint
    if offset > 0 {
        let block = item - offset - 8
        @ptrv(block, uint, 2)-- // Reduce block items-used
        mem_marked -= @ptrv(block, uint, 4)
    }

    let has_vtable = @ptrv(item, u8, byte_vtable_rel) == 1
    let propc = @ptrv(item, u8, byte_propc_rel)
    if propc > 0 {
        // Mark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) {
                free_item_rec(sub)
            }
        }
    }

    if has_vtable {
        @ptrv(item, u8, byte_vtable_rel) = 0

        let vt = @ptrv(item, ptr, 0)

        // _gc_free_properties
        let f1 = @ptrv(vt, ?fn(ptr)(), 1)
        if isset(f1) {
            f1(item)
        }

        if offset > 0 {
            // _gc_free
            let f2 = @ptrv(vt, ?fn(ptr)(), 2)
            if isset(f2) {
                f2(item)
            }
        }
    }
}

fn share(item: ptr) {

    if @ptrv(item, color_type, byte_color_rel) == color_shared : return
    @ptrv(item, color_type, byte_color_rel) = color_shared

    let has_vtable = @ptrv(item, u8, byte_vtable_rel) == 1
    let propc = @ptrv(item, u8, byte_propc_rel)
    if propc > 0 {
        // Mark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) {
                share(sub)
            }
        }
    }

    if has_vtable {
        let vt = @ptrv(item, ptr, 0)
        let func = @ptrv(vt, ?fn(ptr)(), 3)
        if isset(func) {
            func(item)
        }
    }
}
