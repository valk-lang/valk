
fn mark_used(item: ptr) bool $hot {

    let data = (@ptr_offset(item, -8)) @as GcData

    let state = data.state
    if state > state_unused {
        // if from_stack && data.on_stack == 0 {
        //     data.on_stack = 1
        //     let adr = stack_hits.get(sizeof(ptr))
        //     @ptrv(adr, ptr) = item
        // }
        return false
    }
    data.state = state_used

    // Increase block counter
    if state == state_new {
        // New item
        let offset = data.block_offset
        if offset > 0 {
            let block = item - offset
            @ptrv(block, uint, 2)++ // Increase block items-used
            mem_marked += @ptrv(block, uint, 4)
        }
    }

    // Props
    let has_vtable = data.has_vtable == 1
    let propc = data.propc
    if propc > 0 {
        // Mark properties
        let reconnect = false
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) && (sub & 1 == 0) {
                if mark_used(sub) {
                    // Main pipe line
                    @ptrv(prop_base, ?ptr, propc) = sub | 1
                } else {
                    // Already connected to a pipe
                    // Add to reconnect_list
                    reconnect = true
                }
            }
        }
        if reconnect {
            let in_list = data.in_list
            if in_list & in_list_reconnect == 0 {
                data.in_list = in_list | in_list_reconnect
                let adr = reconnect_list.get(sizeof(ptr))
                @ptrv(adr, ptr) = item
            }
        }
    }

    // Call hook _gc_mark
    if has_vtable {
        let vt = data.vtable
        let func = @ptrv(vt, ?fn(ptr)(), 0)
        if isset(func) {
            func(item)
        }
    }

    return true
}

fn disconnect_rec(item: ptr) $hot {

    let data = (@ptr_offset(item, -8)) @as GcData

    if data.on_stack == 1 : return
    data.state = state_unused

    // Props
    let has_vtable = data.has_vtable == 1
    let propc = data.propc
    if propc > 0 {
        // Mark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ptr, propc)
            if sub & 1 == 1 {
                let sub_item : ptr = sub & -2
                @ptrv(prop_base, ?ptr, propc) = sub_item
                disconnect_rec(sub_item)
            }
        }
    }

    // Call hook _gc_mark
    if has_vtable {
        let vt = data.vtable
        let func = @ptrv(vt, ?fn(ptr)(), 1)
        if isset(func) {
            func(item)
        }
    }

    return
}

fn free_blank(item: ptr) $hot {
    let data = (@ptr_offset(item, -8)) @as GcData
    if data.state != state_new : return
    let vt = data.vtable
    let func = @ptrv(vt, ?fn(ptr)(), 2)
    if isset(func) {
        func(item)
    }
}

fn free_disconnect_rec(item: ptr) $hot {

    let data = (@ptr_offset(item, -8)) @as GcData
    if data.state != state_unused : return

    // Load data before clear
    let propc = data.propc
    let has_vtable = data.has_vtable == 1

    // Clear data
    @ptrv(data, u32) = 0

    let offset = data.block_offset
    if offset > 0 {
        let block = item - offset
        @ptrv(block, uint, 2)-- // Reduce block items-used
        mem_marked -= @ptrv(block, uint, 4)
    }

    if propc > 0 {
        // Mark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) {
                free_disconnect_rec(sub)
            }
        }
    }

    if has_vtable {
        let vt = data.vtable

        // _gc_free_properties
        let f1 = @ptrv(vt, ?fn(ptr)(), 2)
        if isset(f1) {
            f1(item)
        }

        if offset > 0 {
            // _gc_free
            let f2 = @ptrv(vt, ?fn(ptr)(), 3)
            if isset(f2) {
                f2(item)
            }
        }
    }
}

fn share_null_check(item: ?ptr) {
    if !isset(item) : return
    share(item)
}

fn share(item: ptr) {
    return

    // let data = (@ptr_offset(item, -8)) @as GcData
    // let item_color = data.color
    // let mark_ = data.mark

    // if item_color == color_shared {
    //     if mark_ & shared_mark != shared_mark {
    //         data.mark = (mark_ & 249) | shared_mark
    //     }
    //     return
    // }

    // data.color = color_shared
    // data.mark = (mark_ & 249) | shared_mark

    // if item_color == color_blank {
    //     let offset = data.block_offset
    //     if offset > 0 {
    //         let block = item - offset
    //         @ptrv(block, uint, 2)++ // Increase block items-used
    //         mem_marked += @ptrv(block, uint, 4)
    //     }
    // }

    // let has_vtable = (mark_ & mark_bit_has_vtable) != 0
    // let propc = data.propc
    // if propc > 0 {
    //     // Mark properties
    //     let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
    //     while propc-- > 0 {
    //         let sub = @ptrv(prop_base, ?ptr, propc)
    //         if isset(sub) {
    //             share(sub)
    //         }
    //     }
    // }

    // if has_vtable {
    //     let vt = data.vtable
    //     let func = @ptrv(vt, ?fn(ptr)(), 4)
    //     if isset(func) {
    //         func(item)
    //     }
    // }
}
