
global mark_list : Lifo (@undefined)

fn mark_used(item: ptr) $hot {

    let ml = mark_list
    ml.add(item)

    while true {
        let item = ml.pop() ! break

        let data = (@ptr_offset(item, -8)) @as GcData

        let state = data.state
        data.state = state_used

        // Increase block counter
        if state == state_new {
            // New item
            let offset = data.block_offset
            if offset > 0 {
                let block = item - offset
                @ptrv(block, uint, 2)++ // Increase block items-used
                mem_marked += @ptrv(block, uint, 4)
            }
        }

        // Props
        let has_vtable = data.has_vtable == 1
        let propc = data.propc
        if propc > 0 {
            // Mark properties
            let reconnect = false
            let prop_base = item + sizeof(ptr) * has_vtable @as uint
            while propc-- > 0 {
                let sub = @ptrv(prop_base, ?ptr, propc)
                if isset(sub) && (sub & 1 == 0) {
                    let sub_data = (@ptr_offset(sub, -8)) @as GcData
                    if sub_data.state < state_used {
                        // Connect
                        @ptrv(prop_base, ?ptr, propc) = sub | 1
                        ml.add(sub)
                    } else {
                        // If already connected or is shared
                        // Add to reconnect_list
                        reconnect = true
                    }
                }
            }
            if reconnect {
                let in_list = data.in_list
                if in_list & in_list_reconnect == 0 {
                    data.in_list = in_list | in_list_reconnect
                    let adr = reconnect_list.get(sizeof(ptr))
                    @ptrv(adr, ptr) = item
                }
            }
        }

        // Call hook _gc_mark
        if has_vtable {
            let vt = data.vtable
            let func = @ptrv(vt, ?fn(ptr)(), 0)
            if isset(func) {
                func(item)
            }
        }
    }
}

fn disconnect_rec(item: ptr) $hot {

    let ml = mark_list
    ml.add(item)

    while true {
        let item = ml.pop() ! break
        let data = (@ptr_offset(item, -8)) @as GcData

        // Props
        let has_vtable = data.has_vtable == 1
        let propc = data.propc
        if propc > 0 {
            // Mark properties
            let prop_base = item + sizeof(ptr) * has_vtable @as uint
            while propc-- > 0 {
                let sub = @ptrv(prop_base, ptr, propc)
                if sub & 1 == 1 {
                    let sub_item : ptr = sub & -2
                    @ptrv(prop_base, ?ptr, propc) = sub_item

                    let sub_data = (@ptr_offset(sub_item, -8)) @as GcData
                    sub_data.state--

                    ml.add(sub_item)
                }
            }
        }

        // Call hook _gc_disconnect
        if has_vtable {
            let vt = data.vtable
            let func = @ptrv(vt, ?fn(ptr)(), 1)
            if isset(func) {
                func(item)
            }
        }
    }

    return
}

fn free_blank(item: ptr) $hot {
    let data = (@ptr_offset(item, -8)) @as GcData
    if data.state != state_new : return
    let vt = data.vtable
    let func = @ptrv(vt, ?fn(ptr)(), 3)
    if isset(func) {
        func(item)
    }
}

fn free_disconnect_rec(item: ptr) $hot {

    let ml = mark_list
    ml.add(item)

    while true {
        let item = ml.pop() ! break

        let data = (@ptr_offset(item, -8)) @as GcData
        if data.state != state_unused : continue

        // Load data before clear
        let propc = data.propc
        let has_vtable = data.has_vtable == 1

        // Clear data
        @ptrv(data, u32) = 0

        let offset = data.block_offset
        if offset > 0 {
            let block = item - offset
            @ptrv(block, uint, 2)-- // Reduce block items-used
            mem_marked -= @ptrv(block, uint, 4)
        }

        if propc > 0 {
            // Mark properties
            let prop_base = item + sizeof(ptr) * has_vtable @as uint
            while propc-- > 0 {
                let sub = @ptrv(prop_base, ?ptr, propc)
                if isset(sub) {
                    ml.add(sub)
                }
            }
        }

        if has_vtable {
            let vt = data.vtable

            // _gc_free_properties
            let f1 = @ptrv(vt, ?fn(ptr)(), 2)
            if isset(f1) {
                f1(item)
            }

            if offset > 0 {
                // _gc_free
                let f2 = @ptrv(vt, ?fn(ptr)(), 3)
                if isset(f2) {
                    f2(item)
                }
            }
        }
    }
}

fn share_null_check(item: ?ptr) {
    if !isset(item) : return
    share(item)
}

fn share(item: ptr) {

    let ml = mark_list
    ml.add(item)

    while true {
        let item = ml.pop() ! break

        let data = (@ptr_offset(item, -8)) @as GcData
        if data.age == shared_mark : continue

        let state = data.state
        data.age = shared_mark

        if state < state_shared_unused {
            let is_new = state == state_new
            data.state = state + 2 + (1 * is_new @as u8)

            shared_items.add_ptr(item)

            // Increase block counter
            if is_new {
                // New item
                let offset = data.block_offset
                if offset > 0 {
                    let block = item - offset
                    @ptrv(block, uint, 2)++ // Increase block items-used
                    mem_marked += @ptrv(block, uint, 4)
                }
            }
        }

        // Props
        let has_vtable = data.has_vtable == 1
        let propc = data.propc
        if propc > 0 {
            // Mark properties
            let prop_base = item + sizeof(ptr) * has_vtable @as uint
            while propc-- > 0 {
                let sub = @ptrv(prop_base, ?ptr, propc)
                if isset(sub) {
                    ml.add(sub & -2)
                }
            }
        }

        // Call hook _gc_mark
        if has_vtable {
            let vt = data.vtable
            let func = @ptrv(vt, ?fn(ptr)(), 4)
            if isset(func) {
                func(item)
            }
        }
    }
}
