
use core

fn increase_block(block: ptr) $inline {
    @ptrv(block, uint, 2)++
    gc.mem_marked += @ptrv(block, uint, 4)
}
fn decrease_block(block: ptr) $inline {
    @ptrv(block, uint, 2)--
    gc.mem_marked -= @ptrv(block, uint, 4)
}

// fn increase_block_of_item(item: ptr) {
//     let data = (item.$offset(-8)).@cast(GcData)
//     let offset = data.block_offset & offmask
//     if offset > 0 {
//         let block = item - offset
//         increase_block(block)
//     }
// }

// fn decrease_block_of_item(item: ptr) {
//     let data = (item.$offset(-8)).@cast(GcData)
//     let offset = data.block_offset & offmask
//     if offset > 0 {
//         let block = item - offset
//         decrease_block(block)
//     }
// }

fn mark_used(item: ?GcItem) $hot {

    let ml = gc.mark_list
    let pl = gc.prop_list
    if isset(item) : ml.add(item)

    while true {
        let item = ml.pop() ! break
        let data = gcdata(item)
        let block = data.block()

        // if data.block_index != 0xFF {
        //     let block = data.block(info)
        //     if data.is_new() : increase_block(block)
            block.slots_used++
            gc.mem_marked += block.isize
            // else if data.has_leak_mark() {
            //     data.remove_leak_mark()
            //     increase_block(block)
            // }
        // }
        #if GC_DEBUG
        // if data.is_shared() : panic("Setting shared item to owned state")
        if data.is_still_co_owned() : panic("double ownership")
        #end
        data.set_owned()

        let pf = block.props
        if isset(pf) : pf(item, pl.@cast(.))
        
        while true {
            let ref = pl.pop() ! break
            let sub = @ptrv(ref, ?ptr)
            if !isset(sub) : continue
            if sub & prop_mask == 0 {
                let sub_data = gcdata(sub)
                if sub_data.is_not_owned_not_shared() {
                    @ptrv(ref, ptr) = sub | prop_owned
                    // if sub_data.block_index != 0xFF && sub_data.is_new() : sub_data.set_leak_mark()
                    let sub_block = sub_data.block()
                    sub_block.slots_used++
                    gc.mem_marked += sub_block.isize
                    // if sub_data.block_index != 0xFF && sub_data.is_new() {
                    //     let block = sub_data.block(sub_data.type_info())
                    //     increase_block(block)
                    // }
                    sub_data.set_owned()
                    ml.add(sub)
                } else {
                    @ptrv(ref, ptr) = sub | prop_co_owned
                    sub_data.co_own()
                }
            }
        }

        // Props
        // let has_vtable = data.has_vtable()
        // let propc = data.propc
        // if propc > 0 {
        //     let prop_base : ptr[?GcItem] = item + size_of(ptr) * has_vtable.@cast(uint)
        //     // Mark properties
        //     while propc-- > 0 {
        //         let sub = prop_base[propc]
        //         if isset(sub) && (sub & prop_mask == 0) {
        //             let sub_data = gcdata(sub)
        //             if sub_data.is_not_owned_not_shared() {
        //                 // Own
        //                 @ptrv(prop_base, ?ptr, propc) = sub | prop_owned
        //                 if sub_data.is_new() : increase_block_of_item(sub)
        //                 sub_data.set_owned()
        //                 // Mark sub properties
        //                 ml.add(sub)
        //             } else {
        //                 // Co-own
        //                 @ptrv(prop_base, ?ptr, propc) = sub | prop_co_owned
        //                 sub_data.co_own()
        //             }
        //         }
        //     }
        // }

        // // Call hook gc_action
        // if has_vtable {
        //     let func = @ptrv(data.vtable, ?fnptr(ptr, fnptr(ptr, ptr)())(), 0)
        //     if isset(func) : func(item, property_mark)
        // }
    }
}

fn free_blank(item: ptr) $hot {
    let data = gcdata(item)
    if data.is_not_new() : return

    // Call gc_free
    let block = data.block()
    let onfree = block.onfree
    if isset(onfree) : onfree(item)

    // let func = @ptrv(data.vtable, ?fnptr(ptr)(), 1)
    // if isset(func) : func(item)
    // data.remove_has_vtable()

    #if GC_DEBUG
    if data.co_count != 0 : panic("co_count not 0 before free")
    if data.flags != 0 {
        print("Flags: ")
        data.flags.print(10)
        print("\n")
        panic("GC error: Flags not 0 before free")
    }
    #end
}

fn dis_own_rec(item: ptr) {

    let ml = gc.mark_list
    let pl = gc.prop_list
    ml.add(item)

    while true {
        let item = (ml.pop() ! break).@cast(GcItem)
        let data = gcdata(item)

        #if GC_DEBUG
        if data.is_shared() : panic("removing ownership from shared item")
        if data.is_new() : panic("double ownership removal")
        if data.is_still_co_owned() : panic("unexpected ownership removal")
        #end

        if data.is_on_stack() {
            gc.prev_stack_items.add_ptr(item)
            continue
        }

        let block = data.block()
        // if data.block_index != 0xFF {
            // let block = data.block(info)
            // decrease_block(block)
            block.slots_used--
            gc.mem_marked -= block.isize
        // }

        gc.dis_own_count++
        data.set_new()
        if data.co_count > 0 : gc.re_own_list.add_ptr(item)

        // Props
        let pf = block.props
        if isset(pf) : pf(item, pl.@cast(.))
        
        while true {
            let ref = pl.pop() ! break
            let sub = @ptrv(ref, ?ptr)
            if !isset(sub) : continue
            if sub & prop_owned == prop_owned {
                let sub_item = sub - prop_owned
                @ptrv(ref, ptr) = sub_item
                let sub_data = gcdata(sub_item)
                sub_data.set_no_owner()
                if sub_data.is_shared() : continue
                ml.add(sub_item)
            } else if sub & prop_co_owned == prop_co_owned {
                let sub_item = sub - prop_co_owned
                @ptrv(ref, ptr) = sub_item
                let sub_data = gcdata(sub_item)
                atomic(sub_data.co_count - 1)
                if sub_data.is_still_co_owned() {
                    sub_data.remove_still_co_owned()
                    // Lets pretend we were the owner
                    ml.add(sub_item)
                }
            }
        }

        let onfree = block.onfree
        if isset(onfree) : gc.blanks.add_ptr(item)

        // Props
        // let has_vtable = data.has_vtable()
        // let propc = data.propc
        // if propc > 0 {
        //     // Mark properties
        //     let prop_base = item + size_of(ptr) * has_vtable.@cast(uint)
        //     while propc-- > 0 {
        //         let sub = @ptrv(prop_base, ?GcItem, propc)
        //         if isset(sub) {
        //             if sub & prop_owned == prop_owned {
        //                 sub = sub - prop_owned
        //                 @ptrv(prop_base, ptr, propc) = sub
        //                 let data = gcdata(sub)
        //                 data.set_no_owner()
        //                 if data.is_shared() : continue
        //                 ml.add(sub)
        //             } else if sub & prop_co_owned == prop_co_owned {
        //                 sub = sub - prop_co_owned
        //                 @ptrv(prop_base, ptr, propc) = sub
        //                 let data = gcdata(sub)
        //                 // data.dis_co_own()
        //                 atomic(data.co_count - 1)
        //                 if data.is_still_co_owned() {
        //                     data.remove_still_co_owned()
        //                     // Lets pretend we were the owner
        //                     ml.add(sub)
        //                 }
        //             }
        //         }
        //     }
        // }

        // Call hook gc_action
        // if has_vtable {
        //     let func = @ptrv(data.vtable, ?fnptr(ptr, fnptr(ptr, ptr)())(), 0)
        //     if isset(func) : func(item, property_dis_own)
        //     if !data.is_in_blanks() {
        //         data.set_in_blanks()
        //         gc.blanks.add_ptr(item)
        //     }
        // }
    }
}


fn share_null_check(item: ?ptr) {
    if isset(item) {
        share(item)
    }
}

fn share(item: GcItem) {
    let ds = gc.dont_stop
    gc.dont_stop = true

    let ml = gc.mark_list
    let pl = gc.prop_list
    let start = ml.index
    ml.add(item)

    while true {
        if ml.index == start : break
        let item = (ml.pop() ! break).@cast(GcItem)
        let data = gcdata(item)

        if data.is_shared() : continue
        data.set_shared()
        data.set_mark()

        let is_new = data.is_new()
        if is_new : data.set_no_owner()
        else if data.is_still_co_owned() {
            data.remove_still_co_owned()
            data.set_no_owner()
        }

        gc.shared_items.add_ptr(item)

        let block = data.block()
        let x = block.props.@cast(ptr)
        print(">")
        item.@cast(ptr).print()
        print(".")
        data.offset.print(10)
        print(".")
        x.print()
        print("<\n")
        // if data.block_index != 0xFF {
            let size = block.isize
            if is_new {
                block.slots_used++
            } else {
                gc.mem_marked -= size
            }
            // Increase mem shared
            atomic(mem_shared + size)
        // }

        // Props
        let pf = block.props
        if isset(pf) : pf(item, pl.@cast(.))
        
        while true {
            let ref = pl.pop() ! break
            let sub = @ptrv(ref, ?ptr)
            if !isset(sub) : continue
            let sub_item : GcItem = sub & -4.to(uint)
            let sub_data = gcdata(sub_item)
            if sub & prop_owned == prop_owned {
                // Remove ownership
                @ptrv(ref, ?GcItem) = sub_item
                sub_data.set_no_owner()
            } else if sub & prop_co_owned == prop_co_owned {
                // Remove co ownership
                @ptrv(ref, ?GcItem) = sub_item
                atomic(sub_data.co_count - 1)
            }

            ml.add(sub_item)
        }


        // let has_vtable = data.has_vtable()
        // let propc = data.propc
        // if propc > 0 {
        //     // Mark properties
        //     let prop_base = item + size_of(ptr) * has_vtable.@cast(uint)
        //     while propc-- > 0 {
        //         let sub = @ptrv(prop_base, ?GcItem, propc)
        //         if isset(sub) {
        //             let sub_item : GcItem = sub & -4.to(uint)

        //             let sub_data = gcdata(sub_item)
        //             if sub & prop_owned == prop_owned {
        //                 // Remove ownership
        //                 @ptrv(prop_base, ?GcItem, propc) = sub_item
        //                 sub_data.set_no_owner()
        //             } else if sub & prop_co_owned == prop_co_owned {
        //                 // Remove co ownership
        //                 @ptrv(prop_base, ?GcItem, propc) = sub_item
        //                 // sub_data.dis_co_own()
        //                 atomic(sub_data.co_count - 1)
        //             }

        //             ml.add(sub_item)
        //         }
        //     }
        // }

        // // Call hook gc_action
        // if has_vtable {
        //     let vt = data.vtable
        //     let func = @ptrv(vt, ?fnptr(ptr, fnptr(ptr, ptr)())(), 0)
        //     if isset(func) : func(item, property_share)
        // }
    }

    gc.dont_stop = ds
}

fn update_mark(item: GcItem) {

    let ml = gc.mark_list
    let pl = gc.prop_list
    ml.add(item)

    while true {
        let item = (ml.pop() ! break).@cast(GcItem)
        let data = gcdata(item)

        if data.is_marked() : continue 
        data.set_mark()

        // Props
        let block = data.block()
        let pf = block.props
        if isset(pf) : pf(item, pl.@cast(.))
        
        while true {
            let ref = pl.pop() ! break
            let sub = @ptrv(ref, ?ptr)
            if !isset(sub) : continue
            let sub_item : GcItem = sub & -4.to(uint)
            let sub_data = gcdata(sub_item)
            if sub_data.is_marked() : continue 
            ml.add(sub_item)
        }

        // let has_vtable = data.has_vtable()
        // let propc = data.propc
        // if propc > 0 {
        //     // Mark properties
        //     let prop_base = item + size_of(ptr) * has_vtable.@cast(uint)
        //     while propc-- > 0 {
        //         let sub = @ptrv(prop_base, ?GcItem, propc)
        //         if isset(sub) {
        //             let item : GcItem = sub & -4.to(uint)
        //             let data = gcdata(item)
        //             if data.is_marked() : continue 
        //             ml.add(item)
        //         }
        //     }
        // }

        // // Call hook gc_action
        // if has_vtable {
        //     let vt = data.vtable
        //     let func = @ptrv(vt, ?fnptr(ptr, fnptr(ptr, ptr)())(), 0)
        //     if isset(func) {
        //         func(item, property_update_mark)
        //     }
        // }
    }
}

fn mark_leak_rec(item: GcItem, on: bool) {

    let ml = gc.mark_list
    let pl = gc.prop_list
    ml.add(item)

    while true {
        let item = (ml.pop() ! break).@cast(GcItem)
        let data = gcdata(item)
        if data.is_shared() : continue
        if on {
            if data.has_leak_mark() : continue 
            data.set_leak_mark()
        } else {
            if !data.has_leak_mark() : continue 
            data.remove_leak_mark()
        }

        // Props
        let block = data.block()
        let pf = block.props
        if isset(pf) : pf(item, pl.@cast(.))
        
        while true {
            let ref = pl.pop() ! break
            let sub = @ptrv(ref, ?ptr)
            if !isset(sub) : continue
            let sub_item : ptr = sub & -4.to(uint)
            if sub_item < 100 {
                println("item <= 255 : " + sub.@cast(uint) + " | on-type: " + data.offset)
                core:raise(11)
            }
            ml.add(sub_item)
        }

        // let has_vtable = data.has_vtable()
        // let propc = data.propc
        // if propc > 0 {
        //     // Mark properties
        //     let prop_base = item + size_of(ptr) * has_vtable.@cast(uint)
        //     while propc-- > 0 {
        //         let sub = @ptrv(prop_base, ?GcItem, propc)
        //         if isset(sub) {
        //             let item : GcItem = sub & -4.to(uint)
        //             ml.add(item)
        //         }
        //     }
        // }

        // // Call hook gc_action
        // if has_vtable {
        //     let func = @ptrv(data.vtable, ?fnptr(ptr, fnptr(ptr, ptr)())(), 0)
        //     if isset(func) : func(item, property_add_mark_list)
        // }
    }
}
