

fn mark(item: ptr, age: u8) {

    let iage = @ptrv(item, u8, byte_mark_rel)
    if iage == age : return
    // if @ptrv(item, u8, byte_mark_rel) == age : return

    @ptrv(item, u8, byte_mark_rel) = age

    // 
    let has_vtable = (@ptrv(item, u8, byte_settings_rel) & 1) == 1
    let propc = @ptrv(item, u8, byte_propc_rel)
    if propc > 0 {
        // Mark properties
        let prop_base = item + (has_vtable ? sizeof(ptr) : 0)
        while propc-- > 0 {
            let sub = @ptrv(prop_base, ?ptr, propc)
            if isset(sub) {
                mark(sub, age)
            }
        }
    }

    if has_vtable {
        let vt = @ptrv(item, ptr, 0)
        let func = @ptrv(vt, ?fn(ptr, u8)(), 0)
        if isset(func) {
            func(item, age)
        }
    }
}

global acount : uint (0)
global fcount : uint (0)

fn free_item(item: ptr) {
    // fcount++
    let has_vtable = (@ptrv(item, u8, byte_settings_rel) & 1) == 1
    @ptrv(item, u8, byte_box_rel) = BOX_DEFAULT

    let offset = @ptrv(item, u16, -1) @as uint
    let block = item - offset - 8
    @ptrv(block, uint, 2)-- // Reduce block items-used
    mem_new -= @ptrv(block, uint, 4)

    if has_vtable {
        let vt = @ptrv(item, ptr, 0)
        let func = @ptrv(vt, ?fn(ptr)(), 2)
        if isset(func) {
            func(item)
        }
    }
}

fn share(item: ptr) {
    @ptrv(item, u8, byte_mark_rel) = FROZEN
}
