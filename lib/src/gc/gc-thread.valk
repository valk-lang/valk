
use core
use coro

@shared gc : Gc (@undefined)
@shared lock: core:Mutex[void] (@undefined)
//
global thread: GcThread (@undefined)
@shared threads: Array[GcThread] (@undefined)
//
shared running : bool (false)
@shared runner_thread : ?GcThread (null)

global stack_root : [20_000 x ptr]
global stack_top : ptr (@undefined)
global stack_backup : [10_000 x ptr]
global stack_backup_size : uint

fn thread_init(is_main: bool (false)) {

    pools_init()
    //
    let t = GcThread.init()
    //
    if is_main {
        gc = Gc.init()
        lock = core:Mutex[void].new()
        threads = Array[GcThread].new()
    }
        print("CREATED\n")
    //
    thread.lock()
    lock.lock()
    threads.push(t)
    lock.unlock()
}

fn thread_stop() {
    thread.unlock()
    lock.lock()
    threads.remove_value(thread)
    thread.stop()
    lock.unlock()
}

class GcThread {
    mutex: core:Mutex[void] (core:Mutex[void].new()) $lazy
    locked: bool (false)
    //
    globals: Bump (Bump.new())
    updated_list: Bump (Bump.new())
    blanks: Bump (Bump.new())
    // Stacks
    stack_root: ptr (stack_root)
    stack_top_ptr: ptr[1 x ptr] (@ref(stack_top))
    stack_backup: ptr (stack_backup)
    stack_backup_size_ptr: ptr[1 x ptr] (@ref(stack_backup_size))
    coros_ptr: ptr[Array[?coro:Coro]] (@ref(coro:g_coros))

    static fn init() SELF {
        let t = SELF {}
        thread = t
        return t
    }

    fn lock() {
        this.mutex.lock()
        this.locked = true
    }
    fn unlock() {
        this.locked = false
        this.mutex.unlock()
    }

    fn stop() {
        this.globals.free()
        this.updated_list.free()
        this.blanks.free()
    }
}
