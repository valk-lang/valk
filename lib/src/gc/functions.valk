
fn mark[T](item: ptr, color: u16) {

    let b = @ptrv(vtable, ptr, 2)
    let item_ptr = item @as ptr
    let item_color = @ptrv(item_ptr, u16, byte_color_rel)
    if color >= color_const : return
    if @ptrv(colors.state, u8, item_color) == color_state_used : return

    @ptrv(item_ptr, u16, byte_color_rel) = color

    if item_color == color_blank {
        let size : uint = sizeof(<T>) + 8
        mem_marked += size

        let block_index = @ptrv(item_ptr, u8, byte_block_index_rel)
        let block_start = item_ptr - 8 - block_index * size
        @ptrv(block_start, uint, -2)++ // Increase used items count
    }

    let added = false
    #loop properties item, T as prop, type
    #if @is_gc_type(type)
    {
        // let p = prop
        #if @is_nullable_type(type)
        let p = prop @as ?ptr
        if isset(p) {
        #else
        let p = prop @as ptr
        #end
            mark[type](p, color)
            // Check if linked to another color
            if !added {
                let prop_ptr = p @as ptr
                let prop_color = @ptrv(prop_ptr, u16, byte_color_rel)
                if prop_color != color {
                    // Add to remark list
                    let adr = remark_list.get(sizeof(ptr))
                    @ptrv(adr, ptr) = item_ptr
                    added = true
                }
            }
        #if @is_nullable_type(type)
        }
        #end
    }
    #end
    #end

    // Call _gc_mark hook
    #if @type_has_method(T, _gc_mark)
    (item @as T)._gc_mark(color)
    #end
}

fn demark[T](item: ptr, color: u16) {

    let item_ptr = item @as ptr
    
    if @ptrv(item_ptr, u16, byte_color_rel) != color : return
    @ptrv(item_ptr, u16, byte_color_rel) = color_blank

    let size : uint = sizeof(<T>) + 8
    mem_marked -= size

    let block_index = @ptrv(item_ptr, u8, byte_block_index_rel)
    let block_start = item_ptr - 8 - block_index * size
    @ptrv(block_start, uint, -2)-- // Increase used items count

    #loop properties item, T as prop, type
    #if @is_gc_type(type)
    {
        #if @is_nullable_type(type)
        let p = prop @as ?ptr
        if isset(p) {
        #else
        let p = prop @as ptr
        #end
            demark[type](p, color)
        #if @is_nullable_type(type)
        }
        #end
    }
    #end
    #end

    // Call _gc_free
    #if @type_has_method(T, _gc_free)
    (item @as T)._gc_free()
    #end
}


fn link(on: ptr, to: ptr) {
    let on_color = @ptrv(on, u16, byte_color_rel)
    let to_color = @ptrv(to, u16, byte_color_rel)

    if on_color != to_color {
        if on_color == color_shared {
            if to_color != color_shared {
                // Mark shared
                // TODO
            }
        } else {
            // Add on-item to remark list
            let adr = remark_list.get(sizeof(ptr))
            @ptrv(adr, ptr) = on
        }
    }
}

fn unlink(from: ptr, item: ptr) {
    // println("UNLINK")
    let from_color = @ptrv(from, u16, byte_color_rel)
    let item_color = @ptrv(item, u16, byte_color_rel)
    if from_color == item_color && item_color != color_unlink {
        @ptrv(colors.state, u8, item_color) = color_state_unlinked
        @ptrv(item, u16, byte_color_rel) = color_unlink

        let list = check_still_used
        let adr = list.get(sizeof(ptr) * 2)
        @ptrv(adr, ptr) = item
        @ptrv(adr, uint, 1) = item_color
    }
}
