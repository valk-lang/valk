
fn mark[T](item: T, color: u16) {

    let item_ptr = item @as ptr
    let item_color = @ptrv(item_ptr, u16, byte_color_rel)
    if @ptrv(colors.state, u8, item_color) == color_state_used { 
        return
    }

    @ptrv(item_ptr, u16, byte_color_rel) = color

    if item_color == color_blank {
        let size : uint = sizeof(<T>) + 8
        mem_marked += size

        let block_index = @ptrv(item_ptr, u8, byte_block_index_rel) & 127
        let block_start = item_ptr - 8 - block_index * size
        @ptrv(block_start, uint, -2)++ // Increase used items count
    }

    // let added = false
    // #loop_object_properties item as prop, type
    // #if @type_is_gc(type)
    // {
    //     let p = prop
    //     #if @type_is_nullable(type)
    //     if isset(p) {
    //     #end
    //         gc_mark[typeof(p)](p, color)
    //         // Check if linked to another color
    //         if !added {
    //             let prop_ptr = p @as ptr
    //             let prop_color = @ptrv(prop_ptr, u16, byte_color_rel)
    //             if prop_color != color {
    //                 // Add to remark list
    //                 let adr = remark_list.get(sizeof(ptr))
    //                 @ptrv(adr, ptr) = item_ptr
    //                 added = true
    //             }
    //         }
    //     #if @type_is_nullable(type)
    //     }
    //     #end
    // }
    // #end
    // #endloop

    // // Call _gc_mark hook
    // #if @type_has_method(T, _gc_mark)
    // item._gc_mark(color)
    // #end
}

fn demark[T](item: T, color: u16) {

    let item_ptr = item @as ptr
    
    if @ptrv(item_ptr, u16, byte_color_rel) != color : return
    @ptrv(item_ptr, u16, byte_color_rel) = color_blank

    let size : uint = sizeof(<T>) + 8
    mem_marked -= size

    let block_index = @ptrv(item_ptr, u8, byte_block_index_rel) & 127
    let block_start = item_ptr - 8 - block_index * size
    @ptrv(block_start, uint, -2)-- // Increase used items count

    // #loop_object_properties item as prop, type
    // #if @type_is_gc(type)
    // {
    //     let p = prop
    //     #if @type_is_nullable(type)
    //     if isset(p) {
    //     #end
    //         gc_demark[typeof(p)](p, color)
    //     #if @type_is_nullable(type)
    //     }
    //     #end
    // }
    // #end
    // #endloop

    // // Call _gc_free
    // #if @type_has_method(T, _gc_free)
    // item._gc_free()
    // #end
}
