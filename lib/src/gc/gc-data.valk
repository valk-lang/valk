
value flag_own_state (3)
value flag_owned (1)
value flag_no_owner (2)

value flag_shared (4)
value flag_on_stack (8)
value flag_still_co_owned (16)
value flag_in_updates (32)
value flag_shmark (64)
value flag_leak (128)

value prop_owned (1)
value prop_co_owned (2)
value prop_mask (3)

macro gcdata "(" V:v1 ")" <{ return v1.$offset(-8).@cast(GcData) }

value shmarkmask ((0xFF - flag_shmark))
value leakmask ((0xFF - flag_leak))
value allmarkmask (((0xFF - 64) - 128))

struct GcData {
    co_count: u32
    flags: u8
    unused: u8
    offset: u16
    //
    fn item() GcItem { return this.@offset(8).@cast(GcItem) }

    // Mark
    fn is_marked() bool { return (this.flags & flag_shmark) == flag_shmark }
    fn set_mark() { this.flags = this.flags | flag_shmark }
    fn remove_mark() { this.flags = this.flags & shmarkmask }
    fn remove_marks() { this.flags = this.flags & allmarkmask }

    fn has_leak_mark() bool { return (this.flags & flag_leak) == flag_leak }
    fn set_leak_mark() { this.flags = this.flags | flag_leak }
    fn remove_leak_mark() { this.flags = this.flags & leakmask }

    fn block() BlockMini { return this.@offset(this.offset.to(int) * -1).@cast(BlockMini) }

    // Flags
    fn set_new() { this.flags = this.flags & (255 - flag_owned - flag_no_owner) }
    fn set_owned() { this.flags = (this.flags & (255 - flag_no_owner)) | flag_owned }
    fn set_no_owner() { this.flags = (this.flags & (255 - flag_owned)) | flag_no_owner }
    //
    fn is_new() bool { return (this.flags & flag_own_state) == 0 }
    fn is_not_new() bool { return (this.flags & flag_own_state) != 0 }
    fn is_owned() bool { return (this.flags & flag_owned) == flag_owned }
    fn is_owned_not_shared() bool { return (this.flags & (flag_owned + flag_shared)) == flag_owned }
    fn is_not_owned() bool { return (this.flags & flag_owned) == 0 }
    fn is_not_owned_not_shared() bool { return (this.flags & (flag_owned + flag_shared)) == 0 }
    fn is_no_owner_not_shared() bool { return (this.flags & (flag_no_owner + flag_shared)) == flag_no_owner }

    fn is_shared() bool { return (this.flags & flag_shared) != 0 }
    fn set_shared() { this.flags = this.flags | flag_shared }
    fn remove_shared() { this.flags = this.flags & (255 - flag_shared) }

    fn is_on_stack() bool { return (this.flags & flag_on_stack) != 0 }
    fn set_on_stack() { this.flags = this.flags | flag_on_stack }
    fn remove_on_stack() { this.flags = this.flags & (255 - flag_on_stack) }
    //
    fn is_still_co_owned() bool { return (this.flags & flag_still_co_owned) != 0 }
    fn set_still_co_owned() { this.flags = this.flags | flag_still_co_owned }
    fn remove_still_co_owned() { this.flags = this.flags & (255 - flag_still_co_owned) }
    //
    fn is_in_updates() bool { return (this.flags & flag_in_updates) != 0 }
    fn set_in_updates() { this.flags = this.flags | flag_in_updates }
    fn remove_in_updates() { this.flags = this.flags & (255 - flag_in_updates) }
    //
    fn co_own() {
        atomic(this.co_count + 1)
    }

    fn dis_co_own() {
        atomic(this.co_count - 1)
        if this.is_still_co_owned() {
            this.remove_still_co_owned()
            this.set_no_owner()
            gc.dis_owned_list.add_ptr(this.item())
        }
    }
}

pointer GcItem {
}

fn print_item_info(item: ptr) {
    let data = gcdata(item)
    println("---------------------")
    println("ITEM: " + item.@cast(ptr))
    println("RUNNING SHARED GC: " + running_shared)
    println("ON-STACK: " + data.is_on_stack())
    println("NEW: " + data.is_new())
    println("OWNED: " + data.is_owned())
    println("SHARED: " + data.is_shared())
    println("HAS SHARE MARK: " + data.is_marked())
    println("HAS LEAK MARK: " + data.has_leak_mark())
    println("FLAGS: " + data.flags)
    println("BLOCK OFFSET: " + data.offset)
    println("---------------------")
}
