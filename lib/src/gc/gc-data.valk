
value state_new (0) 
value state_unused (1) 
value state_used (2) 
value state_shared_unused (3) 
value state_shared (4) 

// value flag_in_disconnected (1)
value flag_in_updates (2)
value flag_in_blanks (4)
value flag_on_stack (8)
value flag_has_vtable (16)
value flag_custom_co_count (32)
value flag_still_co_owned (64)

struct GcData {
    state: u8
    flags: u8
    co_count: u16
    age: u8
    propc: u8
    block_offset: u16
    vtable: ptr
    //
    fn item() GcItem { return @offset(this, u8, 8).@cast(GcItem) }

    // Flags
    fn is_on_stack() bool { return this.flags & flag_on_stack != 0 }
    fn set_on_stack() { this.flags = this.flags | flag_on_stack }
    fn remove_on_stack() { this.flags = this.flags & (255 - flag_on_stack) }
    //
    fn has_vtable() bool { return this.flags & flag_has_vtable != 0 }
    fn set_has_vtable() { this.flags = this.flags | flag_has_vtable }
    fn remove_has_vtable() { this.flags = this.flags & (255 - flag_has_vtable) }
    //
    fn is_custom_co_count() bool { return this.flags & flag_custom_co_count != 0 }
    fn set_custom_co_count() { this.flags = this.flags | flag_custom_co_count }
    fn remove_custom_co_count() { this.flags = this.flags & (255 - flag_custom_co_count) }
    //
    fn is_still_co_owned() bool { return this.flags & flag_still_co_owned != 0 }
    fn set_still_co_owned() { this.flags = this.flags | flag_still_co_owned }
    fn remove_still_co_owned() { this.flags = this.flags & (255 - flag_still_co_owned) }
    //
    fn is_in_updates() bool { return this.flags & flag_in_updates != 0 }
    fn set_in_updates() { this.flags = this.flags | flag_in_updates }
    fn remove_in_updates() { this.flags = this.flags & (255 - flag_in_updates) }
    //
    fn is_in_blanks() bool { return this.flags & flag_in_blanks != 0 }
    fn set_in_blanks() { this.flags = this.flags | flag_in_blanks }
    fn remove_in_blanks() { this.flags = this.flags & (255 - flag_in_blanks) }

    //
    fn co_own() {
        if this.is_custom_co_count() {
            // print("[I]")
            let i = this.co_count
            co_count_index_incr(i)
        } else {
            // print(">")
            let v = atomic_op(this.co_count + 1)
            if v == 65000 {
                // print("[>]")
                // v.print(10)
                // print(".")
                let i = co_count_get_index()
                co_count_set_index_value(i, v + 1)
                this.co_count = i
                this.set_custom_co_count()
            } else if v > 65000 {
                // TODO: block until custom count flag
                panic("Race condition while counting co owners")
            }
        }
    }

    fn dis_co_own() {
        if this.is_custom_co_count() {
            // print("[D]")
            let i = this.co_count
            let c = co_count_index_decr(i)
            if c == 0 {
                print("[<]")
                co_count_give_index(i)
                this.remove_custom_co_count()
            }
        } else {
            let is_low = this.co_count < 65000
            let v = atomic_op(this.co_count - 1)
            if this.co_count > 65000 && is_low : print("_")
        }
    }
}

pointer GcItem {
    // Data
    fn data() GcData { return @offset(this, u8, -8).@cast(GcData) }
}
