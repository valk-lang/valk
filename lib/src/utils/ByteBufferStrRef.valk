
use mem

class ByteBufferStrRef {
    ~ offset: uint
    ~ buffer: ByteBuffer
    ~ length: uint

    static fn new(buffer: ByteBuffer, offset: uint, length: uint) ByteBufferStrRef {
        // (buffer @as ptr).print()
        // print("---")
        // if buffer @as ?ptr == null {
        //     println(">>WTF<<")
        // }
        let b = ByteBufferStrRef {
            buffer: buffer
            offset: offset
            length: length
        }
        // (b @as ptr).print()
        //     print(".")
        return b
    }

    // fn _gc_free() {
    //     println("YOOOOOOOOOOOOO")
    // }

    fn clear() {
        this.length = 0
    }

    fn data_ptr() ptr {
        return @ptr_offset(this.buffer.data, this.offset)
    }

    fn _string() String {
        let len = this.length
        if len == 0 : return ""
        // print("len:")
        // len.print(10)
        //     print(".")
        // print("on:")
        // (this @as ptr).print()
        //     print(".")
        let x = this.buffer.sub_str(this.offset, len)
        // print("b\n")
        return x
    }

    fn _eq(cmp: String) bool {
        let len = this.length
        if len != cmp.bytes : return false 
        if len == 0 : return true
        return mem:equal(@ptr_offset(this.buffer.data, this.offset), cmp.data_ptr(), len)
    }
}
