
use mem
use io

class ByteBuffer {
    ~ data: ptr
    ~ size: uint
    ~ length: uint (0)

    static fn new(start_size: uint) ByteBuffer {
        if start_size < 10 {
            start_size = 10
        }
        let res = ByteBuffer {
            data: mem:alloc(start_size)
            size: start_size
        }
        return res
    }

    fn _gc_free() {
        mem:free(this.data)
    }

    fn clear() {
        this.length = 0
    }
    fn clear_until(index: uint) {
        let len = this.length
        if index >= len {
            this.length = 0
            return
        }
        let data = this.data
        let bytes = len - index
        mem:copy(@ptr_offset(data, index), data, bytes)
        this.length = bytes
    }

    // Read
    fn get(index: uint) u8 !range {
        if index >= this.length : throw range
        return @ptrv(this.data, u8, index)
    }

    // Appending
    fn append(buffer: ByteBuffer, start_index: uint (0)) {
        if start_index >= buffer.length : return
        this.append_from_ptr(buffer.data + start_index, buffer.length - start_index)
    }

    fn append_from_ptr(data: ptr, length: uint) {
        if length == 0 : return
        let bytes : uint = this.length
        let new_bytes : uint = bytes + length
        if(new_bytes > this.size) : this.minimum_size(new_bytes)
        mem:copy(data, @ptr_offset(this.data, bytes), length)
        this.length = new_bytes
    }

    fn append_byte(byte: u8) {
        let bytes : uint = this.length
        let new_bytes : uint = bytes + 1
        if new_bytes > this.size : this.minimum_size(new_bytes)
        @ptrv(this.data, u8, bytes) = byte
        this.length = new_bytes
    }

    fn append_str(str: String) {
        this.append_from_ptr(str.data_ptr(), str.bytes)
    }
    fn append_uint(value: uint) {
        let len = this.length
        let new_bytes : uint = len + sizeof(uint)
        if new_bytes > this.size : this.minimum_size(new_bytes)
        let ilen = value.to_base_to_ptr(10, this.data + len)
        this.length += ilen
    }
    fn append_int(value: int) {
        let len = this.length
        let new_bytes : uint = len + sizeof(uint)
        if new_bytes > this.size : this.minimum_size(new_bytes)
        let ilen = value.to_base_to_ptr(10, this.data + len)
        this.length += ilen
    }

    // Compare

    fn eq_str(str: String) bool {
    	let str_len = str.bytes
    	let len = this.length
    	if str_len != len {
    		return false
    	}
    	return mem:equal(this.data, str.data, len)
    }

    // Find

    fn index_of_byte(byte: u8, start_index: uint (0)) uint !not_found {
        let len = this.length
        if start_index >= len : throw not_found
        let data = this.data
        let res = mem:find_char(data + start_index, byte, len - start_index) ! throw not_found
        return (res - data) @as uint
    }

    fn index_where_byte_is_not(byte: u8, start_index: uint (0)) uint !not_found {
        let index = start_index
        let len = this.length
        let data = this.data
        while index < len {
            let ch = @ptrv(data, u8, index)
            if ch != byte : return index
            index++
        }
        throw not_found
    }

    /////////////////////////
    // String functions
    /////////////////////////

    fn to_string() String {
        if this.length == 0 : return ""
        let str = String.make_empty(this.length)
        mem:copy(this.data, str.data_ptr(), this.length)
        return str
    }

    fn sub_str(start_index: uint, length: uint) String {
        let len = this.length
        if length == 0 || start_index >= len : return ""
        let end = start_index + length
        let real_len = end > len ? len - start_index : length
        let str = String.make_empty(real_len)
        mem:copy(@ptr_offset(this.data, start_index), str.data_ptr(), real_len)
        return str
    }

    // 
    fn minimum_free_space(length: uint) {
        if(this.length + length > this.size) : this.minimum_size(this.length + length)
    }
    fn minimum_size(minimum_size: uint) {
        let size : uint = this.size
        let new_size : uint = size
        while new_size < minimum_size {
            new_size *= 2
        }
        if(new_size != size){
            let data = this.data
            let adr : ptr = mem:alloc(new_size)
            mem:copy(data, adr, this.length)
            mem:free(data)
            this.size = new_size
            this.data = adr
        }
    }

    fn reduce_size(size: uint) {
        if this.size <= size : return
        let len = this.length
        if len > size : size = len
        let data = this.data
        let adr : ptr = mem:alloc(size)
        mem:copy(data, adr, len)
        mem:free(data)
        this.data = adr
        this.size = size
    }

    fn reduce_length(amount: uint) {
        if amount > this.length {
            amount = this.length
        }
        this.length -= amount
    }

    fn set_length(new_length: uint) {
        if new_length <= this.size {
            this.length = new_length
        }
    }
}
