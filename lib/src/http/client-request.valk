
use utils
use net
use fs

class ClientRequest {
    - recv_buffer: utils:ByteBuffer
    - ctx: Context
    - con: net:Connection
    - payload: utils:ByteBuffer
    //
    - output_file: ?fs:FileStream (null)
    // Progress
    - stage: uint (0)
    ~ bytes_to_send: uint (0)
    ~ bytes_sent: uint (0)
    ~ bytes_to_recv: uint (0)
    ~ bytes_received: uint (0)
    ~ sent_percent: uint (0)
    ~ recv_percent: uint (0)
    ~ done: bool (false)
    // Final
    - resp: ?ClientResponse (null)

    static fn new(con: net:Connection, payload: utils:ByteBuffer) ClientRequest {

        let recv_buffer = utils:ByteBuffer.new(2048)
        let ctx = Context.new(recv_buffer)

        return ClientRequest {
            recv_buffer: recv_buffer
            ctx: ctx
            con: con
            payload: payload
            bytes_to_send: payload.length
        }
    }

    + fn set_output_file(file: fs:FileStream) {
        this.ctx.save_to_file = file
    }

    + fn progress() bool !disconnect !invalid_response {
        
        if this.done : return false

        let con = this.con

        if this.stage == 0 {
            // Send request
            let sent_count = con.send_buffer(this.payload, this.bytes_sent, false) ! {
                con.close()
                this.done = true
                throw disconnect, "Unexpected disconnect during request"
            }
            this.bytes_sent += sent_count
            this.sent_percent = this.bytes_sent * 100 / this.bytes_to_send
            if this.bytes_sent < this.bytes_to_send : return true
            // Done
            this.stage = 1
            this.sent_percent = 100
        }

        // Receive response
        let context = this.ctx
        let recv_buf = this.recv_buffer
        if !context.done {
            let bytes = con.recv(recv_buf, 1024 * 32) ! {
                con.close()
                this.done = true
                throw invalid_response
            }
            this.bytes_received += bytes
            if context.content_length > 0 {
                this.recv_percent = this.bytes_received * 100 / context.content_length
            }

            if bytes == 0 {
                con.close()
                this.done = true
                throw invalid_response
            }
            // Parse bytes
            parse_http(recv_buf, context, true) ! {
                if error_is(E, incomplete) : return true
                this.done = true
                throw invalid_response
            }

            this.recv_percent = 100
        }

        // Create response
        let resp = ClientResponse {
            status: context.status
            // headers: request.headers()
            body: context.body()
        }

        con.close()
        context.reset()
        recv_buf.clear()

        this.resp = resp
        this.done = true

        return false
    }

    + fn response() ClientResponse !in_progress !invalid_response {
        if !this.done : throw in_progress
        return this.resp ?! throw invalid_response
    }
}
