
header "sys" as sys

use io
use net
use utils
use fs
use mem
use coro

class Connection {
    worker: Worker
    netcon: net:Connection
    fd: FD

    // Request
    parser: Parser (Parser.new())
    request: ?RequestStream (null)

    fn handle() {

        // Settings
        let worker = this.worker
        let server = worker.server
        let max_hs = server.max_request_header_size
        let max_bs = server.max_request_body_size
        let max_sbs = server.max_server_wide_body_size

        let parser = this.parser
        let input = parser.input
        let handler = server.handler
        let fast_handler = server.fast_handler

        let req = RequestStream {
            method: parser.method
            path: parser.path
            query_string: parser.query_string
            header_data: parser.header_data
        }

        this.request = req

        while true {

            parser.parse(false) ! (err) {
                // Check if we need more data
                if error_is(err, incomplete) {
                    let bytes = this.read_more(input) ! (err) {
                        break
                    }
                    if bytes > 0 : continue
                } else if error_is(err, http413) {
                    this.send_error(413)
                } else {
                    this.send_error(400)
                }
                break
            }

            // Handle request
            req.body = parser.body()

            // Check static dirs
            let is_file = false
            if server.static_dirs.length > 0 {
                let path = req.path._string().trim("/")
                if path.bytes > 0 {
                    each server.static_dirs => dir {
                        let fullpath = dir + path 
                        if fs:is_file(fullpath) {
                            req.send_file(fullpath)
                            is_file = true
                            break
                        }
                    }
                }
            }

            // Response
            if !is_file {
                if isset(fast_handler) {
                    fast_handler(req)
                    if !req.responded {
                        this.send_error(400)
                    }
                } else {
                    let request = Request {
                        method: req.method
                        path: req.path
                        header_data: req.header_data
                        query_string: req.query_string
                        body: req.body
                    }
                    let resp = handler(request)
                    req.send_response(resp)
                }
            }

            // Reset parser for next request
            parser.reset()
            req.reset()

            // Flush output
            if req.should_send() || parser.input_pos == 0 {
                req.send_bytes(this.netcon) ! {
                    break
                }
                req.reset_output()
            }
        }

        this.close()
        worker.connections--
        // atomic(server.connections - 1)
    }

    fn read_more(buffer: utils:ByteBuffer) uint !err {
        let bytes = this.netcon.recv(buffer, 65535) ! (err) {
            throw err
        }
        return bytes
    }

    fn send_error(code: uint) {
        let reqs = this.request
        if isset(reqs) {
            reqs.send_status(code)
            reqs.send_bytes(this.netcon) ! {
                return
            }
        }
    }

    fn close() {
        let reqs = this.request
        if isset(reqs) {
            reqs.reset()
            reqs.reset_output()
        }
        this.parser.reset()
        this.netcon.close()
    }
}


