
header "openssl" as ssl

use net
use url
use utils
use fs

// enum METHOD {
//     GET,
//     POST,
//     PUT,
//     PATCH,
// }

+ fn client(method: String, url: String, headers: ?Map[String] (null)) Client {
    return Client.new(method, url, headers)
}

+ fn request(method: String, url: String, headers: ?Map[String] (null)) 
    ClientResponse !invalid_url !connection_failed !disconnect !invalid_response !ssl
{
    let resp = Client.new(method, url, headers).exec() ! {
        match E {
            E.invalid_url => throw invalid_url, EMSG
            E.connection_failed => throw connection_failed, EMSG
            E.disconnect => throw disconnect, EMSG
            E.ssl => throw ssl, EMSG
            default => throw invalid_response, EMSG
        }
    }
    return resp
}

+ fn download(url: String, to_path: String, headers: ?Map[String] (null)) !failed {
    let req = Client.new("GET", url, headers)
    req.download(to_path) ! throw failed
}

class Client {
    ~ method: String
    ~ url: url:Url (null)
    ~ url_str: String
    + body: String ("")
    ~ headers: ?Map[String] (null)

    + static fn new(
        method: String,
        url: String,
        headers: ?Map[String] (null)
    ) Client {
        return Client {
            method: method
            url: url:parse(url)
            url_str: url
            headers: headers
        }
    }

    + fn request() ClientRequest !invalid_url !connection_failed !ssl {

        // Validate URL
        let url = this.url
        let is_https = url.scheme == "https"

        let split = url.host.split(":")
        let host = url.host
        let port : u16 = is_https ? 443 : 80
        if split.length > 2 : throw invalid_url
        if split.length == 2 {
            host = split.get(0) !? ""
            let p = split.get(1) ! throw invalid_url
            port = (p.to_uint() ! throw invalid_url).@cast(u16)
        }

        // Connect
        let sock = net:Socket.new_tcp(host, port) ! {
            throw connection_failed, "Connection failed"
        }

        let con = sock.connect() ! {
            throw connection_failed, "Connection failed"
        }

        if is_https {
            con.ssl_connect(host, null) ! {
                con.close()
                throw ssl, EMSG
            }
        }

        // Request
        return ClientRequest.new(con, this.get_payload())
    }

    + fn exec() ClientResponse !invalid_url !connection_failed !disconnect !invalid_response !ssl {

        let req = this.request() ! {
            match E {
                E.invalid_url => throw invalid_url, EMSG
                E.ssl => throw ssl, EMSG
                default => throw connection_failed, EMSG
            }
        }

        while (req.progress() ! {
            match E {
                E.disconnect => throw disconnect
                default => throw invalid_response
            }
        }) {}

        return req.response() ! throw invalid_response
    }

    + fn download(to_path: String) !invalid_url !invalid_file_path !connection_failed !disconnect !invalid_response {

        let req = this.request() ! {
            match E {
                E.invalid_url => throw invalid_url
                default => throw connection_failed
            }
        }

        let file = fs:stream(to_path, true, true, false, true) ! {
            fs:remove(to_path) _
            throw invalid_file_path, "Failed to open file for download"
        }

        req.set_output_file(file)

        while (req.progress() ! {
            match E {
                E.disconnect => throw disconnect
                default => throw invalid_response
            }
        }) {}

        file.close()
    }

    - fn get_payload() utils:ByteBuffer {

        let url = this.url

        let len = this.body.bytes
        let buf = utils:ByteBuffer.new(len + 256)

        let method = this.method

        buf.append_str(method)
        buf.append_str(" ")
        buf.append_str(url.path)
        if url.query != "" {
            buf.append_str("?")
            buf.append_str(url.query)
        }
        buf.append_str(" HTTP/1.1\r\n")

        buf.append_str("Host: ")
        buf.append_str(url.host)
        buf.append_str("\r\n")

        buf.append_str("Content-Length: ")
        buf.append_str(this.body.bytes)
        buf.append_str("\r\n")

        let headers = this.headers
        if isset(headers) {
            each headers._keys as k, i {
                let v = headers._values.get(i) ! break
                buf.append_str(k)
                buf.append_str(": ")
                buf.append_str(v)
                buf.append_str("\r\n")
            }
        }

        buf.append_str("\r\n")
        buf.append_str(this.body)

        return buf
    }
}