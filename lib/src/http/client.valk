
header "openssl" as ssl

use net
use url
use utils
use fs

// enum METHOD {
//     GET,
//     POST,
//     PUT,
//     PATCH,
// }

+ fn client() Client {
    return Client.new()
}

+ fn download(url: String, to_path: String, method: String ("GET"), headers: ?Map[String] (null)) !failed {
    let client = Client.new()
    if isset(headers) : client.set_headers(headers)
    client.download(url, to_path, method) ! throw failed
}

class Client {
    + body: String ("")
    - headers_: ?Map[String] (null)

    + static fn new(
    ) Client {
        return Client {
        }
    }

    //////////////////////////////
    // Configure headers
    //////////////////////////////

    + fn headers() Map[String] {
        let hh = this.headers_
        if !isset(hh) {
            hh = map[String]{}
            this.headers_ = hh
            return hh
        }
        return hh
    }
    + fn set_header(key: String, value: String) SELF {
        let hh = this.headers()
        hh.set(key, value)
        return this
    }
    + fn set_headers(headers: Map[String]) SELF {
        each headers as v, k : this.set_header(k, v)
        return this
    }
    + fn clear_headers(key: String, value: String) SELF {
        let hh = this.headers_
        if isset(hh) : hh.clear()
        return this
    }

    //////////////////////////////
    // Configure SSL (TODO)
    //////////////////////////////

    //////////////////////////////
    // Request initialization
    //////////////////////////////

    + fn request(method: String, url: String) ClientRequest !invalid_url !connection_failed !ssl {

        // Validate URL
        let u = url:parse(url)
        let is_https = u.scheme == "https"

        let split = u.host.split(":")
        let host = u.host
        let port : u16 = is_https ? 443 : 80
        if split.length > 2 : throw invalid_url
        if split.length == 2 {
            host = split.get(0) !? ""
            let p = split.get(1) ! throw invalid_url
            port = (p.to_uint() ! throw invalid_url).@cast(u16)
        }

        // Connect
        let sock = net:Socket.new_tcp(host, port) ! {
            throw connection_failed, "Connection failed"
        }

        let con = sock.connect() ! {
            throw connection_failed, "Connection failed"
        }

        if is_https {
            con.ssl_connect(host, net:ca_cert) ! {
                con.close()
                throw ssl, EMSG
            }
        }

        //
        let payload = this.create_payload(method, u)

        // Request
        return ClientRequest.new(con, payload)
    }

    + fn exec(method: String, url: String) ClientResponse !invalid_url !connection_failed !disconnect !invalid_response !ssl {

        let req = this.request(method, url) ! {
            match E {
                E.invalid_url => throw invalid_url, EMSG
                E.ssl => throw ssl, EMSG
                default => throw connection_failed, EMSG
            }
        }

        while (req.progress() ! {
            match E {
                E.disconnect => throw disconnect
                default => throw invalid_response
            }
        }) {}

        return req.response() ! throw invalid_response
    }

    + fn download(url: String, to_path: String, method: String ("GET")) !invalid_url !invalid_file_path !connection_failed !disconnect !invalid_response {

        let req = this.request(method, url) ! {
            match E {
                E.invalid_url => throw invalid_url
                default => throw connection_failed
            }
        }

        let file = fs:stream(to_path, true, true, false, true) ! {
            fs:remove(to_path) _
            throw invalid_file_path, "Failed to open file for download"
        }

        req.set_output_file(file)

        while (req.progress() ! {
            match E {
                E.disconnect => throw disconnect
                default => throw invalid_response
            }
        }) {}

        file.close()
    }

    - fn create_payload(method: String, url: url:Url) utils:ByteBuffer {

        let len = this.body.bytes
        let buf = utils:ByteBuffer.new(len + 256)

        buf.append_str(method)
        buf.append_str(" ")
        buf.append_str(url.path)
        if url.query != "" {
            buf.append_str("?")
            buf.append_str(url.query)
        }
        buf.append_str(" HTTP/1.1\r\n")

        buf.append_str("Host: ")
        buf.append_str(url.host)
        buf.append_str("\r\n")

        buf.append_str("Content-Length: ")
        buf.append_str(this.body.bytes)
        buf.append_str("\r\n")

        let headers = this.headers_
        if isset(headers) {
            each headers._keys as k, i {
                let v = headers._values.get(i) ! break
                buf.append_str(k)
                buf.append_str(": ")
                buf.append_str(v)
                buf.append_str("\r\n")
            }
        }

        buf.append_str("\r\n")
        buf.append_str(this.body)

        return buf
    }
}