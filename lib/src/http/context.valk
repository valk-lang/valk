
use utils
use fs

class Context {
    ~ method: utils:ByteBufferStrRef
    ~ path: utils:ByteBufferStrRef
    ~ query_string: utils:ByteBufferStrRef
    ~ header_data: utils:ByteBufferStrRef
    ~ body_data: utils:ByteBufferStrRef
    - chunks: utils:ByteBuffer (utils:ByteBuffer.new(8192))

    ~ status: uint (0)
    ~ stage: uint (0)
    ~ parsed_index: uint (0)
    ~ content_length: uint (0)
    ~ body_received: uint (0)
    ~ save_to_file: ?fs:FileStream (null)

    - header_map: ?Map[String] (null)

    ~ has_host: bool (false)
    ~ chunked: bool (false)
    ~ done: bool (false)

    static fn new(buffer: utils:ByteBuffer) Context {
        return Context {
            method: buffer.str_ref(0, 0)
            path: buffer.str_ref(0, 0)
            query_string: buffer.str_ref(0, 0)
            header_data: buffer.str_ref(0, 0)
            body_data: buffer.str_ref(0, 0)
        }
    }

    fn reset() {
        let file = this.save_to_file
        if isset(file) : file.close()
        this.save_to_file = null

        this.stage = 0
        this.status = 0

        this.method.clear()
        this.path.clear()
        this.query_string.clear()
        this.header_data.clear()
        this.body_data.clear()

        this.chunks.clear()

        this.has_host = false
        this.chunked = false
        this.done = false
    }

    fn body() String {
        if !this.done : return ""
        if this.chunked : return this.chunks.to_string()
        return this.body_data
    }

    fn headers() Map[String] {
        let headers = this.header_map
        if isset(headers) : return headers
        let new = Map[String].new()
        this.parse_headers(this.header_data.data_ptr(), this.header_data.length, new) _
        this.header_map = new
        return new
    }

    - fn parse_headers(data: ptr, length: uint, result: Map[String]) !invalid {

        let pos : uint = 0

        while true {
            let index = data.offset(pos).index_of_byte('\r', length - pos) ! throw invalid
            index += pos
            if index + 1 >= length : throw invalid
            if @ptrv(data, u8, index + 1) != '\n' : throw invalid

            // End of headers
            if index == pos : break

            let split = data.offset(pos).index_of_byte(':', index - pos) ! throw invalid
            split += pos

            let value_pos = split + 1
            while @ptrv(data, u8, value_pos) == ' ' : value_pos++

            let key = data.offset(pos).create_string(split - pos)
            let value = data.offset(value_pos).create_string(index - value_pos)
            result.set(key.to_lower(), value)

            pos = index + 2
        }
    }
}
