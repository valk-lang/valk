
use utils
use fs
use url
use mem
use net

class RequestStream {
    ~ method: utils:ByteBufferStrRef
    ~ path: utils:ByteBufferStrRef
    ~ header_data: utils:ByteBufferStrRef
    ~ query_string: utils:ByteBufferStrRef
    body: String ("")

    -[ns] header_map: ?Map[String] (null)
    -[ns] params_map: ?Map[String] (null)
    -[ns] params_grp: ?Map[Array[String]] (null)
    -[ns] data_map: ?Map[String] (null)
    -[ns] files_map: ?Map[fs:InMemoryFile] (null)

    -[ns] output: utils:ByteBuffer (utils:ByteBuffer.new(1024)) 
    -[ns] file_response: ?fs:FileStream (null) 
    ~[ns] responded: bool (false) 
    - output_pos: uint (0)

    - fn reset() {
        this.body = ""
        this.responded = false

        this.header_map = null
        this.params_map = null
        this.params_grp = null
        this.data_map = null
        this.files_map = null
    }
    - fn reset_output() {
        this.output.clear()
        this.output.reduce_size(8192)
        this.output_pos = 0

        let file = this.file_response
        if isset(file) {
            file.close()
            this.file_response = null
        }
    }

    fn headers() Map[String] {
        let headers = this.header_map
        if isset(headers) : return headers
        let list = Map[String].new()
        this.parse_headers(this.header_data.data_ptr(), this.header_data.length, list) ? 0
        this.header_map = list
        return list
    }

    fn params() Map[String] {
        let params = this.params_map
        if isset(params) : return params
        let list = Map[String].new()
        let data : String = this.query_string
        if data.bytes > 0 {
            let parts = data.split("&")
            each parts => part {
                let k, v = part.split_on_first_occurance_of_byte('=') ! continue
                list.set(k, url:decode(v))
            }
        }
        this.params_map = list
        return list
    }

    fn params_grouped() Map[Array[String]] {
        let params = this.params_grp
        if isset(params) : return params
        let list = Map[Array[String]].new()
        let data : String = this.query_string
        if data.bytes > 0 {
            let parts = data.split("&")
            each parts => part {
                let k, v = part.split_on_first_occurance_of_byte('=') ! continue
                let arr = list.get(k) ! {
                    let g = Array[String].new()
                    g.push(url:decode(v))
                    list.set(k, g)
                    // new.set(k, array[String]{ url:decode(v) })
                    continue
                }
                arr.push(url:decode(v))
            }
        }
        this.params_grp = list
        return list
    }

    fn data() Map[String] {
        let data = this.data_map
        if isset(data) : return data
        let list = Map[String].new()
        let files = Map[fs:InMemoryFile]{}
        let headers = this.headers()
        let type = headers.get("content-type") ? ""
        if type == "application/x-www-form-urlencoded" {
            this.data_urlencoded(list)
        } else if type.starts_with("multipart/form-data") {
            this.data_multipart(list, files, type.ltrim("multipart/form-data boundary="))
        } else if type == "application/json" {
            this.data_json(list)
        }
        this.data_map = list
        this.files_map = files
        return list
    }

    fn files() Map[fs:InMemoryFile] {
        let files = this.files_map
        if isset(files) : return files
        this.data()
        return this.files()
    }

    - fn data_urlencoded(result: Map[String]) {
        let parts = this.body.split("&")
        each parts => part {
            let k, v = part.split_on_first_occurance_of_byte('=') ! continue
            result.set(k, url:decode(v))
        }
    }
    - fn data_multipart(result: Map[String], files: Map[fs:InMemoryFile], boundary: String) {
        // Content-Type: multipart/form-data boundary=boundary
        // Body example:
        // --boundary
        // Content-Disposition: form-data name="name"
            
        // John
        // --boundary
        // Content-Disposition: form-data name="avatar" filename="avatar.jpg"
        // Content-Type: image/jpeg
            
        // <some binary data>
        // --boundary--
        let headers = Map[String].new()
        let dispos = Map[String].new()
        let body = this.body
        let parts = body.split("--" + boundary)
        each parts => i, part {
            if i == 0 : continue
            let ch = part.byte(0)
            if !ch.is_newline() : break
            ch = part.byte(1)
            if !ch.is_newline() : break
            // Parse headers
            headers.clear()
            dispos.clear()
            let part_data = part.data_ptr()
            let header_bytes = this.parse_headers(part_data, part.bytes, headers) ! continue
            // Content disposition
            let dispo = headers.get("content-disposition") ! continue
            this.parse_content_disposition(dispo, dispos)
            let name = dispos.get("name") ! continue
            let fn : ?String = dispos.get("filename") ? null
            // 
            let body_offset = header_bytes + 2
            if body_offset > part.bytes - 2 : continue
            let body_bytes = part.bytes - body_offset - 2

            if isset(fn) {
                let file = fs:InMemoryFile.create_from_ptr(part_data + body_offset, body_bytes)
                file.filename = fn
                files.set(name, file)
                file.mime_type = headers.get("content-type") ! continue
            } else {
                let v = part.byte_sub_str(body_offset, body_bytes)
                result.set(name, v)
            }
        }
    }

    - fn parse_content_disposition(value: String, result: Map[String]) {
        // form-data name="avatar" filename="avatar.jpg"
        let parts = value.split("")
        each parts => part {
            let k, v = part.split_on_first_occurance_of_byte('=') ! continue
            v = v.trim(" ").trim("\"").unescape()
            result.set(k.trim(" "), v)
        }
    }

    - fn data_json(result: Map[String]) {
        // TODO
    }

    - fn parse_headers(data: ptr, memory_size: uint, result: Map[String]) uint !invalid {

        let pos : uint = 0
        let length = memory_size

        while true {
            let index = data.index_of_byte('\r', pos) ! throw invalid
            if index + 1 == length : throw invalid
            if @ptrv(data, u8, index + 1) != '\n' : throw invalid

            // End of headers
            if index == pos {
                pos += 2
                break
            }

            let split = data.index_of_byte(':', pos) ! throw invalid
            if split > index : throw invalid

            let value_pos = split + 1
            while @ptrv(data, u8, value_pos) == ' ' {
                value_pos++
            }

            let key = data.offset(pos).create_string(split - pos)
            let value = data.offset(value_pos).create_string(index - value_pos)
            result.set(key.to_lower(), value)

            pos = index + 2
        }

        return pos
    }

    fn send_response(resp: Response) {
        if this.responded : return

        let filepath = resp.filepath
        if isset(filepath) {
            this.send_file(filepath)
            return
        }

        this.respond(resp.status, resp.content_type, resp.body, resp.headers)
    }

    fn send_status(status_code: uint) {
        this.respond(status_code, "text/plain", "")
    }

    fn send_file(path: String, custom_filename: ?String (null)) {
        if this.responded : return

        let stream = fs:stream(path, true, false) ! {
            this.respond(404, "text/plain", "", null)
            return
        }
        this.send_file_stream(stream, custom_filename)
    }

    fn send_file_stream(stream: fs:FileStream, filename: ?String (null)) {
        if this.responded : return
        this.responded = true

        let out = this.output
        let path = stream.path
        let fsize = fs:size(path)
        let ext = fs:ext(path)
        let mime = fs:mime(ext)

        this.file_response = stream

        out.append_str("HTTP/1.1 200 OK\r\nContent-Type: " + mime + "\r\nContent-Length: " + fsize + "\r\n")

        if isset(filename) {
            out.append_str("Content-Disposition: attachment filename=\"" + filename + "\"\r\n")
        }

        out.append_str("\r\n")
    }

    fn respond(code: uint, content_type: String, body: String, headers: ?Map[String] (null)) {
        if this.responded : return
        this.responded = true

        let len = body.bytes
        let buf = this.output

        buf.append_str("HTTP/1.1 ")
        buf.append_uint(code)
        buf.append_str(" OK\r\n")

        buf.append_str("Content-Type: ")
        buf.append_str(content_type)
        buf.append_str("\r\n")

        buf.append_str("Content-Length: ")
        buf.append_uint(body.bytes)
        buf.append_str("\r\n")

        if isset(headers) {
            each headers => k, v {
                buf.append_str(k)
                buf.append_str(": ")
                buf.append_str(v)
                buf.append_str("\r\n")
            }
        }

        buf.append_str("\r\n")
        buf.append_str(body)
    }

    - fn count_bytes_to_send() uint {
        return this.output.length - this.output_pos
    }

    - fn should_send() bool {
        return this.count_bytes_to_send() > (128 * 1024) || this.file_response != null
    }

    - fn send_bytes(connection: net:Connection) !write {

        let out = this.output
        let file = this.file_response

        while true {
            // Check file stream
            if isset(file) {
                if this.count_bytes_to_send() == 0 {
                    if file.reading {
                        let part = file.read(65535) ? ""
                        out.append_str(part)
                    }
                    if !file.reading {
                        this.file_response = null
                        file = null
                    }
                }
            }

            let pos = this.output_pos
            let bytes = out.length - pos
            if bytes == 0 : break

            connection.send_from_ptr(out.data + pos, bytes) ! {
                throw write
            }
            this.output_pos += bytes
        }
    }
}
