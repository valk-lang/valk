
header "sys" as sys

use coro
use io
use mem
use core

#if OS == win
type ConnectExFn (fnRef(sys:SOCKET, sys:libc_gen_sockaddr, i32, ?ptr, u32, ?ptr, ?ptr)(bool))
type AcceptExFn (fnRef(sys:SOCKET, sys:SOCKET, ?ptr, u32, u32, u32, &u32, ?ptr)(bool))

global pConnectEx : ?ConnectExFn
global pAcceptEx : ?AcceptExFn

fn LoadConnectEx(s: sys:SOCKET) ConnectExFn !fail {
    let p = pConnectEx
    if isset(p) : return p
    // {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
    let guid : <sys:GUID> = @undefined
    guid.Data1 = 0x25a207b9
    guid.Data2 = 0xddf3
    guid.Data3 = 0x4660
    guid.Data4 = {0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}
    let bytes : u32 = 0
    let res = sys:WSAIoctl(s, sys:SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, size_of(<sys:GUID>), &pConnectEx, size_of(ptr), &bytes, null, null)
    if res != 0 {
        throw fail
    }
    return pConnectEx.@cast(ConnectExFn)
}

fn LoadAcceptEx(s: sys:SOCKET) AcceptExFn !fail {
    let p = pAcceptEx
    if isset(p) : return p
    // {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
    let guid : <sys:GUID> = @undefined
    guid.Data1 = 0xb5367df1
    guid.Data2 = 0xcbac
    guid.Data3 = 0x11cf
    guid.Data4 = {0x95,0xca,0x00,0x80,0x5f,0x48,0xa1,0x92}
    let bytes : u32 = 0
    let res = sys:WSAIoctl(s, sys:SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, size_of(<sys:GUID>), &pAcceptEx, size_of(ptr), &bytes, null, null)
    if res != 0 {
        throw fail
    }
    return pAcceptEx.@cast(AcceptExFn)
}
#end

fn accept(sock_fd: FD, addr: AddrInfo) FD !error {
    #if OS == win
    let fd = sys:WSASocketA(sys:AF_INET, sys:SOCK_STREAM, sys:IPPROTO_TCP, null, 0, sys:WSA_FLAG_OVERLAPPED)
    if fd == sys:INVALID_SOCKET : throw error

    sys:CreateIoCompletionPort(fd, io:iocp(), 0, 0)

    let acfn = LoadAcceptEx(sock_fd) ! {
        Socket.close_fd(fd)
        throw error
    }

    let ov = io:overlap[io:OverlapAcceptEx]
    // Important: buffer must be large enough for local + remote address
    // For IPv4: 2 × (sizeof(sockaddr_in) + 16) = 2 × 32 = 64 bytes minimum
    let addrLen : u32 = size_of(<sys:sockaddr_in>) + 16;
    let ok = acfn(sock_fd, fd, &ov.addressBuffer, 0, addrLen, addrLen, &ov.bytesReceived, ov)
    coro:yield()

    if ov.base.sys.Internal != 0 {
        Socket.close_fd(fd)
        throw error
    }

    return fd

    #elif OS == linux

    let coro = coro:current_coro.@cast(coro:Coro)
    let sqe = io:sqe(coro) ! throw error
    io:io_uring_prep_accept(sqe, sock_fd.@cast(i32), null, 0, 0)
    coro:yield()
    let fd = coro.completion_res.to(FD)
    if (fd < 0) : throw error

    return fd
    #elif OS == macos
    while true {
        let fd = sys:accept(sock_fd, null, null)
        if fd == -1 {
            let err = sys:errno
            if err == sys:EAGAIN {
                io:await_fd(sock_fd, true, false)
                continue
            }
            if err == sys:EMFILE || err == sys:ENFILE {
                // Too many connections
                throw error
            }
            throw error
        }
        return fd
    }
    throw error
    #else
    #error "Socket accept: Unsupported OS"
    #end
}

fn connect(fd: FD, addr: AddrInfo) !error {
    #if OS == win
    let empty_addr : <sys:libc_gen_sockaddr> = @undefined
    mem:clear(empty_addr, size_of(<sys:libc_gen_sockaddr>))
    empty_addr.sa_family = sys:AF_INET

    let err = sys:bind(fd, @ref(empty_addr), size_of(<sys:libc_gen_sockaddr>))
    if err != 0 : throw error

    let confn = LoadConnectEx(fd) ! throw error

    let ov = io:overlap[io:OverlapConnectEx]
    let ok = confn(fd, addr.sock_addr(), addr.addr_len(), null, 0, &ov.sent, ov)
    coro:yield()

    if ov.base.sys.Internal != 0 {
        throw error
    }

    #elif OS == linux
    let coro = coro:current_coro.@cast(coro:Coro)
    let sqe = io:sqe(coro) ! throw error
    io:io_uring_prep_connect(sqe, fd, addr.sock_addr(), addr.addr_len())
    coro:yield()
    let res = coro.completion_res
    if res < 0 : throw error

    #elif OS == macos
    while true {
        let err = sys:connect(fd, addr.sock_addr(), addr.addr_len())
        if err == 0 : break
        // Error
        let e = sys:errno
        if e == sys:EISCONN : break
        let a = e == sys:EINPROGRESS
        if a {
            io:await_fd(fd, false, true)
            continue
        }
        throw error
    }
    #else
    #error "Socket connect: Unsupported OS"
    #end
}

// Receive
+ fn recv(fd: FD, buf: ByteBuffer, amount: uint) uint !fail {
    buf.minimum_free_space(amount)
    let res = recv_to_ptr(fd, buf.data.@offset(buf.length), amount) !>
    buf.length += res
    return res
}
+ fn recv_to_ptr(fd: FD, buf: ptr, amount: uint) uint !fail {

    let coro = coro:current_coro.@cast(coro:Coro)

    #if OS == linux
    let sqe = io:sqe(coro) ! throw fail
    io:io_uring_prep_recv(sqe, fd.@cast(i32), buf, amount.to(u32), 0)

    coro:yield()
    let rcvd = coro.completion_res
    if rcvd <= 0 : throw fail
    return rcvd.@cast(uint)

    #elif OS == win
    let ov = io:overlap[io:OverlapRecv]
    ov.buflen = amount
    ov.buf = buf

    let res = sys:WSARecv(fd, @ref(ov.buflen), 1, null, &ov.flags, ov, null)
    coro:yield()

    let ok = sys:WSAGetOverlappedResult(fd, ov, &ov.rcvd, true, &ov.flags)
    if ov.base.sys.Internal != 0 {
        throw fail
    }

    let rcvd = ov.rcvd
    if rcvd == 0 : throw fail
    return rcvd

    #elif OS == macos
    while true {
        let res = sys:read(fd, buf, amount.to(u32))
        if res == 0 : throw fail
        if res < 0 {
            if sys:errno == sys:EAGAIN {
                let ev = io:await_fd(fd, true, false)
                if ev.is_closed() || !ev.is_readable() : throw fail
                continue
            }
            if sys:errno != sys:EINTR : break
            throw fail
        }
        return res.@cast(uint)
    }
    return 0
    #else
    #error "Socket recv: Unsupported OS"
    #end
}

// Receive
+ fn send(fd: FD, buf: ByteBuffer, amount: uint) uint !fail {
    if amount > buf.length : amount = buf.length
    return send_from_ptr(fd, buf.data, amount) !>
}
+ fn send_string(fd: FD, str: String) uint !fail {
    return send_from_ptr(fd, str.data, str.length) !>
}
+ fn send_from_ptr(fd: FD, buf: ptr, amount: uint) uint !fail {

    let coro = coro:current_coro.@cast(coro:Coro)

    #if OS == linux
    let sqe = io:sqe(coro) ! throw fail
    io:io_uring_prep_send(sqe, fd.@cast(i32), buf, amount.to(u32), 0)

    coro:yield()
    let sent = coro.completion_res
    if sent <= 0 : throw fail
    return sent.@cast(uint)

    #elif OS == win
    let ov = io:overlap[io:OverlapSend]
    ov.buflen = amount
    ov.buf = buf

    let res = sys:WSASend(fd, @ref(ov.buflen), 1, null, 0, ov, null)
    coro:yield()

    let flags : u32 = 0
    let ok = sys:WSAGetOverlappedResult(fd, ov, &ov.sent, true, &flags)
    if ov.base.sys.Internal != 0 {
        throw fail
    }

    let sent = ov.sent
    return sent

    #elif OS == macos
    while true {
        let res = sys:write(fd, buf, amount.to(u32))
        if res == 0 : throw fail
        if res < 0 {
            if sys:errno == sys:EAGAIN {
                let ev = io:await_fd(fd, false, true)
                if ev.is_closed() || !ev.is_readable() : throw fail
                continue
            }
            if sys:errno != sys:EINTR : break
            throw fail
        }
        return res.@cast(uint)
    }
    return 0

    #else
    #error "Socket send: Unsupported OS"
    #end
}
