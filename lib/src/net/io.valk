
header "sys" as sys

use coro
use io
use mem

#if OS == win
type ConnectExFn (fnRef(sys:SOCKET, sys:libc_gen_sockaddr, i32, ?ptr, u32, ?ptr, ?ptr)(bool))
type AcceptExFn (fnRef(sys:SOCKET, sys:SOCKET, ?ptr, u32, u32, u32, &u32, ?ptr)(bool))

global pConnectEx : ?ConnectExFn
global pAcceptEx : ?AcceptExFn

fn LoadConnectEx(s: sys:SOCKET) ConnectExFn !fail {
    let p = pConnectEx
    if isset(p) : return p
    // {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
    let guid : <sys:GUID> = @undefined
    guid.Data1 = 0x25a207b9
    guid.Data2 = 0xddf3
    guid.Data3 = 0x4660
    guid.Data4 = {0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}
    let bytes : u32 = 0
    let res = sys:WSAIoctl(s, sys:SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, size_of(<sys:GUID>), &pConnectEx, size_of(ptr), &bytes, null, null)
    if res != 0 {
        throw fail
    }
    return pConnectEx.@cast(ConnectExFn)
}

fn LoadAcceptEx(s: sys:SOCKET) AcceptExFn !fail {
    let p = pAcceptEx
    if isset(p) : return p
    // {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
    let guid : <sys:GUID> = @undefined
    guid.Data1 = 0xb5367df1
    guid.Data2 = 0xcbac
    guid.Data3 = 0x11cf
    guid.Data4 = {0x95,0xca,0x00,0x80,0x5f,0x48,0xa1,0x92}
    let bytes : u32 = 0
    let res = sys:WSAIoctl(s, sys:SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, size_of(<sys:GUID>), &pAcceptEx, size_of(ptr), &bytes, null, null)
    if res != 0 {
        throw fail
    }
    return pAcceptEx.@cast(AcceptExFn)
}
#end

fn accept(sock_fd: FD, addr: AddrInfo) FD !error {
    #if OS == win
    let fd = sys:WSASocketA(sys:AF_INET, sys:SOCK_STREAM, sys:IPPROTO_TCP, null, 0, sys:WSA_FLAG_OVERLAPPED)
    if fd == sys:INVALID_SOCKET : throw error

    sys:CreateIoCompletionPort(fd, io:iocp(), 0, 0)

    let acfn = LoadAcceptEx(sock_fd) ! {
        Socket.close(fd)
        throw error
    }
    let ov = io:overlap[io:OverlapAcceptEx]()

    // Important: buffer must be large enough for local + remote address
    // For IPv4: 2 × (sizeof(sockaddr_in) + 16) = 2 × 32 = 64 bytes minimum
    let addrLen : u32 = size_of(<sys:sockaddr_in>) + 16;
    let ok = acfn(sock_fd, fd, &ov.addressBuffer, 0, addrLen, addrLen, &ov.bytesReceived, ov)
    coro:block()

    if ov.base.sys.Internal != 0 {
        io:free_ov(ov)
        Socket.close(fd)
        throw error
    }

    io:free_ov(ov)
    return fd

    #elif OS == linux

    let coro = coro:current_coro.@cast(coro:Coro)
    let sqe = io:sqe(coro) ! throw error
    io:io_uring_prep_accept(sqe, sock_fd.@cast(i32), null, 0, 0)
    coro:block()
    let fd = coro.completion_res
    if (fd < 0) : throw error

    return fd
    #else
    while true {
        let ofd = sys:accept(io:os_fd(sock_fd), null, null)
        let fd = io:valk_fd(ofd.to(int))
        if fd == -1 {
            let err = core:libc_errno()
            if err == sys:EAGAIN {
                io:await_fd(fd, true, false)
                continue
            }
            if err == sys:EMFILE || err == sys:ENFILE {
                throw too_many_connections
            }
            throw error
        }
        return fd
    }
    throw error
    #end
}

fn connect(fd: FD, addr: AddrInfo) !error {
    #if OS == win
    let empty_addr : <sys:libc_gen_sockaddr> = @undefined
    mem:clear(empty_addr, size_of(<sys:libc_gen_sockaddr>))
    empty_addr.sa_family = sys:AF_INET

    let err = sys:bind(fd, @ref(empty_addr), size_of(<sys:libc_gen_sockaddr>))
    if err != 0 : throw error

    let confn = LoadConnectEx(fd) ! throw error

    let ov = io:overlap[io:OverlapConnectEx]()
    let ok = confn(fd, addr.sock_addr(), addr.addr_len(), null, 0, &ov.sent, ov)
    coro:block()

    if ov.base.sys.Internal != 0 {
        io:free_ov(ov)
        throw error
    }

    io:free_ov(ov)

    #elif OS == linux
    let coro = coro:current_coro.@cast(coro:Coro)
    let sqe = io:sqe(coro) ! throw error
    io:io_uring_prep_connect(sqe, fd.@cast(i32), addr.sock_addr(), addr.addr_len())
    coro:block()
    let res = coro.completion_res
    if res < 0 : throw error

    #else
    while true {
        let err = sys:connect(ofd, addr.sock_addr(), addr.addr_len())
        if err == 0 : break
        // Error
        let e = core:socket_errno()
        if e == sys:EISCONN : break
        let a = e == sys:EINPROGRESS
        if a {
            io:await_fd(fd, false, true)
            continue
        }
        throw error
    }
    #end
}
