
use ext
use coro
use io
use mem
use core

#if OS == win
type ConnectExFn (fnptr(ext:SOCKET, ext:libc_gen_sockaddr, i32, ?ptr, u32, ?ptr, ?ptr)(bool))
type AcceptExFn (fnptr(ext:SOCKET, ext:SOCKET, ?ptr, u32, u32, u32, &u32, ?ptr)(bool))

global pConnectEx : ?ConnectExFn
global pAcceptEx : ?AcceptExFn

fn LoadConnectEx(s: ext:SOCKET) ConnectExFn !fail {
    let p = pConnectEx
    if isset(p) : return p
    // {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
    let guid : <ext:GUID> = @undefined
    guid.Data1 = 0x25a207b9
    guid.Data2 = 0xddf3
    guid.Data3 = 0x4660
    guid.Data4 = {0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}
    let bytes : u32 = 0
    let res = ext:WSAIoctl(s, ext:SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, size_of(<ext:GUID>), &pConnectEx, size_of(ptr), &bytes, null, null)
    if res != 0 {
        throw fail
    }
    return pConnectEx.@cast(ConnectExFn)
}

fn LoadAcceptEx(s: ext:SOCKET) AcceptExFn !fail {
    let p = pAcceptEx
    if isset(p) : return p
    // {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
    let guid : <ext:GUID> = @undefined
    guid.Data1 = 0xb5367df1
    guid.Data2 = 0xcbac
    guid.Data3 = 0x11cf
    guid.Data4 = {0x95,0xca,0x00,0x80,0x5f,0x48,0xa1,0x92}
    let bytes : u32 = 0
    let res = ext:WSAIoctl(s, ext:SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, size_of(<ext:GUID>), &pAcceptEx, size_of(ptr), &bytes, null, null)
    if res != 0 {
        throw fail
    }
    return pAcceptEx.@cast(AcceptExFn)
}
#end

fn accept(sock_fd: FD, addr: AddrInfo) FD !error {
    #if OS == win
    let fd = ext:WSASocketA(ext:AF_INET, ext:SOCK_STREAM, ext:IPPROTO_TCP, null, 0, ext:WSA_FLAG_OVERLAPPED)
    if fd == ext:INVALID_SOCKET : throw error

    ext:CreateIoCompletionPort(fd, io:iocp(), 0, 0)

    let acfn = LoadAcceptEx(sock_fd) ! {
        Socket.close_fd(fd)
        throw error
    }

    let ov = io:overlap[io:OverlapAcceptEx]
    // Important: buffer must be large enough for local + remote address
    // For IPv4: 2 × (sizeof(sockaddr_in) + 16) = 2 × 32 = 64 bytes minimum
    let addrLen : u32 = size_of(<ext:sockaddr_in>) + 16;
    let ok = acfn(sock_fd, fd, &ov.addressBuffer, 0, addrLen, addrLen, &ov.bytesReceived, ov)
    coro:yield()

    if ov.base.sys.Internal != 0 {
        Socket.close_fd(fd)
        throw error
    }

    return fd

    #elif OS == linux

    let coro = coro:current_coro.@cast(coro:Coro)
    let sqe = io:sqe(coro) ! throw error
    io:io_uring_prep_accept(sqe, sock_fd.@cast(i32), null, 0, 0)
    coro:yield()
    let fd = coro.completion_res.to(FD)
    if (fd < 0) : throw error

    return fd
    #elif OS == macos
    while true {
        let fd = ext:accept(sock_fd, null, null)
        if fd == -1 {
            let err = ext:errno
            if err == ext:EAGAIN {
                io:await_fd(sock_fd, true, false)
                continue
            }
            if err == ext:EMFILE || err == ext:ENFILE {
                // Too many connections
                throw error
            }
            throw error
        }
        return fd
    }
    throw error
    #else
    #error "Socket accept: Unsupported OS"
    #end
}

fn connect(fd: FD, addr: AddrInfo) !error {
    #if OS == win
    let empty_addr : <ext:libc_gen_sockaddr> = @undefined
    mem:clear(empty_addr, size_of(<ext:libc_gen_sockaddr>))
    empty_addr.sa_family = ext:AF_INET

    let err = ext:bind(fd, @ref(empty_addr), size_of(<ext:libc_gen_sockaddr>))
    if err != 0 : throw error

    let confn = LoadConnectEx(fd) ! throw error

    let ov = io:overlap[io:OverlapConnectEx]
    let ok = confn(fd, addr.sock_addr(), addr.addr_len(), null, 0, &ov.sent, ov)
    coro:yield()

    if ov.base.sys.Internal != 0 {
        throw error
    }

    #elif OS == linux
    let coro = coro:current_coro.@cast(coro:Coro)
    let sqe = io:sqe(coro) ! throw error
    io:io_uring_prep_connect(sqe, fd, addr.sock_addr(), addr.addr_len())
    coro:yield()
    let res = coro.completion_res
    if res < 0 : throw error

    #elif OS == macos
    while true {
        let err = ext:connect(fd, addr.sock_addr(), addr.addr_len())
        if err == 0 : break
        // Error
        if ext:errno == ext:EISCONN : break
        if ext:errno == ext:EINPROGRESS {
            io:await_fd(fd, false, true)
            continue
        }
        throw error
    }
    #else
    #error "Socket connect: Unsupported OS"
    #end
}

// Receive
+ fn recv(fd: FD, buf: ByteBuffer, amount: uint) uint !fail {
    buf.minimum_free_space(amount)
    let res = recv_to_ptr(fd, buf.data.@offset(buf.length), amount) !>
    buf.length += res
    return res
}
+ fn recv_to_ptr(fd: FD, buf: ptr, amount: uint) uint !fail {

    let coro = coro:current_coro.@cast(coro:Coro)

    #if OS == macos
    while true {
        let res = ext:read(fd, buf, amount.to(u32))
        if res == 0 : throw fail
        if res < 0 {
            if ext:errno == ext:EAGAIN {
                let ev = io:await_fd(fd, true, false)
                if ev.is_closed() || !ev.is_readable() : throw fail
                continue
            }
            if ext:errno != ext:EINTR : break
            throw fail
        }
        return res.@cast(uint)
    }
    throw fail

    #elif OS == linux
    let sqe = io:sqe(coro) ! throw fail
    io:io_uring_prep_recv(sqe, fd.@cast(i32), buf, amount.to(u32), 0)

    coro:yield()
    let rcvd = coro.completion_res
    if rcvd <= 0 : throw fail
    return rcvd.@cast(uint)

    #elif OS == win
    let ov = io:overlap[io:OverlapRecv]
    ov.buflen = amount
    ov.buf = buf

    let res = ext:WSARecv(fd, @ref(ov.buflen), 1, null, &ov.flags, ov, null)
    coro:yield()

    let ok = ext:WSAGetOverlappedResult(fd, ov, &ov.rcvd, true, &ov.flags)
    if ov.base.sys.Internal != 0 {
        throw fail
    }

    let rcvd = ov.rcvd
    if rcvd == 0 : throw fail
    return rcvd
    #else
    #error "Socket recv: Unsupported OS"
    #end
}

// Receive
+ fn send(fd: FD, buf: ByteBuffer, amount: uint) uint !fail {
    if amount > buf.length : amount = buf.length
    return send_from_ptr(fd, buf.data, amount) !>
}
+ fn send_string(fd: FD, str: String) uint !fail {
    return send_from_ptr(fd, str.data, str.length) !>
}
+ fn send_from_ptr(fd: FD, buf: ptr, amount: uint) uint !fail {

    let coro = coro:current_coro.@cast(coro:Coro)

    #if OS == macos
    while true {
        let res = ext:write(fd, buf, amount.to(u32))
        if res == 0 : throw fail
        if res < 0 {
            if ext:errno == ext:EAGAIN {
                let ev = io:await_fd(fd, false, true)
                if ev.is_closed() || !ev.is_readable() : throw fail
                continue
            }
            if ext:errno != ext:EINTR : break
            throw fail
        }
        return res.@cast(uint)
    }
    throw fail

    #elif OS == linux
    let sqe = io:sqe(coro) ! throw fail
    io:io_uring_prep_send(sqe, fd.@cast(i32), buf, amount.to(u32), 0)

    coro:yield()
    let sent = coro.completion_res
    if sent <= 0 : throw fail
    return sent.@cast(uint)

    #elif OS == win
    let ov = io:overlap[io:OverlapSend]
    ov.buflen = amount
    ov.buf = buf

    let res = ext:WSASend(fd, @ref(ov.buflen), 1, null, 0, ov, null)
    coro:yield()

    let flags : u32 = 0
    let ok = ext:WSAGetOverlappedResult(fd, ov, &ov.sent, true, &flags)
    if ov.base.sys.Internal != 0 {
        throw fail
    }

    let sent = ov.sent
    return sent

    #else
    #error "Socket send: Unsupported OS"
    #end
}
