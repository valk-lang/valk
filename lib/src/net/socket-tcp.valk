
header "sys" as sys

use core
use coro
use io
use mem

#if OS == win
type ConnectExFn (fnRef(sys:SOCKET, sys:libc_gen_sockaddr, i32, ?ptr, u32, ?ptr, ?ptr)(bool))
type AcceptExFn (fnRef(sys:SOCKET, sys:SOCKET, ?ptr, u32, u32, u32, &u32, ?ptr)(bool))

global pConnectEx : ?ConnectExFn
global pAcceptEx : ?AcceptExFn

fn LoadConnectEx(s: sys:SOCKET) ConnectExFn !fail {
    let p = pConnectEx
    if isset(p) : return p
    // {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
    let guid : <sys:GUID> = @undefined
    guid.Data1 = 0x25a207b9
    guid.Data2 = 0xddf3
    guid.Data3 = 0x4660
    guid.Data4 = {0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}
    let bytes : u32 = 0
    let res = sys:WSAIoctl(s, sys:SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, size_of(<sys:GUID>), &pConnectEx, size_of(ptr), &bytes, null, null)
    if res != 0 {
        throw fail
    }
    return pConnectEx.@cast(ConnectExFn)
}

fn LoadAcceptEx(s: sys:SOCKET) AcceptExFn !fail {
    let p = pAcceptEx
    if isset(p) : return p
    // {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
    let guid : <sys:GUID> = @undefined
    guid.Data1 = 0xb5367df1
    guid.Data2 = 0xcbac
    guid.Data3 = 0x11cf
    guid.Data4 = {0x95,0xca,0x00,0x80,0x5f,0x48,0xa1,0x92}
    let bytes : u32 = 0
    let res = sys:WSAIoctl(s, sys:SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, size_of(<sys:GUID>), &pAcceptEx, size_of(ptr), &bytes, null, null)
    if res != 0 {
        throw fail
    }
    return pAcceptEx.@cast(AcceptExFn)
}
#end

class SocketTCP {
    ~ host: String
    ~ fd: FD
    ~ port: u16
    - addrinfo: AddrInfo
    - closed: bool (false)

    + static fn new(host: String, port: u16) SocketTCP !os_socket_create !invalid_host {
        // 
        #if OS == win
        core:WSA.init()
        #end

        // Get host info
        let addrinfo = AddrInfo.new(host, port) ! throw invalid_host

        #if OS == win
        let sock_fd = sys:WSASocketA(sys:AF_INET, sys:SOCK_STREAM, sys:IPPROTO_TCP, null, 0, sys:WSA_FLAG_OVERLAPPED)
        let fd : FD = io:valk_fd(sock_fd.to(int))
        if sock_fd == sys:INVALID_SOCKET {
            throw os_socket_create
        }
        sys:CreateIoCompletionPort(sock_fd, io:iocp(), 0, 0)

        #else
        let ufd = sys:socket(sys:AF_INET, sys:SOCK_STREAM, 0)
        let fd : FD = ufd.@cast(FD)
        #end

        if fd == -1 : throw os_socket_create
        #if OS != win
        io:set_non_block(fd, true)
        #end

        // Set timeout
        #if OS == win
        let timeout : i32 = 1000 * 5 // 5 seconds
        sys:setsockopt(sock_fd, sys:SOL_SOCKET, sys:SO_RCVTIMEO, @ref(timeout), size_of(i32))
        #else
        let timeout = @stack(<sys:libc_timeval>)
        timeout.tv_sec = 5
        timeout.tv_usec = 0
        sys:setsockopt(ufd, sys:SOL_SOCKET, sys:SO_RCVTIMEO, timeout, size_of(<sys:libc_timeval>))
        #end

        // SO_NOSIGPIPE
        #if OS == macos
        let nosigv : i32 = 1
        sys:setsockopt(ufd, sys:SOL_SOCKET, sys:SO_NOSIGPIPE, @ref(nosigv), size_of(i32))
        #end

        return SocketTCP{
            host: host
            port: port
            fd: fd
            addrinfo: addrinfo
        }
    }

    + fn close() {
        if this.closed : return
        this.closed = true
        Socket.close(this.fd)
    }

    fn gc_free() {
        this.close()
    }

    + fn connect() Connection !closed !connection_failed {

        if this.closed : throw closed

        let fd = this.fd
        let ofd = io:os_fd(this.fd)

        while true {
            #if OS == win
            let addr : <sys:libc_gen_sockaddr> = @undefined
            mem:clear(addr, size_of(<sys:libc_gen_sockaddr>))
            addr.sa_family = sys:AF_INET

            let err = sys:bind(fd, @ref(addr), size_of(<sys:libc_gen_sockaddr>))
            if err != 0 {
                throw connection_failed
            }

            let confn = LoadConnectEx(fd) ! {
                Socket.close(fd)
                throw connection_failed
            }

            let ov = io:overlap[io:OverlapConnectEx]()
            let ok = confn(fd, this.addrinfo.sock_addr(), size_of(<sys:sockaddr_in>), null, 0, &ov.sent, ov)
            coro:block()

            if ov.base.sys.Internal != 0 {
                io:free_ov(ov)
                Socket.close(fd)
                throw connection_failed
            }

            io:free_ov(ov)
            break

            #else
            let err = sys:connect(ofd, this.addrinfo.sock_addr(), this.addrinfo.addr_len())
            if err == 0 : break
            // Error
            let e = core:socket_errno()
            if e == sys:EISCONN : break
            let a = e == sys:EINPROGRESS
            if a {
                coro:await_fd(fd, false, true)
                continue
            }
            throw connection_failed
            #end
        }

        this.closed = true // The connection will close the FD
        return Connection.new(this.fd)
    }

    + fn bind() !closed !bind !listen {

        if this.closed : throw closed

        let yes : i32 = 1
        let yes_ptr = @ref(yes)
        
        let err : i32 = 0

        sys:setsockopt(io:os_fd(this.fd), sys:SOL_SOCKET, sys:SO_REUSEADDR, yes_ptr, size_of(i32))

        err = sys:bind(io:os_fd(this.fd), this.addrinfo.sock_addr(), this.addrinfo.addr_len())
        if err != 0 : throw bind

        err = sys:listen(io:os_fd(this.fd), 2000000)
        if err != 0 : throw listen
    }

    + fn accept() Connection !too_many_connections !error !closed {

        if this.closed : throw closed

        let sock_fd = this.fd

        while true {
            #if OS == win

            let fd = sys:WSASocketA(sys:AF_INET, sys:SOCK_STREAM, sys:IPPROTO_TCP, null, 0, sys:WSA_FLAG_OVERLAPPED)
            if fd == sys:INVALID_SOCKET {
                throw error
            }

            sys:CreateIoCompletionPort(fd, io:iocp(), 0, 0)

            let acfn = LoadAcceptEx(sock_fd) ! {
                Socket.close(fd)
                throw error
            }
            let ov = io:overlap[io:OverlapAcceptEx]()

            // Important: buffer must be large enough for local + remote address
            // For IPv4: 2 × (sizeof(sockaddr_in) + 16) = 2 × 32 = 64 bytes minimum
            let addrLen : u32 = size_of(<sys:sockaddr_in>) + 16;
            let ok = acfn(sock_fd, fd, &ov.addressBuffer, 0, addrLen, addrLen, &ov.bytesReceived, ov)
            coro:block()

            if ov.base.sys.Internal != 0 {
                io:free_ov(ov)
                Socket.close(fd)
                throw error
            }

            io:free_ov(ov)
            return Connection.new(fd)

            #else
            let ofd = sys:accept(io:os_fd(this.fd), null, null)
            let fd = io:valk_fd(ofd.to(int))
            if fd == -1 {
                let err = core:libc_errno()
                if err == sys:EAGAIN {
                    coro:await_fd(this.fd, true, false)
                    continue
                }
                if err == sys:EMFILE || err == sys:ENFILE {
                    throw too_many_connections
                }
                throw error
            }

            return Connection.new(fd)
            #end
        }
        throw error
    }

    // fn clone() SELF {
    //     return SELF {
    //         host: this.host
    //         fd: this.fd
    //         port: this.port
    //         addrinfo: SELF.get_addrinfo(this.host, this.port) !? this.addrinfo.@cast(sys:libc_addrinfo_fix)
    //     }
    // }
}
