
use fs

shared ca_cert : ?String
global ca_dirs : ?Array[String]
global ca_paths : ?Array[String]

+ fn set_ca_cert_path(path: ?String) {
    ca_cert = path
}

+ class SSL {
    ~ ctx: OSSL
    ~ ssl: OSSL
    - host: String
    - ca_cert_path: ?String

    + static fn ca_paths() Array[String] {
        let paths = ca_paths
        if isset(paths) : return paths
        // List
        paths = Array[String]{}
        // Default
        let x509_default : String = X509_get_default_cert_file()
        paths.append(x509_default)
        // Macos
        #if OS == macos
        paths.append("/usr/local/etc/ca-certificates/cert.pem")
        paths.append("/etc/ssl/cert.pem")
        #end
        // Linux
        #if OS == linux
        paths.append("/etc/ssl/certs/ca-certificates.crt")
        paths.append("/etc/pki/tls/certs/ca-bundle.crt")
        paths.append("/etc/ssl/ca-bundle.pem")
        paths.append("/etc/pki/tls/cacert.pem")
        paths.append("/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem")
        paths.append("/etc/ssl/cert.pem")
        #end
        // Exe
        paths.append(fs:add(fs:exe_dir(), "cacert.pem"))

        ca_paths = paths
        return paths
    }

    static fn try_ca_path(ctx: SSL_CTX, path: ?String) bool {
        if !isset(path) : return false
        #if OS == win
        if path.starts_with("\\\\") : return false
        #end
        return SSL_CTX_load_verify_locations(ctx, path.data, null) == 1
    }

    static fn new(fd: FD, host: String, ca_path: ?String (null)) SSL {
        let method = TLS_client_method()
        let ctx = SSL_CTX_new(method)

        // CA cert path
        // User defined cert
        if SELF.try_ca_path(ctx, ca_path) {
        } else {

            let found = false
            let ca_paths = SELF.ca_paths()
            each ca_paths as path {
                if SELF.try_ca_path(ctx, path.data_cstring) {
                    ca_path = path
                    found = true
                    break
                }
            }

            if !found {
                SSL_CTX_set_default_verify_paths(ctx)
            }
        }

        // Verify settings
        SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, null);

        // Ciphers
        // SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MIN_PROTO_VERSION, TLS1_2_VERSION, null)
        // SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv3);

        // Init SSL
        let ssl = SSL_new(ctx)
        SSL_set_fd(ssl, fd.@cast(i32))
        SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_HOSTNAME, TLSEXT_NAMETYPE_host_name, host.data)

        return SSL {
            ctx: ctx
            ssl: ssl
            host: host
            ca_cert_path: ca_path
        }
    }

    + static fn last_error_msg() String {
        let e : uint = ERR_get_error()
        let msg = ERR_error_string(e, null)
        return msg
    }

    fn gc_free() {
        SSL_free(this.ssl)
        SSL_CTX_free(this.ctx);
    }
}
