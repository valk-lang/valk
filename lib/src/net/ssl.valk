
header "openssl" as ossl

use fs

shared ca_cert : ?String (null)

+ fn set_ca_cert_path(path: ?String) {
    ca_cert = path
}

class SSL {
    ~ ssl: ossl:SSL
    - host: String
    - ca_cert_path: ?String

    static fn new(fd: FD, host: String, ca_cert_path: ?String (null)) SSL {
        let method = ossl:TLS_client_method()
        let ctx = ossl:SSL_CTX_new(method)

        // CA cert path
        #if OS == win
        let exe_path = fs:exe_dir() + "/cacert.pem"
        #end

        let found = false
        if !found && isset(ca_cert_path) && !ca_cert_path.starts_with("\\\\") && ossl:SSL_CTX_load_verify_locations(ctx, ca_cert_path.data_ptr(), null) == 1 {
            found = true
        }

        #if OS == win
        if !found && !exe_path.starts_with("\\\\") && ossl:SSL_CTX_load_verify_locations(ctx, exe_path.data_ptr(), null) == 1 {
            ca_cert_path = exe_path
        }
        #end

        if !found && ossl:SSL_CTX_set_default_verify_paths(ctx) == 1 : {
            found = true
        }

        // Verify settings
        ossl:SSL_CTX_set_verify(ctx, ossl:SSL_VERIFY_PEER, null);

        // Ciphers
        // ossl:SSL_CTX_ctrl(ctx, ossl:SSL_CTRL_SET_MIN_PROTO_VERSION, ossl:TLS1_2_VERSION, null)
        // ossl:SSL_CTX_set_options(ctx, ossl:SSL_OP_NO_SSLv3);

        // Init SSL
        let ssl = ossl:SSL_new(ctx)
        ossl:SSL_set_fd(ssl, fd.@cast(i32))
        ossl:SSL_ctrl(ssl, ossl:SSL_CTRL_SET_TLSEXT_HOSTNAME, ossl:TLSEXT_NAMETYPE_host_name, host.data_ptr())

        return SSL {
            ssl: ssl
            host: host
            ca_cert_path: ca_cert_path
        }
    }

    fn gc_free() {
        ossl:SSL_free(this.ssl)
    }
}
