
header "sys" as sys

use io

+ enum SOCKET_TYPE {
    TCP
}

+ class Socket {
    ~ host: String
    ~ fd: FD
    ~ port: u16
    - addrinfo: AddrInfo
    - closed: bool (false)

    + static fn server(type: SOCKET_TYPE, host: String, port: u16) SocketServer !invalid_host !create !bind !listen !closed {

        let socket = SELF.create(type, host, port) !>
        socket.bind() !>

        return SocketServer {
            socket: socket
        }
    }

    + static fn client(type: SOCKET_TYPE, host: String, port: u16) Connection !invalid_host !create !connect !closed {
        let socket = SELF.create(type, host, port) !>
        let con = socket.connect() !>
        return con
    }

    static fn create(type: SOCKET_TYPE, host: String, port: u16) Socket !invalid_host !create {
        // 
        #if OS == win
        WSA.init()
        #end

        // Get host info
        let addrinfo = AddrInfo.new(host, port) ! throw invalid_host

        #if OS == win
        let fd = sys:WSASocketA(sys:AF_INET, sys:SOCK_STREAM, sys:IPPROTO_TCP, null, 0, sys:WSA_FLAG_OVERLAPPED)
        if fd == sys:INVALID_SOCKET : throw create
        sys:CreateIoCompletionPort(fd, io:iocp(), 0, 0)

        #else
        let fd = sys:socket(sys:AF_INET, sys:SOCK_STREAM, 0)
        #end

        if fd == -1 : throw create
        #if OS == macos
        io:set_non_block(fd, true)
        #end

        // Set timeout
        #if OS == win
        let timeout : i32 = 1000 * 5 // 5 seconds
        sys:setsockopt(fd, sys:SOL_SOCKET, sys:SO_RCVTIMEO, @ref(timeout), size_of(i32))
        #else
        let timeout = @stack(<sys:libc_timeval>)
        timeout.tv_sec = 5
        timeout.tv_usec = 0
        sys:setsockopt(fd, sys:SOL_SOCKET, sys:SO_RCVTIMEO, timeout, size_of(<sys:libc_timeval>))
        #end

        // SO_NOSIGPIPE
        #if OS == macos
        let nosigv : i32 = 1
        sys:setsockopt(fd, sys:SOL_SOCKET, sys:SO_NOSIGPIPE, @ref(nosigv), size_of(i32))
        #end

        return Socket {
            host: host
            port: port
            fd: fd
            addrinfo: addrinfo
        }
    }

    fn bind() !closed !bind !listen {

        if this.closed : throw closed

        let yes : i32 = 1
        let err : i32 = 0

        sys:setsockopt(this.fd, sys:SOL_SOCKET, sys:SO_REUSEADDR, @ref(yes), size_of(i32))

        err = sys:bind(this.fd, this.addrinfo.sock_addr(), this.addrinfo.addr_len())
        if err != 0 : throw bind

        err = sys:listen(this.fd, 2000000)
        if err != 0 : throw listen
    }

    fn connect() Connection !closed !connect {

        if this.closed : throw closed

        let fd = this.fd
        connect(fd, this.addrinfo) ! {
            this.close()
            throw connect
        }

        this.closed = true // The connection will close the FD
        return Connection.new(fd)
    }

    + fn close() void {
        if this.closed : return
        this.closed = true
        SELF.close_fd(this.fd)
    }

    + static fn close_fd(fd: FD) void {
        #if OS == win
        sys:closesocket(fd.@cast(uint))
        #else
        sys:shutdown(fd, sys:O_RDWR)
        io:close(fd)
        #end
    }
}
