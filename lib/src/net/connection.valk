
header "sys" as sys
header "openssl" as ossl

use io
use utils

class Connection {
    ~ fd: FD
    ~ ssl: ?SSL (null)
    ~ ssl_enabled: bool (false)
    - closed: bool (false)

    + static fn new(fd: FD) Connection {
        #if OS == macos
        io:set_non_block(fd, true)
        #end
        return Connection {
            fd: fd
        }
    }

    + fn close() {
        if this.closed : return
        this.closed = true
        Socket.close(this.fd)
    }

    fn gc_free() {
        this.close()
    }

    + fn ssl_connect(host: String, ca_cert_path: ?String (null)) !ssl_error {

        let fd = this.fd
        #if OS == macos
        io:set_non_block(fd, false)
        #end

        if this.ssl_enabled : return

        let ssl = SSL.new(fd, host, ca_cert_path)

        let err = ossl:SSL_connect(ssl.ssl)
        if err != 1 {
            let ssl_err = ossl:SSL_get_error(ssl.ssl, err);

            let msg : ?String = null
            let e : uint = ossl:ERR_get_error()
            if e != 0 {
                msg = ossl:ERR_error_string(e, null)
            }
            throw ssl_error, msg ?? ("SSL error code: " + ssl_err)
        }
        this.ssl = ssl
        this.ssl_enabled = true

        #if OS == macos
        io:set_non_block(fd, true)
        #end
    }

    + fn send(data: String) !connection {
        this.send_bytes(data.data, data.bytes, true) ! throw connection
    }
    + fn send_buffer(data: utils:ByteBuffer, skip_bytes: uint, send_all: bool) uint !connection {
        return this.send_bytes(data.data.offset(skip_bytes), data.length - skip_bytes, send_all) ! throw connection
    }

    + fn send_bytes(data: ptr, bytes: uint, send_all: bool) uint !connection !closed {

        if this.closed : throw closed

        if bytes == 0 : return 0
        let ssl = this.ssl
        let bytes_sent : uint = 0
        let bytes_to_send : uint = bytes

        while true {
            //////////////
            // SSL
            //////////////
            if isset(ssl) {
                let wbytes = ossl:SSL_write(ssl.ssl, data, bytes_to_send);
                if wbytes < 0 {
                    // SSL_ERROR_WANT_WRITE: 3
                    let err = ossl:SSL_get_error(ssl.ssl, wbytes);
                    if err == 3 {
                        // EAGAIN
                        #if OS != macos
                        continue
                        #else
                        let ev = io:await_fd(this.fd, false, true)
                        if ev.is_closed() || !ev.is_writable() : throw closed
                        continue
                        #end
                    }
                    throw connection;
                }

                let new_bytes = wbytes.@cast(uint)
                bytes_sent += new_bytes
                if bytes_sent == bytes : break
                if bytes_sent < bytes {
                    data += new_bytes
                    bytes_to_send -= new_bytes
                    if send_all : continue
                    break
                }

                throw connection
            }

            //////////////
            // NO SSL
            //////////////

            let wbytes = send_from_ptr(this.fd, data, bytes_to_send) ! {
                if E == E.again {
                    // EAGAIN
                    let ev = io:await_fd(this.fd, true, false)
                    if ev.is_closed() || !ev.is_readable() {
                        throw closed
                    }
                    if !ev.is_readable() {
                        throw closed
                    }
                    continue
                }
                throw connection
            }

            let new_bytes = wbytes.@cast(uint)
            bytes_sent += new_bytes
            if bytes_sent == bytes : break
            if bytes_sent < bytes {
                data += new_bytes
                bytes_to_send -= new_bytes
                if send_all : continue
                break
            }

            throw connection
        }

        return bytes_sent
    }

    + fn recv(buffer: utils:ByteBuffer, bytes: uint) uint !connection !closed {

        if this.closed : throw closed

        buffer.minimum_free_space(bytes)
        let count : uint = 0
        let ssl = this.ssl;
        let err : i32 = 0

        while true {
            //////////////
            // SSL
            //////////////
            if isset(ssl) {
                let rcvd = ossl:SSL_read(ssl.ssl, buffer.data.offset(buffer.length), bytes);
                if rcvd <= 0 {
                    // SSL_ERROR_NONE: 0
                    // SSL_ERROR_WANT_READ: 2
                    // SSL_ERROR_ZERO_RETURN: 6
                    err = ossl:SSL_get_error(ssl.ssl, rcvd);
                    if err == 2 {
                        #if OS != macos
                        continue
                        #else
                        let ev = io:await_fd(this.fd, true, false)
                        if ev.is_closed() || !ev.is_readable() : throw closed
                        continue
                        #end
                    }
                    throw connection, "SSL Error #" + err;
                }
                count = rcvd.@cast(uint)
                buffer.length += count
                break
            }

            //////////////
            // NO SSL
            //////////////

            count = recv(this.fd, buffer, bytes) ! {
                if E == E.again {
                    // EAGAIN
                    let ev = io:await_fd(this.fd, true, false)
                    if ev.is_closed() || !ev.is_readable() {
                        throw closed
                    }
                    if !ev.is_readable() {
                        throw closed
                    }
                    continue
                }
                throw connection
            }
            break
        }
            
        return count
    }
}
