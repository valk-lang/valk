
use ext
header "openssl" as ossl

use io

+ class Connection {
    ~ fd: FD
    ~ ssl: ?SSL (null)
    ~ ssl_enabled: bool (false)
    - closed: bool (false)

    + static fn new(fd: FD) Connection {
        #if OS == macos
        io:set_non_block(fd, true)
        #end
        return Connection {
            fd: fd
        }
    }

    + fn close() {
        if this.closed : return
        this.closed = true
        Socket.close_fd(this.fd)
    }

    fn gc_free() {
        this.close()
    }

    + fn ssl_connect(host: String, ca_cert_path: ?String (null)) !ssl_error {

        if this.ssl_enabled : return

        let ssl = SSL.new(this.fd, host, ca_cert_path)

        while true {
            let res = ossl:SSL_connect(ssl.ssl)
            if res != 1 {
                let err = ossl:SSL_get_error(ssl.ssl, res)
                if err == ossl:ERROR.WANT_READ {
                    let fd = ossl:SSL_get_fd(ssl.ssl)
                    if fd == -1 : throw ssl_error, "SSL missing FD"
                    io:await_fd(fd, true, false)
                    continue
                }
                if err == ossl:ERROR.WANT_WRITE {
                    let fd = ossl:SSL_get_fd(ssl.ssl)
                    if fd == -1 : throw ssl_error, "SSL missing FD"
                    io:await_fd(fd, false, true)
                    continue
                }
                throw ssl_error, "SSL connect failed | Error code: " + err + " | Message: " + SSL.last_error_msg()
            }
            break
        }
        this.ssl = ssl
        this.ssl_enabled = true
    }

    + fn send(data: String) !connection {
        this.send_bytes(data.data, data.bytes, true) ! throw connection
    }
    + fn send_buffer(data: ByteBuffer, skip_bytes: uint, send_all: bool) uint !connection {
        return this.send_bytes(data.data.@offset(skip_bytes), data.length - skip_bytes, send_all) ! throw connection
    }

    + fn send_bytes(data: ptr, bytes: uint, send_all: bool) uint !connection !closed {

        if this.closed : throw closed

        if bytes == 0 : return 0
        let ssl = this.ssl
        let bytes_sent : uint = 0
        let bytes_to_send : uint = bytes

        while true {
            //////////////
            // SSL
            //////////////
            if isset(ssl) {
                let wbytes = ossl:SSL_write(ssl.ssl, data, bytes_to_send);
                if wbytes < 0 {
                    // SSL_ERROR_WANT_WRITE: 3
                    let err = ossl:SSL_get_error(ssl.ssl, wbytes);
                    if err == 3 {
                        // EAGAIN
                        #if OS != macos
                        continue
                        #else
                        let ev = io:await_fd(this.fd, false, true)
                        if ev.is_closed() || !ev.is_writable() : throw closed
                        continue
                        #end
                    }
                    throw connection;
                }

                let new_bytes = wbytes.@cast(uint)
                bytes_sent += new_bytes
                if bytes_sent == bytes : break
                if bytes_sent < bytes {
                    data += new_bytes
                    bytes_to_send -= new_bytes
                    if send_all : continue
                    break
                }

                throw connection
            }

            //////////////
            // NO SSL
            //////////////

            let wbytes = send_from_ptr(this.fd, data, bytes_to_send) ! throw connection

            let new_bytes = wbytes.@cast(uint)
            bytes_sent += new_bytes
            if bytes_sent == bytes : break
            if bytes_sent < bytes {
                data += new_bytes
                bytes_to_send -= new_bytes
                if send_all : continue
                break
            }

            throw connection
        }

        return bytes_sent
    }

    + fn recv(buffer: ByteBuffer, bytes: uint) uint !connection !closed {

        if this.closed : throw closed

        buffer.minimum_free_space(bytes)
        let count : uint = 0
        let ssl = this.ssl;
        let err : i32 = 0

        while true {
            //////////////
            // SSL
            //////////////
            if isset(ssl) {
                let rcvd = ossl:SSL_read(ssl.ssl, buffer.data.@offset(buffer.length), bytes);
                if rcvd <= 0 {
                    // SSL_ERROR_NONE: 0
                    // SSL_ERROR_WANT_READ: 2
                    // SSL_ERROR_ZERO_RETURN: 6
                    err = ossl:SSL_get_error(ssl.ssl, rcvd);
                    if err == 2 {
                        #if OS != macos
                        continue
                        #else
                        let ev = io:await_fd(this.fd, true, false)
                        if ev.is_closed() || !ev.is_readable() : throw closed
                        continue
                        #end
                    }
                    throw connection, "SSL Error #" + err;
                }
                count = rcvd.@cast(uint)
                buffer.length += count
                break
            }

            //////////////
            // NO SSL
            //////////////

            count = recv(this.fd, buffer, bytes) ! throw connection
            break
        }
            
        return count
    }
}
