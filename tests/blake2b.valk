
use valk:crypto

test "Blake2" {
    // test_blake2b_out_size()
}

fn test_blake2b_out_size() {
    let input : [u8 x 256] = [0...]

    let str = "Hello"
    let i = 0
    while i < str.length {
        let out_size = i+1;
        let out : [u8 x crypto:OUT_BYTES] = [0...]
        let h = crypto:Blake2b.new(out_size);
        h.update(&input, input.$length);
        h.finalize(&out, out_size);
        // assert_eq!(&out[..out_size], kat::BLAKE2B_KAT_OUT_SIZE[i]);
        i++
    }
}

// fn test_blake2b_kat() {
//     let mut input = [0u8; 256];
//     for i in 0..input.len() {
//         input[i] = i as u8;
//     }

//     for i in 0..kat::BLAKE2B_KAT.len() {
//         let mut h = Blake2b::new(OUT_BYTES);
//         let mut out = [0u8; OUT_BYTES];
//         h.update(&input[..i]);
//         h.finalize(&mut out);
//         assert_eq!(out.as_ref(), kat::BLAKE2B_KAT[i].as_ref());
//     }
// }

// fn test_blake2b_keyed_kat() {
//     let mut input = [0u8; 256];
//     let mut key = [0u8; KEY_BYTES];

//     for i in 0..input.len() {
//         input[i] = i as u8;
//     }

//     for i in 0..key.len() {
//         key[i] = i as u8;
//     }

//     for i in 0..kat::BLAKE2B_KEYED_KAT.len() {
//         let mut h = Blake2b::new_with_key(OUT_BYTES, key.as_ref());
//         let mut out = [0u8; OUT_BYTES];
//         h.update(&input[..i]);
//         h.finalize(&mut out);
//         assert_eq!(out.as_ref(), kat::BLAKE2B_KEYED_KAT[i].as_ref());
//     }
// }