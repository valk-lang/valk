
use valk:coro
use valk:gc
use valk:time

global coro_test_str: String ("")

fn coro_test() {
    coro_test_str += "_2"
    coro:await_last()
    coro_test_str += "_4"
}

fn coro_val(suffix: String) String {
    return "a" + suffix
}

fn coro_throw(suffix: String) String !testerr {
    throw testerr, "throw_msg"
}

fn coro_cothrow(suffix: String) String {
    cothrow testerr, "cothrow_msg"
}

test "Coro: basics" {
    coro_test_str = "1"
    let coro = co coro_test()
    coro_test_str += "_3"
    await coro
    assert(coro_test_str == "1_2_3_4")
}

test "Coro: await" {
    let task = co coro_val("x")
    let res = await task
    assert(res == "ax")
}

test "Coro: throw" {
    let task = co coro_throw("x")
    let res = await task !? <{
        assert(error_is(E, testerr))
        assert(EMSG == "throw_msg")
        return "z"
    }
    assert(res == "z")
}

test "Coro: cothrow" {
    let task = co coro_cothrow("x")
    let res = await task !? <{
        assert(error_is(E, testerr))
        assert(EMSG == "cothrow_msg")
        return "z"
    }
    assert(res == "z")
}

global coro_leaks : uint (0)
class CoroLeak {
    value: String
    fn gc_free() { atomic(coro_leaks + 1) }
}

fn startcoro() co(String) {
    let l = CoroLeak{ value: "ABC" }
    let c = co fn() String {
        time:sleep_ms(10) // Give back control to parent function
        let z = l
        return z.value
    }()
    return c
}

test "Coro: closure leak" {
    let c = startcoro()
    assert(coro_leaks == 0)
    gc:collect()
    assert(coro_leaks == 0)
    let a = await c
    // assert(coro_leaks == 0)
    gc:collect()
    assert(coro_leaks == 1)
    assert(a == "ABC")
}
