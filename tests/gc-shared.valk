
@ignore_access

use valk:gc
use valk:thread
use valk:core

@shared shared_test_node : ?Node (null)

fn shared_1() {
    shared_test_node = Node.tree(12)
}
fn shared_2() {
    let i = 0
    while i++ < 10 {
        shared_test_node = Node.tree(12)
    }
}

test "GC: Shared Leaks" {
    // Record before memory usage
    let before = gc:mem_shared
    // Create some shared memory
    shared_1()
    // Record new memory usage
    let before2 = gc:mem_shared
    assert(before2 > before)
    // Create much more shared memory
    shared_2()
    // Test shared memory amount
    gc:collect_shared()
    assert(gc:mem_shared == before2)
    // Remove shared memory test
    shared_test_node = null
    gc:collect_shared()
    assert(gc:mem_shared <= before + 100)
}

@shared shared_node : ?Node (null)
@shared shared_lock : core:Mutex[void] (core:Mutex[void].new()) 

fn spam_shared_memory() {
    shared_lock.lock()
    shared_lock.unlock()
    let i = 0
    while i++ < 20 {
        shared_node = Node.tree(8)
    }
}

test "GC: Shared Leaks Multi Thread" {

    shared_lock.lock()
    let tt = array[thread:Thread]{}
    let i = 0
    while i++ < 4 {
        let t = thread:start(fn() {
            spam_shared_memory()
        })
        tt.push(t)
    }
    shared_lock.unlock()
    each tt as t {
        t.wait()
    }

    gc:collect_shared()
    shared_node = null
    gc:collect_shared()
    // TODO : asserts
    // But first we need a proper gc:shutdown
}
