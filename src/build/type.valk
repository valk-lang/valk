
use helper

struct Type {
    type: int
    build: Build
    array_of: ?Type (null)
    array_size: uint (0)
    func_info: ?FuncInfo (null)
    class: ?Class (null)
    sub_types: ?Array[Type] (null)
    is_pointer: bool (false)
    nullable: bool (false)
    is_signed: bool (false)

    static fn new(b: Build, type: int) Type {
        return Type {
            type: type
            build: b
        }
    }

    fn size() uint {
        if this.is_pointer {
            return this.build.ptr_size
        }
        let array_of = this.array_of
        if isset(array_of) {
            return array_of.size() * this.array_size
        }
        let class = this.class
        if isset(class) {
            return class.size
        }
        return 0
    }

    fn clone() Type {
        let type = Type.new(this.build, this.type)
        type.array_of = this.array_of
        type.array_size = this.array_size
        type.func_info = this.func_info
        type.class = this.class
        type.is_pointer = this.is_pointer
        type.nullable = this.nullable
        type.is_signed = this.is_signed
        return type
    }

    fn is_void() bool {
        return this.type == ty_void
    }
    fn is_undefined() bool {
        return this.type == ty_undefined
    }
    fn is_gc() bool {
        if this.type == ty_class && this.is_pointer {
            let class = this.class
            if !isset(class) : panic("Type has no class: " + this + " (bug)")
            return true
            // return class.size > 0
        }
        return false
    }
    fn is_ptr() bool {
        return this.type == ty_ptr
    }
    fn is_int() bool {
        return this.type == ty_int && !this.is_pointer
    }
    fn is_float() bool {
        return this.type == ty_float && !this.is_pointer
    }
    fn is_number() bool {
        return (this.type == ty_int || this.type == ty_float) && !this.is_pointer
    }
    fn is_bool() bool {
        return this.type == ty_bool && !this.is_pointer
    }
    fn is_struct_type() bool {
        return this.type == ty_struct
    }
    fn allow_math() bool {
        return this.type == ty_ptr || this.is_number()
    }
    fn fits_eax() bool {
        return true
    }

    fn _string() String {
        return this.str()
    }
    fn str() String {
        let t = this.type
        if t == ty_void : return "void"
        if t == ty_undefined : return "@undefined"
        if t == ty_error : return "<error>"
        if t == ty_promise : return "<promise>" // TODO
        if t == ty_func {
            let str = "fn("
            let info = this.func_info
            if isset(info) {
                each info.args as i, type {
                    if i > 0 : str += ", "
                    str += type
                }
            }
            str += ")("
            if isset(info) {
                each info.rett_types as i, type {
                    if i > 0 : str += ", "
                    str += type
                }
            }
            str += ")"
            return str
        }
        if t == ty_multi {
            return "<multi-type>" // TODO
        }
        //
        let result = ""
        if t == ty_array {
            let of = this.array_of;
            let size = this.array_size;
            if !isset(of) : return "[???]"
            result = "[" + size + " x " + of + "]"
        } else {
            let class = this.class
            if isset(class) {
                result = class.display_name
            }
        }
        if !this.is_pointer && (t == ty_struct || t == ty_class || t == ty_array) {
            result = "<" + result + ">"
        }
        if result.bytes == 0 : return "<cannot-convert-type-to-string>"
        if this.nullable : result = "?" + result
        return result
    }

    fn compat_check(type: Type, p: Parser) {
        if !this.compat(type) : p.error("Incompatible types. Passing a '" + type + "' value to a '" + this + "' type")
    }
    fn compat(type: Type) bool {
        if !this.nullable && type.nullable : return false
        if this.type == ty_ptr && type.is_pointer : return true
        if this.type != type.type : return false
        if this.type == ty_int && this.size() != type.size() : return false
        return true
    }

    fn get_non_nullable() Type {
        if !this.nullable : return this
        if !this.is_pointer : return this
        let type = this.clone()
        type.nullable = false
        return type
    }

    fn get_nullable() Type {
        if this.nullable : return this
        if !this.is_pointer : return this
        let type = this.clone()
        type.nullable = true
        return type
    }
    fn get_notnullable() Type {
        if !this.nullable : return this
        if !this.is_pointer : return this
        let type = this.clone()
        type.nullable = false
        return type
    }
    fn get_pointer() Type {
        if this.is_pointer : return this
        let type = this.clone()
        type.is_pointer = true
        return type
    }
    fn get_inline_type() Type {
        if !this.is_pointer : return this
        let type = this.clone()
        type.is_pointer = false
        type.nullable = false
        return type
    }

    fn fits_intv(intv: int, signed: bool) bool {
        if this.type != ty_int : return false
        if signed && intv < 0 {
            if !this.is_signed : return false
            let min : int = 1 << (this.size() * 8 - 1) @as int
            return min >= intv
        }

        let max : uint = 0
        max--
        max = max >> (sizeof(uint) * 8 - this.size() * 8)
        if signed : max = max >> 1

        let uv = intv @as uint
        return uv == (uv & max)
    }
}


fn read_type(p: Parser, scope: Scope, allow_newline: bool (true)) Type {

    let t = p.tok(true, allow_newline)

    if t == tok_sign {
        if p.sign_is("?") {
            let type = read_type(p, scope, false)
            if !type.is_pointer {
                p.error("Cannot make type '" + type + "' nullable. This is only possible for pointer types.")
            }
            return type.get_nullable()
        } else if p.sign_is("<") {
            let type = read_type(p, scope, false)
            if type.nullable || type.is_pointer {
                type = type.clone()
                type.nullable = false
                type.is_pointer = false
            }
            p.expect(">", true, false)
            return type
        } else if p.sign_is("[") {
            t = p.tok(true, false)
            let size = p.integer_value() ! p.error("Invalid array size syntax")
            p.expect("x", true, false)
            let sub = read_type(p, scope, false)
            let type = Type.new(p.build, ty_array)
            type.array_of = sub
            type.array_size = size
            p.expect("]", true, false)
            return type
        }
    }

    if t == tok_word {
        if p.word_is("void") {
            return type_void(p.build)
        }
        if p.word_is("fn") {
            // Arg types
            p.expect("(", false, false)
            let types = p.read_types(scope, ")", false)
            // Return type
            p.expect("(", false, false)
            let rett_types = p.read_types(scope, ")", true)
            // Errors
            let errors = map[u32]{}
            p.tok(true, false, false)
            while p.sign_is("!") {
                p.tok(true, false)
                let t = p.tok(false, false)
                if t != tok_word : p.error("Invalid error name syntax: " + p.word())
                let name = p.word()
                let val = helper:ctxhash_u32(name)
                if errors.has(name) : p.error("Duplicate error name: " + name)
                if errors.has_value(val) : p.error("It seems that 2 different error names are resolving to the same hash, try picking a different error name: " + name)
                errors.set(name, val)
                // Next
                p.tok(true, false, false)
            }
            // Result
            let info = FuncInfo {
                args: types
                rett_types: rett_types
                errors: errors
                can_error: errors.length() > 0
            }
            let type = Type.new(p.build, ty_func)
            type.func_info = info
            type.is_pointer = true
            return type
        }
        if p.word_is("typeof") {
            p.expect("(", false, false)
            let v = read_value(p, scope)
            p.expect(")", true, true)
            return v.rett
        }
        if p.word_is("notnull") {
            p.expect("(", false, false)
            let t = read_type(p, scope, true)
            p.expect(")", true, true)
            return t.get_notnullable()
        }
        let id = Id.read_full(p, p.word())
        let idf = scope.find_or_err(p, id)
        return handle_type_idf(p, scope, idf)
    }

    p.error("Unknown type: " + p.word())
}

fn handle_type_idf(p: Parser, scope: Scope, idf: Idf) Type {

    let for = idf.for

    if for == idf_type {
        let type = idf.type
        if isset(type) : return type
    }
    if for == idf_class {
        let class = idf.class
        if isset(class) {
            if class.is_generic_base : class = read_class_generic(p, scope, class)
            return class.get_type()
        }
    }

    p.error("Not a type")
}

fn type_void(b: Build) Type {
    return Type.new(b, ty_void)
}
fn type_undefined(b: Build) Type {
    return Type.new(b, ty_undefined)
}
fn type_func(func: Func) Type {
    let t = Type.new(func.build, ty_func)
    t.func_info = func.info()
    t.is_pointer = true
    return t
}
fn type_promise(b: Build, fi: FuncInfo) Type {
    let t = Type.new(b, ty_promise)
    t.func_info = fi
    t.is_pointer = true
    return t
}
fn type_multi(b: Build, types: Array[Type]) Type {
    if types.length <= 1 {
        return types.get(0) ? type_void(b)
    }
    let t = Type.new(b, ty_multi)
    t.sub_types = types
    return t
}
fn type_valk(b: Build, name: String) Type {
    return b.valk_class("type", name).get_type()
}
fn type_string(b: Build) Type {
    return b.valk_class("type", "String").get_type()
}
fn type_int(b: Build) Type {
    return b.valk_class("type", "int").get_type()
}
fn type_uint(b: Build) Type {
    return b.valk_class("type", "uint").get_type()
}
fn type_ptr(b: Build) Type {
    return b.valk_class("type", "ptr").get_type()
}
fn type_array(b: Build, array_of: Type, size: uint) Type {
    let type = Type.new(b, ty_array)
    type.array_of = array_of
    type.array_size = size
    type.is_pointer = true
    return type
}
fn type_number(b: Build, size: uint, is_float: bool, is_signed: bool) Type {
    let name : ?String = null
    if(is_float) {
        if size == 4 : name = "f32"
        else if size == 8 : name = "f64"
    } else {
        if size == 1 : name = is_signed ? "i8" : "u8"
        else if size == 2 : name = is_signed ? "i16" : "u16"
        else if size == 4 : name = is_signed ? "i32" : "u32"
        else if size == 8 : name = is_signed ? "i64" : "u64"
    }
    if isset(name) {
        return b.valk_class("type", name).get_type()
    }
    b.error("Cannot generate numeric type for size: " + size)
}

