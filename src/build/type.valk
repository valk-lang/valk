
struct Type {
    type: int
    build: Build
    array_of: ?Type (null)
    array_size: uint (0)
    func_info: ?FuncInfo (null)
    class: ?Class (null)
    is_pointer: bool (false)
    nullable: bool (false)
    is_signed: bool (false)

    static fn new(b: Build, type: int) Type {
        return Type {
            type: type
            build: b
        }
    }

    fn size() uint {
        if this.is_pointer {
            return this.build.ptr_size
        }
        let class = this.class
        if isset(class) {
            return class.size
        }
        return 0
    }

    fn clone() Type {
        let type = Type.new(this.build, this.type)
        type.array_of = this.array_of
        type.array_size = this.array_size
        type.func_info = this.func_info
        type.class = this.class
        type.is_pointer = this.is_pointer
        type.nullable = this.nullable
        type.is_signed = this.is_signed
        return type
    }

    fn _string() String {
        return this.str()
    }
    fn str() String {
        return "-cannot-conver-type-string-"
    }

    fn compat_check(type: Type, p: Parser) {
        if !this.compat(type) : p.error("Type '" + type + "' is not compatible with '" + this + "'")
    }
    fn compat(type: Type) bool {
        return true
    }
}

struct FuncInfo {
}


fn read_type(p: Parser, allow_newline: bool (true)) Type {

    let t = p.tok(true, allow_newline)

    if t == tok_sign {
        if p.sign_is("?") {
            let type = read_type(p)
            if !type.is_pointer {
                p.error("Cannot make type '" + type + "' nullable. This is only allowed for pointer types such as classes & structs.")
            }
            if !type.nullable {
                type = type.clone()
                type.nullable = true
            }
            return type
        }
    }

    if t == tok_word {
        if p.word_is("void") {
            return type_void(p.build)
        }
    }

    p.error("Invalid type")
}

fn type_void(b: Build) Type {
    return Type.new(b, ty_void)
}
fn type_undefined(b: Build) Type {
    return Type.new(b, ty_undefined)
}
