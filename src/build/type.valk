
use helper

class Type {
    type: int
    build: Build
    sub_type: ?Type (null)
    array_size: uint (0)
    func_info: ?FuncInfo (null)
    errors: ?Map[ERR_TYPE] (null)
    class: ?Class (null)
    group: ?Group (null)
    enum: ?Enum (null)
    sub_types: ?Array[Type] (null)
    custom_name: String ("")
    nullable: bool (false)
    is_signed: bool (false)
    is_imut: bool (false)
    null_overwrite: bool (false)
    can_error: bool (false)
    unsafe: bool (false)

    static fn new(b: Build, type: int) Type {
        return Type {
            type: type
            build: b
        }
    }

    fn size() uint {
        if this.type == TYPE.any : return this.build.ptr_size
        if this.is_pointer() {
            return this.build.ptr_size
        }
        if this.type == TYPE.array {
            let array_of = this.sub_type
            if isset(array_of) {
                return array_of.size() * this.array_size
            }
        }
        let class = this.class
        if isset(class) {
            return class.size
        }
        return 0
    }
    fn bit_size() uint {
        if this.type == TYPE.bool {
            return 1
        }
        return this.size() * 8
    }
    fn align_size(is_atomic: bool) uint {
        let s = this.size()
        if s >= this.build.ptr_size : return this.build.ptr_size
        return 4
    }

    fn largest_property_offset() uint {
        let ptr_size = this.build.ptr_size
        let offset = this.size()
        if !this.is_pointer() {
            if this.is_structural_type() {
                let class = this.class
                if isset(class) {
                    offset = 0
                    each class.props as prop {
                        let size = prop.type.size()
                        if size > offset : offset = size
                    }
                }
            }
            if this.is_array_type() {
                let sub_type = this.sub_type
                if isset(sub_type) {
                    offset = sub_type.size()
                }
            }
        }
        if offset > ptr_size : offset = ptr_size
        return offset
    }

    fn clone() Type {
        let type = Type.new(this.build, this.type)
        type.sub_type = this.sub_type
        type.array_size = this.array_size
        type.func_info = this.func_info
        type.class = this.class
        type.group = this.group
        type.nullable = this.nullable
        type.is_signed = this.is_signed
        type.is_imut = this.is_imut
        return type
    }

    fn is_void() bool {
        return this.type == TYPE.void
    }
    fn is_undefined() bool {
        return this.type == TYPE.undefined
    }
    fn is_none() bool {
        return this.type == TYPE.none
    }
    fn is_multi() bool {
        return this.type == TYPE.multi
    }
    fn is_gc() bool {
        if this.type == TYPE.closure {
            return true
        }
        if this.type == TYPE.ptr {
            let sub = this.sub_type
            if isset(sub) && sub.type == TYPE.class {
                let class = sub.class
                if !isset(class) : panic("Type has no class: " + this + " (bug)")
                return true
                // return class.size > 0
            }
        }
        return false
    }
    fn is_ptr() bool {
        return this.type == TYPE.ptr
    }
    fn is_voidptr() bool {
        return this.type == TYPE.voidptr
    }
    fn is_ref() bool {
        return this.type == TYPE.ref
    }
    fn is_int() bool {
        return this.type == TYPE.int
    }
    fn is_float() bool {
        return this.type == TYPE.float
    }
    fn is_number() bool {
        return (this.type == TYPE.int || this.type == TYPE.float)
    }
    fn is_bool() bool {
        return this.type == TYPE.bool
    }
    fn is_struct_type() bool {
        return this.type == TYPE.struct
    }
    fn is_class_type() bool {
        return this.type == TYPE.class
    }
    fn is_structural_type() bool {
        return this.type == TYPE.struct || this.type == TYPE.class
    }
    fn is_array_type() bool {
        return this.type == TYPE.array
    }
    fn is_inline_type() bool {
        return this.type == TYPE.array || this.type == TYPE.struct || this.type == TYPE.class
    }
    fn is_pointer_for(type: Type) bool {
        return this.compat(type.get_pointer())
    }
    fn is_ref_for(type: Type) bool {
        return this.compat(type.get_ref())
    }
    fn allow_math() bool {
        return this.type == TYPE.voidptr || this.is_number()
    }
    fn fits_eax() bool {
        if this.is_inline_type() : return false
        return true
    }
    fn load_by_ref() bool {
        return this.type == TYPE.array || this.type == TYPE.struct
    }
    fn is_func_ref() bool {
        return this.type == TYPE.func
    }
    fn is_closure() bool {
        return this.type == TYPE.closure
    }

    fn str() String $to {
        return this.to_str(false)
    }
    fn to_str(full: bool) String {
        let t = this.type
        let e = this.enum
        if isset(e) {
            this.enum = null
            let result = e.display_name + "(" + this.to_str(full) + ")"
            this.enum = e
            return result
        }
        if t == TYPE.any : return this.custom_name
        if t == TYPE.none : return "none"
        if t == TYPE.void : return "void"
        if t == TYPE.undefined : return "@undefined"
        if t == TYPE.error : return "<error>"
        if t == TYPE.error_item : return "<error-value>"

        if t == TYPE.promise  {
            let result = "co"
            let types = this.sub_types
            if isset(types) && types.length > 0 {
                result += "("
                each types as type, i {
                    if i > 0 : result += ", "
                    result += type
                }
                result += ")"
            }
            let errors = this.errors
            if isset(errors) {
                each errors as name, err {
                    result += " !" + name
                }
            }
            return result
        }

        let result = ""
        //
        if this.is_imut {
            result += "imut "
        }
        if this.nullable {
            result += "?"
        }

        if t == TYPE.func || t == TYPE.closure {
            let is_closure = t == TYPE.closure
            let str = is_closure ? "fn(" : "fnptr("
            let info = this.func_info
            if isset(info) {
                each info.args as type, i {
                    if i > 0 : str += ", "
                    str += type.to_str(full)
                }
            }
            str += ")("
            if isset(info) {
                each info.rett_types as type, i {
                    if i > 0 : str += ", "
                    str += type.to_str(full)
                }
            }
            str += ")"
            return result + str
        }
        if t == TYPE.multi {
            let sub_types = this.sub_types
            if !isset(sub_types) : return "<multi-type> (missing type information)"
            let str = "("
            each sub_types as type, i {
                if i > 0 : str += ", "
                str += type.to_str(full)
            }
            str += ")"
            return str
        }

        if t == TYPE.ptr {
            let sub = this.sub_type
            if !isset(sub) : return "<missing-pointer-sub-type>"
            if sub.is_structural_type() {
                let class = sub.get_class() ! return "<missing-class-name>"
                return result + class.get_name(full)
            }
        }

        if t == TYPE.ref {
            result += "&"
        } else if t == TYPE.ptr {
            result += "*"
        } else if t == TYPE.array {
            let of = this.sub_type;
            let size = this.array_size;
            result += "[" + (isset(of) ? of.to_str(full) : "?") + " x " + size + "]"
        } else {
            // Class based type
            let class = this.get_class() !? null
            if isset(class) {
                result += class.get_name(full)
                if this.is_structural_type() {
                    result = "<" + result + ">"
                }
            } else {
                result += "<missing-class-name>"
            }
        }

        if t == TYPE.ptr || t == TYPE.ref || t == TYPE.voidptr {
            let sub = this.sub_type
            let size = this.array_size
            if isset(sub) {
                if size == 1 {
                    result += sub
                } else {
                    result += "["
                    result += sub
                    if size > 1 {
                        result += " x " + size
                    }
                    result += "]"
                }
            }
        }

        if result.bytes == 0 : return "<cannot-convert-type-to-string> (compiler-type: " + t + ")"

        return result
    }

    fn compat_check(type: Type, p: ?Parser, err_chunk: ?Chunk (null)) {
        let ignore_imut = false
        if isset(p) : ignore_imut = p.ignore_imut()

        if !this.compat(type, ignore_imut) {
            if isset(p) {
                if isset(err_chunk) : p.set_chunk(err_chunk)
                p.error("Incompatible types. Passing a '" + type + "' value to a '" + this + "' type")
            }
            this.build.error("Incompatible types. Passing a '" + type + "' value to a '" + this + "' type")
        }
    }
    fn compat(type: Type, ignore_imut: bool (false)) bool {
        let base = this
        let base_class = base.get_class() !? null
        let type_class = type.get_class() !? null
        if isset(base_class) && base_class.mode_for_class != null : base_class = base_class.mode_for_class
        if isset(type_class) && type_class.mode_for_class != null : type_class = type_class.mode_for_class

        if base.type == TYPE.any || type.type == TYPE.any : return true // For docs
        if !base.nullable && type.nullable : return false

        // [...] == ptr[...]
        if base.is_inline_type() && type.is_pointer() {
            base = base.get_ref()
            base_class = base.get_class() !? null
        }
        // ptr[...] == [...]
        else if type.is_inline_type() && base.is_pointer() {
            type = type.get_ref()
            type_class = type.get_class() !? null
        }

        if base.type == TYPE.voidptr && type.is_pointer() : return true
        if base.type != type.type {
            if base.type == TYPE.ref && type.type == TYPE.ptr {
                // allow: &X <-> *X
            } else if base.type == TYPE.error && type.type == TYPE.error_item {
                // allow: error <-> error-item
            } else {
                return false
            }
        }

        // Enums
        let enu = base.enum
        if isset(enu) {
            if base.enum != type.enum {
                return false
            }
        }

        // */&X == */&X
        if base.type == TYPE.ptr || base.type == TYPE.ref {
            let sub = base.sub_type
            let sub2 = type.sub_type
            if !isset(sub) || !isset(sub2) : return false
            return sub.compat(sub2, ignore_imut)
        }
        // Error types
        if base.type == TYPE.error || base.type == TYPE.error_item {
            if type.type != TYPE.error && type.type != TYPE.error_item : return false
            let base_errors = base.errors
            let type_errors = type.errors
            if !isset(base_errors) || !isset(type_errors) : return false
            each type_errors as code, name {
                if !base_errors.has(name) : return false
            }
            return true
        }
        // co[u32]!err
        if base.type == TYPE.promise {
            // Rett types
            let base_retts = base.sub_types
            let type_retts = type.sub_types
            if isset(type_retts) && type_retts.length > 0 {
                if !isset(base_retts) : return false
                if base_retts.length != type_retts.length : return false
                each base_retts as base_rett, i {
                    let type_rett = type_retts.get(i) ! return false
                    if !base_rett.compat(type_rett) : return false
                }
            }
            // Errors
            let base_errors = base.errors
            let type_errors = type.errors
            if isset(type_errors) {
                if !isset(base_errors) : return false
                each type_errors as code, name {
                    if !base_errors.has(name) : return false
                }
            }
            return true
        }
        if base.type == TYPE.func || base.type == TYPE.closure {
            let fi_base = this.func_info
            let fi_type = type.func_info
            if !isset(fi_base) || !isset(fi_type) : return false
            let args_base = fi_base.args
            let args_type = fi_type.args
            let retts_base = fi_base.rett_types
            let retts_type = fi_type.rett_types
            if args_base.length != args_type.length : return false
            if retts_base.length != retts_type.length : return false
            each args_base as rb, i {
                let rt = args_type.get(i) ! return false
                if !rt.compat(rb) : return false
            }
            each retts_base as rb, i {
                let rt = retts_type.get(i) ! return false
                if !rb.compat(rt) : return false
            }
            if fi_type.can_error && !fi_base.can_error : return false
        }
        //
        if base.type == TYPE.int || base.type == TYPE.float {
            // Numbers
            if base.size() != type.size() : return false
            if base.is_signed != type.is_signed : return false
        } else {
            // Not a number
            if base_class != type_class : return false
            if base.is_imut != type.is_imut && !ignore_imut : return false
        }
        // Arrays
        if base.type == TYPE.array {
            let sub1 = base.sub_type
            let sub2 = type.sub_type
            if !isset(sub1) || !isset(sub2) : return false
            if base.array_size > 0 && type.array_size > 0 && base.array_size > type.array_size : return false
            return sub1.compat(sub2, ignore_imut)
        }
        // Multi types
        if base.is_multi() {
            let sub1 = base.sub_types
            let sub2 = type.sub_types
            if !isset(sub1) || !isset(sub2) : return false
            each sub1 as subt1, i {
                let subt2 = sub2.get(i) ! return false
                if !subt1.compat(subt2, ignore_imut) : return false
            }
        }
        return true
    }

    fn get_non_nullable() Type {
        if !this.nullable : return this
        if !this.is_pointer() : return this
        let type = this.clone()
        type.nullable = false
        return type
    }

    fn get_nullable() Type {
        if this.nullable : return this
        if !this.is_pointer() : return this
        let type = this.clone()
        type.nullable = true
        return type
    }
    fn get_class() Class !none {
        let class = this.class
        if isset(class) : return class
        if this.type == TYPE.ptr {
            let sub = this.sub_type
            if isset(sub) {
                let class = sub.class
                if isset(class) : return class
            }
        }
        throw none
    }
    fn is_pointer() bool {
        let t = this.type
        return t == TYPE.ptr || t == TYPE.ref || t == TYPE.voidptr || t == TYPE.func || t == TYPE.closure || t == TYPE.promise
    }
    fn get_pointer() Type {
        if this.type == TYPE.struct || this.type == TYPE.class {
            let class = this.class
            if isset(class) : return class.get_type()
        }
        if this.type == TYPE.array {
            let sub = this.sub_type
            if isset(sub) {
                let type = Type.new(this.build, TYPE.ptr)
                type.sub_type = sub
                type.array_size = this.array_size
                return type
            }
        }
        let type = Type.new(this.build, TYPE.ptr)
        type.sub_type = this
        return type
    }
    fn get_ref() Type {
        let type = this.get_pointer().clone()
        type.type = TYPE.ref
        return type
    }
    fn get_inline() Type {
        let t = this.type
        if t == TYPE.ptr || t == TYPE.ref || t == TYPE.voidptr {
            let sub = this.sub_type
            if isset(sub) {
                let size = this.array_size
                if size > 1 {
                    let type = Type.new(this.build, TYPE.array)
                    type.sub_type = sub
                    type.array_size = size
                    return type
                }
                return sub
            }
        }
        return this
    }
    fn get_imut(is_imut: bool) Type {
        if is_imut {
            return get_imut_type(this)
        }
        return get_mut_type(this)
    }
    fn get_imut_or_async() Type {
        let class = this.class
        if isset(class) {
            if class.is_async {
                return this
            }
        }
        return get_imut_type(this)
    }
    fn is_imut_or_async() bool {
        if !this.is_structural_type() : return true
        let class = this.class
        if isset(class) {
            if class.is_async {
                return true
            }
        }
        return this.is_imut
    }

    fn is_imut_compatible() bool {
        if !this.is_structural_type() : return true
        let class = this.class
        if !isset(class) : return true
        return class.is_imut
    }
    fn get_func_info() FuncInfo {
        let info = this.func_info
        if isset(info) : return info
        this.build.error("Missing function information (compiler bug)")
    }
    fn match_nullable(with: Type) Type {
        if this.is_pointer() && with.nullable {
            return this.get_nullable()
        } else if (this.is_multi() && with.is_multi()) {
            let sub1 = this.sub_types
            let sub2 = with.sub_types
            let list = Array[Type].new()
            if isset(sub1) && isset(sub2) {
                each sub1 as subt1, i {
                    let subt2 = sub2.get(i) ! {
                        list.append(subt1)
                        continue;
                    }
                    list.append(subt1.match_nullable(subt2))
                }
                return type_multi(this.build, list)
            }
        }
        return this
    }

    fn unroll() Array[Type] {
        if this.is_multi() {
            let types = this.sub_types
            if isset(types) : return types
        }
        let res = Array[Type].new()
        if !this.is_void() && !this.is_none() && !this.is_undefined() {
            res.append(this)
        }
        return res
    }

    fn fits_intv(intv: int, signed: bool) bool {
        if this.type != TYPE.int : return false
        if signed && intv < 0 {
            if !this.is_signed : return false
            let min : int = 1 << (this.size() * 8 - 1).@cast(int)
            return min >= intv
        }

        let max : uint = 0
        max--
        max = max >> (size_of(uint) * 8 - this.size() * 8)
        if signed : max = max >> 1

        let uv = intv.@cast(uint)
        return uv == (uv & max)
    }
}


fn read_type(p: Parser, scope: Scope, allow_newline: bool (true), allow_multi: bool (false)) Type {

    let t = p.tok(true, allow_newline)

    // if t == TOK.word {
    //     if p.word_is("imut") {
    //         let type = read_type(p, scope, false)
    //         return type.get_imut(true)
    //     }
    // }

    if t == TOK.sign {
        if p.sign_is("?") {
            let type = read_type(p, scope, false)
            // if !type.is_pointer : p.error("Cannot make type '" + type + "' nullable. This is only possible for pointer types.")
            return type.get_nullable()
        } else if p.sign_is("*") {
            if p.next_word_is("[", false, false, true) {
                let type = Type.new(p.build, TYPE.ptr)
                read_pointer_info(p, scope, type)
                return type
            }
            let type = read_type(p, scope, false)
            return type.get_pointer()
        } else if p.sign_is("&") {
            if p.next_word_is("[", false, false, true) {
                let type = Type.new(p.build, TYPE.ref)
                read_pointer_info(p, scope, type)
                return type
            }
            let type = read_type(p, scope, false)
            return type.get_ref()
        } else if p.sign_is(".") {
            let s = p.suggest_type
            if !isset(s) : p.error("Using '.' but the compiler could not find a typehint for it")
            return s
        } else if p.sign_is("<") {
            let type = read_type(p, scope, false)
            type = type.get_inline()
            p.expect(">", true, false)
            return type
        } else if p.sign_is("[") {
            return read_fixed_array_type(p, scope)
        } else if allow_multi && p.sign_is("(") {
            // Multi type
            let types = Array[Type].new()
            while true {
                let t = p.tok(true, false, false)
                if p.word_is(")") || t == TOK.none : break
                if types.length > 0 : p.expect2(",", ")", true, false)
                let type = read_type(p, scope, true)
                if type.is_void() : p.error("You cannot use 'void' in a multi-type")
                types.append(type)
            }
            p.expect(")", true, false)

            if types.length == 1 {
                let first = types.get(0) !? null
                if isset(first) : return first
            }

            return type_multi(p.build, types)
        }
    }

    if t == TOK.word {
        if p.word_is("void") {
            return type_void(p.build)
        }
        if p.word_is("fn") || p.word_is("fnptr") {
            let is_closure = p.word_is("fn")
            // Arg types
            p.expect("(", false, false)
            let types = p.read_types(scope, ")", false)
            // Return type
            p.expect("(", false, false)
            let rett_types = p.read_types(scope, ")", true)
            // Errors
            let errors = Map[u32]{}
            read_errors(p, errors)

            // Result
            let info = FuncInfo {
                args: types
                rett_types: rett_types
                errors: errors
                can_error: errors.length > 0
            }
            let type = Type.new(p.build, is_closure ? TYPE.closure : TYPE.func)
            type.func_info = info
            return type
        }
        if p.word_is("co") {
            // co[u32, u16] !hello !*
            let rett_types : ?Array[Type] = null
            if p.next_word_is("(", false, false, true) {
                rett_types = p.read_types(scope, ")", true)
            }
            let errors = Map[u32]{}
            read_errors(p, errors)
            return type_promise(p.build, rett_types, errors)
        }
        if p.word_is("typeof") {
            p.expect("(", false, false)
            let v = read_value(p, scope)
            p.expect(")", true, true)
            return v.rett
        }
        p.col -= p.word_len
        p.i -= p.word_len
        let idf = p.read_idf(scope, true, false)
        return handle_type_idf(p, scope, idf)
    }

    p.error("Unknown type: " + p.word())
}

fn read_fixed_array_type(p: Parser, scope: Scope) Type {
    // Type
    let sub = read_type(p, scope, false)
    if sub.is_gc() : p.error("You cannot use class types in fixed arrays")
    p.expect("x", true, false)
    // Size
    let sug = p.suggest_type
    p.suggest_type = p.build.valk_type("type", "uint")
    let vsize = read_value(p, scope)
    if vsize.type != VAL.int || vsize.rett.is_signed : p.error("Invalid integer size")
    p.suggest_type = sug
    let size = vsize.int.to(uint)
    if size == 0 : p.error("Array size must be larger than 0")
    //
    let type = Type.new(p.build, TYPE.array)
    type.sub_type = sub
    type.array_size = size
    p.expect("]", true, false)
    return type
}

fn read_errors(p: Parser, errors: Map[ERR_TYPE]) {
    p.tok(true, false, false)
    while p.sign_is("!") {
        p.tok(true, false)
        let t = p.tok(false, false)
        if t != TOK.word : p.error("Invalid error name syntax: " + p.word())
        let name = p.word()
        let val = helper:ctxhash_u32(name)
        if errors.has(name) : p.error("Duplicate error name: " + name)
        if errors.has_value(val) : p.error("It seems that 2 different error names are resolving to the same hash, try picking a different error name: " + name)
        errors.set(name, val)
        // Next
        p.tok(true, false, false)
    }
}

fn handle_type_idf(p: Parser, scope: Scope, idf: Idf) Type {

    let for = idf.for

    if for == IDF.type {
        let type = idf.type
        if isset(type) : return type
    }
    if for == IDF.class {
        let class = idf.class
        if isset(class) {
            if class.is_generic_base : class = read_class_generic(p, scope, class)
            let type = class.get_type()

            if p.next_word_is("[", false, false, true) {
                type = type.clone()
                read_pointer_info(p, scope, type)
            }

            return type
        }
    }
    if for == IDF.alias {
        let alias = idf.alias
        if isset(alias) {
            let for_idf = alias.for_idf
            if isset(for_idf) {
                return handle_type_idf(p, scope, for_idf)
            }
            let for_type = alias.for_type
            if isset(for_type) {
                return for_type
            }
        }
    }
    if for == IDF.class_prop {
        let prop = idf.prop
        if !isset(prop) : p.bug("Missing property info for identifier")
        return prop.type
    }
    if for == IDF.prop {
        let prop = idf.prop
        if !isset(prop) : p.bug("Missing property info for identifier")
        return prop.type
    }

    if for == IDF.enum {
        let enu = idf.enum
        if !isset(enu) : p.bug("Missing enum info for identifier")
        return enu.get_type()
    }

    p.error("Not a type")
}

fn read_pointer_info(p: Parser, scope: Scope, type: Type) {
    let sub = read_type(p, scope)
    let size : uint = 0
    // Size
    if p.next_word_is("x", true, false, true) {
        let sug = p.suggest_type
        p.suggest_type = p.build.valk_type("type", "uint")
        let vsize = read_value(p, scope)
        if vsize.type != VAL.int || vsize.rett.is_signed : p.error("Invalid integer size")
        p.suggest_type = sug
        size = vsize.int.to(uint)
        if size == 0 : p.error("Array size must be larger than 0")
    }
    //
    p.expect("]", true, false)
    type.sub_type = sub
    type.array_size = size
}

fn type_void(b: Build) Type {
    return Type.new(b, TYPE.void)
}
fn type_undefined(b: Build) Type {
    return Type.new(b, TYPE.undefined)
}
fn type_any(b: Build) Type {
    return Type.new(b, TYPE.any)
}
fn type_none(b: Build) Type {
    return Type.new(b, TYPE.none)
}
fn type_func(func: Func) Type {
    let t = Type.new(func.build, TYPE.func)
    t.func_info = func.info()
    return t
}
fn type_func_info(b: Build, info: FuncInfo) Type {
    let t = Type.new(b, TYPE.func)
    t.func_info = info
    return t
}
fn type_promise(b: Build, return_types: ?Array[Type], errors: ?Map[ERR_TYPE]) Type {
    let t = Type.new(b, TYPE.promise)
    t.sub_types = return_types
    t.errors = errors
    t.can_error = isset(errors) && errors.length > 0
    return t
}
fn type_closure(b: Build, fi: FuncInfo) Type {
    let t = Type.new(b, TYPE.closure)
    t.func_info = fi
    return t
}
fn type_multi(b: Build, types: Array[Type]) Type {
    if types.length <= 1 {
        return types.get(0) !? type_void(b)
    }
    let t = Type.new(b, TYPE.multi)
    t.sub_types = types
    return t
}
fn type_valk(b: Build, name: String) Type {
    return b.valk_class("type", name).get_type()
}
fn type_string(b: Build) Type {
    return b.valk_class("type", "String").get_type()
}
fn type_int(b: Build) Type {
    return b.valk_class("type", "int").get_type()
}
fn type_uint(b: Build) Type {
    return b.valk_class("type", "uint").get_type()
}
fn type_float(b: Build) Type {
    return b.valk_class("type", "f64").get_type()
}
fn type_ptr(b: Build) Type {
    return b.valk_class("type", "ptr").get_type()
}
fn type_array(b: Build, array_of: Type, size: uint) Type {
    let type = Type.new(b, TYPE.array)
    type.sub_type = array_of
    type.array_size = size
    return type
}
fn type_number(b: Build, size: uint, is_float: bool, is_signed: bool) Type {
    let name : ?String = null
    if(is_float) {
        if size == 4 : name = "f32"
        else if size == 8 : name = "f64"
    } else {
        if size == 1 : name = is_signed ? "i8" : "u8"
        else if size == 2 : name = is_signed ? "i16" : "u16"
        else if size == 4 : name = is_signed ? "i32" : "u32"
        else if size == 8 : name = is_signed ? "i64" : "u64"
    }
    if isset(name) {
        return b.valk_class("type", name).get_type()
    }
    b.error("Cannot generate numeric type for size: " + size)
}

fn type_error(b: Build, errors: Map[ERR_TYPE]) Type {
    let type = Type.new(b, TYPE.error)
    type.errors = errors
    type.class = b.valk_class("type", "u32")
    return type
}
fn type_error_item(b: Build, name: String, val: ERR_TYPE) Type {
    let type = Type.new(b, TYPE.error_item)
    let errors = Map[ERR_TYPE].new()
    errors.set(name, val)
    type.errors = errors
    type.class = b.valk_class("type", "u32")
    return type
}

fn match_alt_value_types(t1: Type, t2: Type, return_void_if_not_compat: bool) Type !compat {
    if t2.nullable : t1 = t1.get_nullable()
    if t1.compat(t2) : return t1
    if return_void_if_not_compat : return type_void(t1.build)
    throw compat
}