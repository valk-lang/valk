
fn layout(class: Class) ?Func {
    let f = class._props_func
    if isset(f) : return f
    let _props = class.funcs.get("_props") !? null
    let props  = class.props
    let has_gc_props = false
    each props as prop, name {
        if prop.type.is_gc() {
            has_gc_props = true
            break
        }
    }
    if !has_gc_props {
        if isset(_props) : return _props
        return null
    }

    // Generate function
    let b = class.build
    let scope = Scope.new(SCOPE.default, b, null)

    // Code
    let code = StringComposer.new(4096)
    code.append_str("item: ptr, list: LIFO_TYPE) {\n")
        // code.append_str("print(\"%{ this.display_name }\n\")\n")

    // Loop props
    each props as prop, name, i {
        if !prop.type.is_gc() : continue
        code.append_str("ir_comment(\"ADD PROP: ")
        code.append_str(name)
        code.append_str("\")\n")
        code.append_str("list.add(item.@offset(")
        code.append_uint(prop.offset)
        code.append_str("))\n")
    }

    if isset(_props) {
        code.append_str("_PROPS(item.@cast(CLASS_TYPE), list)\n")
    }

    // Func end
    code.append_str("}\n")

    // Parse
    let content = code.to_string()
    let chunk = Chunk.new(b, content, class.fc)
    let sp = Parser.new(chunk, null)

    // let fc = b.generated_fc()
    f = class.unit.new_func(class.fc, class.fc, act_default, class.name + ".LIST_PROPS", null, chunk, false)
    f.arg_scope.parent = scope
    f.disable_gc_stack = true
    scope.func = f

    let ctx = Context.forFunc(f)
    // Identifiers
    let lifo_type = b.valk_type("gc", "Lifo")
    let idf = Idf.for_type(lifo_type)
    scope.set_idf(ctx, "LIFO_TYPE", idf)
    idf = Idf.for_type(class.get_type())
    scope.set_idf(ctx, "CLASS_TYPE", idf)
    if isset(_props) {
        idf = Idf.for_func(_props)
        scope.set_idf(ctx, "_PROPS", idf)
    }

    //
    f.parse_args(sp)
    parse_func_args(f)
    code.clear()

    class._props_func = f
    return f
}

