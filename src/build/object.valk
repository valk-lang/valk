
use helper
use valk:utils

fn read_object(p: Parser, scope: Scope) Value {

    p.expect("{", true, true)
    let values = Map[Value]{}
    let types = Array[Type]{}

    while true {
        let t = p.tok(true, true)
        while p.word_is(",") : t = p.tok(true, true)
        if p.word_is("}") : break

        let name = p.word()
        if t != TOK.word : p.error("Invalid property name: " + name)
        if values.has(name) : p.error("Duplicate property name: " + name)

        p.expect(":", true, false)

        let v = read_value(p, scope)
        types.append(v.rett)
        values.set(name, v)
    }

    let b = p.build

    let buf = utils:ByteBuffer.new()
    let str = generic_types_to_str(types, buf, true)
    let hash = helper:ctxhash(str)

    let class = b.objects.get(hash) !? null
    if !isset(class) {
        // Create new class
        let func = p.func()
        class = func.unit.new_class(func.fc, act_public_all, "custom_object_" + b.objects.length, CT.class, null, null)
        b.objects.set(hash, class)

        each values as v, name {
            let p = Prop{
                name: name
                type: v.rett
                class: class
                act: act_public_all
            }
            class.props.set(name, p)
        }

        class.determine_size() ! p.error("Cannot determine class size of: " + class.display_name)
    }

    return vgen_class_init(p.ctx, class, scope, values, p)
}