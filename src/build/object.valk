
use helper

fn read_object(p: Parser, scope: Scope) Value {

    p.expect("{", true, true)
    let values = map[Value]{}
    let types = array[Type]{}

    while true {
        let t = p.tok(true, true)
        while p.word_is(",") : t = p.tok(true, true)
        if p.word_is("}") : break

        let name = p.word()
        if t != tok_word : p.error("Invalid property name: " + name)
        if values.has(name) : p.error("Duplicate property name: " + name)

        p.expect(":", true, false)

        let v = read_value(p, scope)
        types.push(v.rett)
        values.set(name, v)
    }

    let b = p.build

    let str = "["
    each types as type, i {
        if i > 0 : str += ", "
        str += type.to_str(true)
    }
    str += "]"
    let hash = helper:ctxhash(str)

    let class = b.objects.get(hash) !? null
    if !isset(class) {
        // Create new class
        let func = p.func()
        class = func.unit.new_class(func.fc, act_public_all, "custom_object_" + b.objects.length, ct_class, null, null)
        b.objects.set(hash, class)

        each values as v, name {
            let p = Prop{
                name: name
                type: v.rett
                class: class
                act: act_public_all
            }
            class.props.set(name, p)
        }

        class.determine_size() ! p.error("Cannot determine class size of: " + class.display_name)
    }

    return vgen_class_init(class, scope, values)
}