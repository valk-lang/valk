
use helper
use valk:os
use valk:fs

fn run(args: Array[String]) {

    let valid_flags = array[String]{
        "--help", "-h", "-o", "--target", "--def", "--test", "-t", "--run", "-r", "--clean", "-c", "-v", "-vv", "-vvv"
    }
    let has_value = array[String]{ "-o", "--target", "--def" }
    let cli = helper:parse_cli_args(args, valid_flags, has_value)

    if cli.invalid.length > 0 {
        build_error("Unknown build argument: " + cli.invalid.get(0) ? "?")
    }

    let dir: ?String = null
    let files = array[String]{}
    each cli.inputs as arg {
        if arg.ends_with(".valk") {
            files.push(arg)
            continue
        }
        if !fs:is_dir(arg) {
            build_error("Invalid config directory: " + arg)
        }
        if isset(dir) {
            build_error("You can only pass 1 config directory in your build arguments\nDir1: " + dir + "\nDir2: " + arg)
        }
        dir = arg
    }

    if files.length == 0 {
        build_error("You did not mention any *.valk files in your build command\nNothing to compile")
    }

    let first_file = files.get(0) ! return
    let conf_dir = isset(dir) ? dir : fs:dir_of(first_file)
    if conf_dir.bytes == 0 : conf_dir = "."

    let is_test = cli.flags.contains("--test") || cli.flags.contains("-t")
    let run = cli.flags.contains("--run") || cli.flags.contains("-r")
    let optimize = cli.flags.contains("--no-opt") ? false : true

    let target = get_target(cli)
    let verbose = 0
    if cli.flags.contains("-v") : verbose = 1
    if cli.flags.contains("-vv") : verbose = 2
    if cli.flags.contains("-vvv") : verbose = 3

    let hash = conf_dir
    hash += "||"
    hash += target.os
    hash += target.arch
    hash += optimize ? "1" : "0"
    hash += is_test ? "1" : "0"

    hash = helper:ctxhash(hash)

    let home = fs:home_dir() ! build_error("Cannot find user home directory, so we cannot create the cache directory")
    let cache_dir = home + "/.valk/"
    if !fs:is_dir(cache_dir) : fs:mkdir(cache_dir) ! build_error("Failed to create cache directory: " + cache_dir)
    cache_dir += hash
    if !fs:is_dir(cache_dir) : fs:mkdir(cache_dir) ! build_error("Failed to create cache directory: " + cache_dir)

    if verbose > 0 {
        println("ðŸ“¦ Cache directory: " + cache_dir);
    }

    let b = Build {
        target: target
        verbose: verbose
        cache_dir: cache_dir
    }

    // Setup main package & namespace
    let pkc_main = Pkc.new(b)
    pkc_main.set_dir(conf_dir)
    pkc_main.pkc_by_name.set("main", pkc_main)

    let nsc_main = Nsc.new(pkc_main, "main", conf_dir)
    pkc_main.namespaces.set("main", nsc_main)

    // Load valk package
    let vlk = pkc_main.load_sub_pkc("valk");
    b.pkc_valk_ = vlk

    // Load valk package core namespaces
    vlk.nsc("core")
    vlk.nsc("io")
    vlk.nsc("mem")
    vlk.nsc("type")

    // Load cli files
    each files as file {
        let fc = nsc_main.load_fc(file)
    }

    println("âœ… Compiled")
}

exit_fn help() {
    println("\n# valk build {.valk-file(s)} [{config-dir}] -o {outpath}");
    println("or");
    println("# valk build {.valk-file(s)} [{config-dir}] -r|--run\n");

    println(" -o                  set outpath");
    println(" --run -r            run program after compiling");
    println(" --watch -w          watch files & rebuild when code changes");
    println(" --test -t           build tests");
    println(" --clean -c          ignore cache");
    // println(" --debug -d          generate debug info");
    // println(" --no-opt            build without optimizations");
    print("\n");

    println(" --def               define compile condition variables");
    println("                     format: VAR1=VAL,VAR2=VAL");
    println(" --target            compile for a specific os/arch");
    println("                     linux-x64, macos-x64, win-x64");

    print("\n");
    println(" -v -vv -vvv         show compile info");
    println(" --help -h           build command usage info");
    print("\n");

    os:exit(1)
}
