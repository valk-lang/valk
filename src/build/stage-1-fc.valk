

fn stage_fc_pipeline(b: Build) {
    let i : uint = 0
    let list = b.fc_pipeline
    while i < list.length {
        let fc = list.get(i++) ! break
        stage_fc(fc)
    }

    stage_alias(b)
}

fn stage_fc(fc: Fc) {
    let b = fc.build
    if b.verbose > 2 : b.log("> Stage 1: " + fc.path)

    let p = Parser.new(fc.start, null)
    let nsc = fc.nsc

    while true {
        let t = p.tok(true, true)

        if t == tok_end {
            break
        }

        let act = act_public_nsc

        if t == tok_word {
            // With act
            if p.word_is("fn") {
                parse_func(p, fc, act)
                continue
            }
            if p.word_is("exit") {
                p.expect("fn", true, false)
                parse_func(p, fc, act)
                continue
            }
            if p.word_is("class") {
                parse_class(p, fc, act, ct_class)
                continue
            }
            if p.word_is("struct") {
                parse_class(p, fc, act, ct_struct)
                continue
            }
            if p.word_is("pointer") {
                parse_class(p, fc, act, ct_pointer)
                continue
            }
            if p.word_is("integer") {
                parse_class(p, fc, act, ct_int)
                continue
            }
            if p.word_is("float") {
                parse_class(p, fc, act, ct_float)
                continue
            }
            if p.word_is("global") {
                parse_global(p, fc, act, false)
                continue
            }
            if p.word_is("shared") {
                parse_global(p, fc, act, true)
                continue
            }
            if p.word_is("trait") {
                parse_trait(p, fc, act)
                continue
            }
            if p.word_is("value") {
                parse_alias(p, fc, act, alias_value)
                continue
            }
            if p.word_is("type") {
                parse_alias(p, fc, act, alias_type)
                continue
            }
            if p.word_is("macro") {
                parse_macro(p, fc, act)
                continue
            }

            // Without act
            if p.word_is("use") {
                parse_use(p, fc)
                continue
            }
            if p.word_is("header") {
                parse_header(p, fc)
                continue
            }
            if p.word_is("test") {
                parse_test(p, fc)
                continue
            }
            if p.word_is("link") {
                parse_link(p, fc)
                continue
            }
        }

        p.error("Unexpected token: '" + p.word() + "'")
    }
}

fn parse_func(p: Parser, fc: Fc, act: int) {
    let name = p.read_word(true, false) 
    p.expect("(", false, false)
    let chunk_args = p.clone_chunk()
    let f = fc.nsc.unit.new_func(fc, act, name, chunk_args) ! p.error("Name already used: " + name)
    f.parse_args(p)
}

fn parse_class(p: Parser, fc: Fc, act: int, type: int) {
}
fn parse_trait(p: Parser, fc: Fc, act: int) {
}
fn parse_global(p: Parser, fc: Fc, act: int, shared: bool) {
}
fn parse_alias(p: Parser, fc: Fc, act: int, type: int) {
}
fn parse_macro(p: Parser, fc: Fc, act: int) {
}

// 
fn parse_use(p: Parser, fc: Fc) {
    let id = Id.read(p, true, false)
    let pkc = fc.nsc.pkc
    let pkg = id.pkg
    if isset(pkg) {
        pkc = pkc.load_sub_pkc(pkg)
    }
    pkc.nsc(id.ns)
}
fn parse_header(p: Parser, fc: Fc) {
}
fn parse_link(p: Parser, fc: Fc) {
}
fn parse_test(p: Parser, fc: Fc) {
}
