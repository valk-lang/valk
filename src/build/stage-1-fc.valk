

fn stage_fc_pipeline(b: Build) {
    let i : uint = 0
    let list = b.fc_pipeline
    while i < list.length {
        let fc = list.get(i++) ! break
        stage_fc(fc)
    }
}

fn stage_fc(fc: Fc) {
    let b = fc.build
    if b.verbose > 2 : b.log("> Stage 1: " + fc.path)

    let p = Parser.new(fc.start, fc.nsc.unit, fc.nsc, null)

    while true {
        let t = p.tok(true, true)

        if t == tok_end {
            break
        }

        let act = act_public_nsc

        if t == tok_word {
            let word = p.word()

            if word == "fn" {
                parse_func(p)
                continue
            }
        }

        p.error("Unexpected token: " + p.tok_to_str(t))
    }
}

fn parse_func(p: Parser) {
    let name = p.read_id(true, false) 
    p.expect("(", false, false)
    let chunk_args = p.clone_chunk()
    p.skip_body(")")
    let chunk_rett: ?Chunk = null
    let chunk_body: ?Chunk = null

    let t = p.tok(true, true, false)
    if !p.sign_is("{") && !p.sign_is("!") {
        chunk_rett = p.clone_chunk()
        p.skip_type()
    }

    t = p.tok(true, true, false)
    while p.sign_is("!") {
        t = p.tok(true, true)
        t = p.tok(false, false)
        if t != tok_word : p.error("Invalid error name: " + p.word())
    }

    p.expect("{", true, true)
    chunk_body = p.clone_chunk()
    p.skip_body("}")

    let f = p.unit.new_func(p.nsc, name, chunk_args, chunk_rett)

}
