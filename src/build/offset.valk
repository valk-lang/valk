
fn parse_offset_value(p: Parser, scope: Scope, on: Value) Value {
    // 
    let func = offset_get_func(p, on) ! {
        // No offset function
        if on.rett.type == TYPE.array {
            on = vgen_ref(on, scope)
        }
        // Try native
        if on.rett.type == TYPE.ptr || on.rett.type == TYPE.ref || on.rett.type == TYPE.voidptr {
            let sub = on.rett.sub_type
            if isset(sub) {
                let max_offset : uint = 0
                let array_type = sub
                let index = read_value(p, scope)
                if index.rett.type != TYPE.int : p.error("Invalid offset, expected an integer value instead of: " + index.rett)

                // Offset check if possible
                if max_offset > 0 && index.type == VAL.int && index.int >= max_offset.@cast(int) {
                    p.error("Out of bounds. You are asking for index '" + index.int + "' on type: " + array_type + ". The last index is: " + (max_offset - 1))
                }

                // Result
                let result = vgen_ptrv(on, sub, index)
                p.expect("]", true, true)
                return result
            }
        }
        p.error("Type: '" + on.rett + "' has no '[]' get offset function")
    }

    let fptr = vgen_func_ptr(func)
    let argvs = Array[Value].new()
    argvs.append(on)
    read_func_call_arg_values(p, scope, fptr, "]", argvs)

    let t = p.tok(true, true, false)
    let is_assign = p.word_is("=")
    
    if !is_assign {
        let get_call = vgen_func_call(p.build, scope, fptr, argvs)
        // Error handling
        let info = fptr.rett.get_func_info()
        if info.can_error {
            if p.has_error_handler_ahead() {
                get_call = value_error_handling(p, scope, get_call, info.errors)
            } else {
                let altv = vgen_empty_value(get_call.rett)
                altv.rett = altv.rett.get_nullable()
                get_call = vgen_error_handler(scope, get_call, altv, true)
            }
        }
        //
        return get_call
    }

    let setfunc = offset_assign_func(p, on) ! p.error("Type: " + on.rett + " has no '[]' offset assign function")
    let last_arg = setfunc.args.get(setfunc.args.length - 1) ! p.error("Missing $offset_assign value argument")

    t = p.tok(true, true)

    p.set_suggest(last_arg.type)
    let right = read_value(p, scope)
    p.pop_suggest()

    right = right.try_convert(p.ctx, scope, last_arg.type)
    last_arg.type.compat_check(right.rett, p)

    let set_values = argvs.copy()
    set_values.append(right)

    let set_fptr = vgen_func_ptr(setfunc)
    let set_call = vgen_func_call(p.build, scope, set_fptr, set_values)

    // let info = set_fptr.rett.get_func_info()
    // if info.can_error {
    //     set_call = vgen_error_code_reset(set_call)
    //     set_call.rett = type_void(p.build)
    // }

    return set_call
}

fn offset_get_func(p: Parser, on: Value) Func !not_found {
    let class = on.rett.get_class() !? null

    let func : ?Func = null
    if isset(class) {
        func = class.offset
        if !isset(func) {
            let for_class = class.mode_for_class
            if isset(for_class) : func = for_class.offset
        }
    }

    if !isset(func) : throw not_found
    return func
}

fn offset_assign_func(p: Parser, on: Value) Func !none {
    let class = on.rett.get_class() !? null
    let func : ?Func = null
    if isset(class) {
        func = class.offset_assign
        if !isset(func) {
            let for_class = class.mode_for_class
            if isset(for_class) : func = for_class.offset_assign
        }
    }
    if !isset(func) : throw none
    return func
}
