
fn parse_offset_value(p: Parser, scope: Scope, on: Value) Value {
    // 
    let func = offset_get_func(p, on)
    let fptr = vgen_func_ptr(func)
    let argvs = Array[Value].new()
    argvs.push(on)
    read_func_call_arg_values(p, scope, fptr, "]", argvs)

    let t = p.tok(true, true, false)
    let is_assign = p.word_is("=") || p.word_is("+=") || p.word_is("-=") || p.word_is("*=") || p.word_is("/=") || p.word_is("%=")
    
    if !is_assign {
        let get_call = vgen_func_call(p.build, p.get_ds(), fptr, argvs)
        // Error handling
        let info = fptr.rett.func_info
        if isset(info) : if info.can_error : get_call = value_error_handling(p, scope, get_call, info)
        //
        return get_call
    }

    let setfunc = offset_set_func(p, on)
    let last_arg = setfunc.args.get(setfunc.args.length - 1) ! p.error("Missing $offset_set value argument")

    t = p.tok(true, true)
    if p.word_is("=") {

        p.set_suggest(last_arg.type)
        let right = read_value(p, scope)
        p.pop_suggest()

        right = right.try_convert(p.get_ds(), last_arg.type)
        last_arg.type.compat_check(right.rett, p)

        let set_values = argvs.copy()
        set_values.push(right)

        let set_call = vgen_func_call(p.build, p.get_ds(), vgen_func_ptr(setfunc), set_values)
        return set_call
    }

    let get_call = vgen_func_call(p.build, p.get_ds(), fptr, argvs)

    // Operation
    let op = op_none
    let rightv : ?Value = null 
    if p.word_is("++") || p.word_is("--") {
        if !get_call.rett.is_int() : p.error("You can only use '++' and '--' on integer values")
        op = p.word_is("++") ? op_add : op_sub
        rightv = vgen_int(1, get_call.rett)

    } else if p.word_is("+=") : op = op_add
    else if p.word_is("-=") : op = op_sub
    else if p.word_is("*=") : op = op_mul
    else if p.word_is("/=") : op = op_div
    else if p.word_is("%=") : op = op_mod

    p.set_suggest(get_call.rett)
    let addv = isset(rightv) ? rightv : read_value(p, scope)
    p.pop_suggest()

    let right = value_handle_op(p, scope, op, get_call, addv)

    right = right.try_convert(p.get_ds(), last_arg.type)
    last_arg.type.compat_check(right.rett, p)

    let set_values = argvs.copy()
    set_values.push(right)

    let set_call = vgen_func_call(p.build, p.get_ds(), vgen_func_ptr(setfunc), set_values)
    return set_call
}

fn offset_get_func(p: Parser, on: Value) Func {
    let class = on.rett.class
    let func : ?Func = null
    if isset(class) {
        func = class.offset
    }
    if !isset(func) : p.error("Type: " + on.rett + " has no '[]' get offset function")
    return func
}

fn offset_set_func(p: Parser, on: Value) Func {
    let class = on.rett.class
    let func : ?Func = null
    if isset(class) {
        func = class.offset_set
    }
    if !isset(func) : p.error("Type: " + on.rett + " has no '[]' set offset function")
    return func
}
