
fn parse_offset_value(p: Parser, scope: Scope, on: Value) Value {
    // 
    let func = offset_get_func(p, on)
    let fptr = vgen_func_ptr(func)
    let argvs = Array[Value].new()
    argvs.push(on)
    read_func_call_arg_values(p, scope, fptr, "]", argvs)

    let t = p.tok(true, true, false)
    let is_assign = p.word_is("=")
    
    if !is_assign {
        let get_call = vgen_func_call(p.build, p.get_ds(), fptr, argvs)
        // Error handling
        let info = fptr.rett.func_info
        if isset(info) : if info.can_error : get_call = value_error_handling(p, scope, get_call, info)
        //
        return get_call
    }

    let setfunc = offset_set_func(p, on)
    let last_arg = setfunc.args.get(setfunc.args.length - 1) ! p.error("Missing $offset_set value argument")

    t = p.tok(true, true)

    p.set_suggest(last_arg.type)
    let right = read_value(p, scope)
    p.pop_suggest()

    right = right.try_convert(p.get_ds(), last_arg.type)
    last_arg.type.compat_check(right.rett, p)

    let set_values = argvs.copy()
    set_values.push(right)

    let set_call = vgen_func_call(p.build, p.get_ds(), vgen_func_ptr(setfunc), set_values)
    return set_call
}

fn offset_get_func(p: Parser, on: Value) Func {
    let class = on.rett.class
    let func : ?Func = null
    if isset(class) {
        func = class.offset
    }
    if !isset(func) : p.error("Type: " + on.rett + " has no '[]' get offset function")
    return func
}

fn offset_set_func(p: Parser, on: Value) Func {
    let class = on.rett.class
    let func : ?Func = null
    if isset(class) {
        func = class.offset_set
    }
    if !isset(func) : p.error("Type: " + on.rett + " has no '[]' set offset function")
    return func
}
