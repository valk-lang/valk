
fn read_ast(p: Parser, scope: Scope, single: bool) {

    let b = p.build
    let first = true

    while true {
        if single && !first : break

        p.backup()
        let t = p.tok(true, true)

        if t == tok_sign {
            if p.word_is("}") {
                break
            }
            if p.word_is(";") {
                continue
            }
            if p.word_is("#") && p.on_newline {
                parse_compile_macro(p)
                continue;
            }
        }
        if t == tok_word {
            if p.word_is("let") {
                ast_let(p, scope)
                continue
            }
            if p.word_is("return") {
                ast_return(p, scope)
                continue
            }
        }

        // Not a token -> Read value instead
        p.restore()
        let left = read_value(p, scope)

        scope.ast.push(Token {
            type: tk_statement
            value: left
        })
    }

    if scope.must_return && !scope.did_return {
        p.error("Missing 'return' statement")
    }

    // Return void
    if scope.type == sc_func {
        if !scope.did_return {
            scope.ast.push(Token {
                type: tk_return
            })
        }
    }
}

fn ast_let(p: Parser, scope: Scope) {
    let names = array[String]{}
    let types = array[?Type]{}
    let t = p.tok(true, false, false)
    if p.sign_is("(") {
        p.tok(true, false)
        // Multi
        while true {
            let name = p.read_word(true, true)
            if names.contains(name) : p.error("Duplicate name: " + name)
            names.push(name)
            // Type
            t = p.tok(true, false, false)
            if p.sign_is(":") {
                p.tok(true, false)
                let type = read_type(p, scope, true)
                types.push(type)
            } else {
                types.push(null)
            }
            // Next
            p.expect2(",", ")", true, true)
            if p.word_is(")") : break
        }
    } else if t == tok_word {
        let name = p.read_word(true, true)
        names.push(name)
        // Type
        t = p.tok(true, false, false)
        if p.sign_is(":") {
            p.tok(true, false)
            let type = read_type(p, scope, true)
            types.push(type)
        } else {
            types.push(null)
        }
    } else {
        p.error_token()
    }

    p.expect("=", true, true)

    let suggest_type = p.suggest_type
    if types.length == 1 {
        let t1 = types.get(0) ? null
        if isset(t1) : p.suggest_type = t1
    }
    let v = read_value(p, scope)
    p.suggest_type = suggest_type

    let values = v.type == v_multi ? (v.values ?? array[Value]{}) : array[Value]{ v }

    if names.length > values.length : p.error("Right side of '=' is not returning enough values to fit all your variables")

    each names as i, name {
        let type = types.get(i) ! p.error("Missing type (bug)")
        let value = values.get(i) ! p.error("Missing value (bug)")

        if isset(type) {
            value = try_convert(value, type)
            type.compat_check(value.rett, p)
        } else {
            type = value.rett
        }
        if !isset(type) : p.error("Failed to adopt value type (bug)")

        let decl = Decl.new(type, false)

        scope.ast.push(Token {
            type: tk_declare
            decl: decl
            value: value
        })

        scope.set_idf(p, name, Idf.for_decl(decl))
    }
}

fn ast_return(p: Parser, scope: Scope) {

    let func = p.func
    if !isset(func) : p.error("Using 'return' outside a function")

    let rett = func.rett_eax()

    let value: ?Value = null
    
    if rett.is_void() {
        let next = p.tok(true, true, false)
        if !p.word_is(";") && !p.on_newline : p.error("The function has a 'void' return type. We expected 'return' to be followed by a newline or ';'")
    } else {
        let suggest_type = p.suggest_type
        p.suggest_type = rett
        let v = read_value(p, scope)
        p.suggest_type = suggest_type

        rett.compat_check(v.rett, p)
        value = v
    }

    scope.ast.push(Token {
        type: tk_return
        value: value
    })

    scope.did_return = true
}
