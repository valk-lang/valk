
fn read_ast(p: Parser, scope: Scope, single: bool) {

    let b = p.build
    let first = true

    while true {
        if single && !first : break

        if scope.did_return {
            p.skip_body("}")
            if scope.did_exit {
                let func = p.func
                if !isset(func) : p.error("Missing scope function (bug)")
                scope.ast.push(Token {
                    type: tk_return
                    value1: func.empty_return_value()
                })
            }
            break
        }

        p.backup()
        let t = p.tok(true, true)
        first = false

        if t == tok_sign {
            if p.word_is("}") {
                break
            }
            if p.word_is(";") {
                continue
            }
            if p.word_is("#") && p.on_newline {
                parse_compile_macro(p)
                continue;
            }
        }
        if t == tok_word {
            if p.word_is("let") {
                ast_let(p, scope)
                continue
            }
            if p.word_is("return") {
                ast_return(p, scope)
                continue
            }
            if p.word_is("while") {
                ast_while(p, scope)
                continue
            }
            if p.word_is("if") {
                ast_if(p, scope)
                continue
            }
            if p.word_is("throw") {
                ast_throw(p, scope)
                continue
            }
            if p.word_is("break") {
                ast_break(p, scope)
                continue
            }
            if p.word_is("continue") {
                ast_continue(p, scope)
                continue
            }
        }
        if t == tok_at_word {
            if p.word_is("@allocas") {
                let func = p.func
                if !isset(func) : p.error("Using @allocas outside function")
                if !func.is_entrance : p.error("@allocas can only be used inside a function thats flagged with $entrance")
                scope.ast.push(Token { type: tk_allocas })
                continue
            }
        }

        // Not a token -> Read value instead
        p.restore()
        let left = read_value(p, scope)

        t = p.tok(true, true, false)
        if t == tok_sign {
            if p.word_is("=") || p.word_is("+=") || p.word_is("-=") || p.word_is("*=") || p.word_is("/=") || p.word_is("%=") {
                t = p.tok(true, true)

                let op = op_none
                if p.word_is("+=") : op = op_add
                else if p.word_is("-=") : op = op_sub
                else if p.word_is("*=") : op = op_mul
                else if p.word_is("/=") : op = op_div

                p.set_suggest(left.rett)
                let right = read_value(p, scope)
                p.pop_suggest()

                if op != op_none {
                    right = value_handle_op(p, op, left, right)
                }

                right = right.try_convert(left.rett)

                if right.type == v_undefined : continue

                if left.type == v_decl {
                    let decl = left.decl
                    if isset(decl) {
                        if decl.type.nullable {
                            if right.rett.nullable {
                                if !left.rett.nullable {
                                    scope.not_null_remove(decl)
                                    left.rett = decl.type
                                }
                            } else {
                                scope.not_null_add(decl)
                            }
                        }
                    }
                }

                left.rett.compat_check(right.rett, p)

                scope.ast.push(Token {
                    type: tk_assign
                    value1: left
                    value2: right
                })
                continue
            }
        }

        scope.ast.push(Token {
            type: tk_statement
            value1: left
        })
    }

    if scope.must_return && !scope.did_return {
        p.error("Missing 'return' statement")
    }

    // Return void
    if scope.type == sc_func {
        if !scope.did_return {
            scope.ast.push(Token {
                type: tk_return
            })
        }
    }
}

fn ast_let(p: Parser, scope: Scope) {
    let names = array[String]{}
    let types = array[?Type]{}
    let t = p.tok(true, false, false)
    if p.sign_is("(") {
        p.tok(true, false)
        // Multi
        while true {
            let name = p.read_word(true, true)
            if names.contains(name) : p.error("Duplicate name: " + name)
            names.push(name)
            // Type
            t = p.tok(true, false, false)
            if p.sign_is(":") {
                p.tok(true, false)
                let type = read_type(p, scope, true)
                types.push(type)
            } else {
                types.push(null)
            }
            // Next
            p.expect2(",", ")", true, true)
            if p.word_is(")") : break
        }
    } else if t == tok_word {
        let name = p.read_word(true, true)
        names.push(name)
        // Type
        t = p.tok(true, false, false)
        if p.sign_is(":") {
            p.tok(true, false)
            let type = read_type(p, scope, true)
            types.push(type)
        } else {
            types.push(null)
        }
    } else {
        p.error_token()
    }

    p.expect("=", true, true)

    let suggest_type = p.suggest_type
    if types.length == 1 {
        let t1 = types.get(0) ? null
        if isset(t1) : p.suggest_type = t1
    }
    let v = read_value(p, scope)
    p.suggest_type = suggest_type

    let values = v.type == v_multi ? (v.values ?? array[Value]{}) : array[Value]{ v }

    if names.length > values.length : p.error("Right side of '=' is not returning enough values to fit all your variables")

    each names as i, name {
        let type = types.get(i) ! p.error("Missing type (bug)")
        let value = values.get(i) ! p.error("Missing value (bug)")

        if isset(type) {
            value = value.try_convert(type)
            type.compat_check(value.rett, p)
        } else if (value.type != v_undefined) {
            type = value.rett
        }
        if !isset(type) : p.error("Failed to adopt value type (bug)")

        let decl = Decl.new(type, false)
        scope.set_idf(p, name, Idf.for_decl(decl))

        if value.type == v_undefined : continue

        scope.ast.push(Token {
            type: tk_declare
            decl: decl
            value1: value
        })
    }
}

fn ast_return(p: Parser, scope: Scope) {

    let func = p.func
    if !isset(func) : p.error("Using 'return' outside a function")

    let rett = func.rett_eax()

    let value: ?Value = null
    
    if rett.is_void() {
        let next = p.tok(true, true, false)
        if !p.word_is(";") && !p.on_newline : p.error("The function has a 'void' return type. We expected 'return' to be followed by a newline or ';'")
    } else {
        let suggest_type = p.suggest_type
        p.suggest_type = rett
        let v = read_value(p, scope)
        p.suggest_type = suggest_type

        v = v.try_convert(rett)
        rett.compat_check(v.rett, p)
        value = v
    }

    scope.ast.push(Token {
        type: tk_return
        value1: value
    })

    scope.did_return = true
}


fn ast_while(p: Parser, scope: Scope) {
    let cond = read_value(p, scope)
    if !cond.rett.is_bool() : p.error("The while condition value must be of type bool, not: " + cond.rett)
    p.expect2("{", ":", true, true)
    let single = p.word_is(":")
    let sub = scope.sub_scope(sc_loop)

    apply_issets(sub, cond.issets)

    read_ast(p, sub, single)

    scope.not_null_remove_check(sub)

    scope.ast.push(Token {
        type: tk_while
        value1: cond
        scope1: sub
    })
}

fn ast_if(p: Parser, scope: Scope) {
    let cond = read_value(p, scope)
    if !cond.rett.is_bool() : p.error("The if condition value must be of type bool, not: " + cond.rett)
    p.expect2("{", ":", true, true)
    let single = p.word_is(":")
    let sub = scope.sub_scope(sc_if)
    let sub_else = scope.sub_scope(sc_if)

    apply_issets(sub, cond.issets)

    read_ast(p, sub, single)

    if sub.did_return : apply_issets(scope, cond.not_issets)
    apply_issets(sub_else, cond.not_issets)

    let t = p.tok(true, true, false)
    if p.word_is("else") {
        t = p.tok(true, true)
        t = p.tok(true, true, false)
        if p.word_is("if") {
            t = p.tok(true, true)
            ast_if(p, sub_else)
        } else {
            p.expect2("{", ":", true, true)
            let single = p.word_is(":")
            read_ast(p, sub_else, single)
        }
    }

    scope.not_null_remove_check(sub)
    scope.not_null_remove_check(sub_else)
    apply_issets(scope, sub.not_null.intersect(sub_else.not_null))

    scope.ast.push(Token {
        type: tk_if
        value1: cond
        scope1: sub
        scope2: sub_else
    })
}

fn ast_throw(p: Parser, scope: Scope) {
    let func = p.func
    if !isset(func) : p.error("Using 'throw' outside a function")

    let err = p.read_word(true, false)
    let hash = func.errors.get(err) ! p.error("Unknown error '" + err + "'. Please add the error to your function declaration.")

    let b = p.build
    let g = b.valk_global("core", "error_code")
    scope.ast.push(Token {
        type: tk_assign
        value1: vgen_global(g)
        value2: vgen_int(hash, b.valk_type("type", "uint"))
    })

    scope.ast.push(Token {
        type: tk_return
        value1: func.empty_return_value()
    })

    scope.did_return = true
}

fn ast_break(p: Parser, scope: Scope) {

    let loop = scope.find_type(sc_loop) ! p.error("Using 'break' without being inside a loop")
    each loop.decls as decl {
        if !decl.type.is_gc() : continue
        scope.ast.push(Token {
            type: tk_assign
            value1: vgen_decl(decl)
            value2: vgen_null(decl.type)
        })
    }

    scope.ast.push(Token {
        type: tk_break
    })
    scope.did_return = true
}
fn ast_continue(p: Parser, scope: Scope) {

    let loop = scope.find_type(sc_loop) ! p.error("Using 'break' without being inside a loop")
    each loop.decls as decl {
        if !decl.type.is_gc() : continue
        scope.ast.push(Token {
            type: tk_assign
            value1: vgen_decl(decl)
            value2: vgen_null(decl.type)
        })
    }

    scope.ast.push(Token {
        type: tk_continue
    })
    scope.did_return = true
}
