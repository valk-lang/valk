
fn read_ast(p: Parser, scope: Scope, single: bool) {

    let b = p.build
    let first = true

    while true {
        if single && !first : break

        if scope.did_return {
            p.skip_body("}")
            if scope.did_exit {
                let func = p.func
                if !isset(func) : p.error("Missing scope function (bug)")
                scope.ast.push(Token {
                    type: tk_return
                    value1: func.empty_return_value()
                })
            }
            break
        }

        p.backup()
        let t = p.tok(true, true)
        first = false

        if t == tok_sign {
            if p.word_is("}") {
                break
            }
            if p.word_is(";") {
                continue
            }
            if p.word_is("#") && p.on_newline {
                parse_compile_macro(p, scope)
                continue;
            }
            if p.word_is("{") {
                let sub = scope.sub_scope(sc_default)
                read_ast(p, sub, false)
                if sub.did_return : scope.did_return
                scope.ast.push(Token { type: tk_inline_scope, scope1: sub })
                continue
            }
        }
        if t == tok_word {
            if p.word_is("let") {
                ast_let(p, scope)
                continue
            }
            if p.word_is("return") {
                ast_return(p, scope)
                continue
            }
            if p.word_is("while") {
                ast_while(p, scope)
                continue
            }
            if p.word_is("each") {
                ast_each(p, scope)
                continue
            }
            if p.word_is("if") {
                ast_if(p, scope)
                continue
            }
            if p.word_is("throw") {
                ast_throw(p, scope)
                continue
            }
            if p.word_is("break") {
                ast_break(p, scope)
                continue
            }
            if p.word_is("continue") {
                ast_continue(p, scope)
                continue
            }
            if p.word_is("ir_comment") {
                ast_ir_comment(p, scope)
                continue
            }
        }
        if t == tok_at_word {
            if p.word_is("@allocas") {
                let func = p.func
                if !isset(func) : p.error("Using @allocas outside function")
                if !func.is_entrance : p.error("@allocas can only be used inside a function thats flagged with $entrance")
                // scope.ast.push(Token { type: tk_allocas })
                scope.ast.push(Token { type: tk_inline_scope, scope1: func.scope_alloca })
                continue
            }
        }

        // Not a token -> Read value instead
        p.restore()
        let left = read_value(p, scope)

        t = p.tok(true, true, false)
        if t == tok_sign {
            if p.word_is("=") || p.word_is("+=") || p.word_is("-=") || p.word_is("*=") || p.word_is("/=") || p.word_is("%=") {
                t = p.tok(true, true)

                left.check_decl_mutable()

                let op = op_none
                if p.word_is("+=") : op = op_add
                else if p.word_is("-=") : op = op_sub
                else if p.word_is("*=") : op = op_mul
                else if p.word_is("/=") : op = op_div

                p.set_suggest(left.rett)
                let right = read_value(p, scope)
                p.pop_suggest()

                if op != op_none {
                    right = value_handle_op(p, scope, op, left, right)
                }

                right = right.try_convert(p.get_ds(), left.rett)

                if right.type == v_undefined : continue

                if left.type == v_decl {
                    let decl = left.decl
                    if isset(decl) {
                        if decl.type.nullable {
                            if right.rett.nullable {
                                if !left.rett.nullable {
                                    scope.not_null_remove(decl)
                                    left.rett = decl.type
                                }
                            } else {
                                scope.not_null_add(decl)
                            }
                        }
                    }
                }

                left.rett.compat_check(right.rett, p)

                scope.ast.push(Token {
                    type: tk_assign
                    value1: left
                    value2: right
                })

                if left.type == v_global {
                    let g = left.global
                    if isset(g) {
                        let type = g.type
                        if g.shared && isset(type) {
                            if type.is_gc() {
                                let share_func = b.valk_func("gc", "share_item_null_check")
                                let gtypes = array[Type]{ type }
                                // let func = get_func_generic(p, scope, share_func, gtypes)
                                let on = vgen_func_ptr(share_func)

                                scope.ast.push(Token {
                                    type: tk_statement
                                    value1: vgen_func_call(b, scope, on, array[Value]{ left })
                                })
                            }
                        }
                    }
                }

                continue
            }
        }

        scope.ast.push(Token {
            type: tk_statement
            value1: left
        })
    }

    if scope.must_return && !scope.did_return {
        p.error("Missing 'return' statement")
    }

    // Add continue add end of loop
    if scope.type == sc_loop && !scope.did_return {
        ast_continue(p, scope)
    }
    // Return void
    if scope.type == sc_func {
        if !scope.did_return {
            ast_return(p, scope)
        }
    }
}

fn ast_let(p: Parser, scope: Scope) {
    let names = array[String]{}
    let types = array[?Type]{}

    let first = true
    while p.sign_is(",") || first {
        if !first {
            p.tok(true, false)
        }
        first = false

        let name = p.read_word(true, true)
        names.push(name)
        // Type
        p.tok(true, false, false)
        if p.sign_is(":") {
            p.tok(true, false)
            let type = read_type(p, scope, true)
            types.push(type)
        } else {
            types.push(null)
        }

        p.tok(true, false, false)
    }


    // let t = p.tok(true, false, false)
    // if p.sign_is("(") {
    //     p.tok(true, false)
    //     // Multi
    //     while true {
    //         let name = p.read_word(true, true)
    //         if names.contains(name) : p.error("Duplicate name: " + name)
    //         names.push(name)
    //         // Type
    //         t = p.tok(true, false, false)
    //         if p.sign_is(":") {
    //             p.tok(true, false)
    //             let type = read_type(p, scope, true)
    //             types.push(type)
    //         } else {
    //             types.push(null)
    //         }
    //         // Next
    //         p.expect2(",", ")", true, true)
    //         if p.word_is(")") : break
    //     }
    // } else if t == tok_word {
    // } else {
    //     p.error_token()
    // }

    p.expect("=", true, true)

    let suggest_type = p.suggest_type
    if types.length == 1 {
        let t1 = types.get(0) ? null
        if isset(t1) : p.suggest_type = t1
    }
    let v = read_value(p, scope)
    p.suggest_type = suggest_type

    //
    let values = array[Value]{ v }
    let multi_values = v.multi_values
    if isset(multi_values) {
        values = multi_values
        scope.ast.push(Token {
            type: tk_statement
            value1: v
        })
    }

    if names.length > values.length : p.error("Right side of '=' is not returning enough values to fit all your variables")

    each names as i, name {
        let type = types.get(i) ! p.error("Missing type (bug)")
        let value = values.get(i) ! p.error("Missing value (bug)")

        if isset(type) {
            value = value.try_convert(p.get_ds(), type)
            type.compat_check(value.rett, p)
        } else if (value.type != v_undefined) {
            type = value.rett
        }
        if !isset(type) : p.error("Cannot determine the type for this variable")
        if type.is_void() : p.error("You cannot declare a variable of type 'void'")

        let decl = Decl.new(type, false)
        scope.set_idf(p, name, Idf.for_decl(decl))
        p.add_decl(decl)

        if type.nullable && !value.rett.nullable {
            scope.not_null_add(decl)
        }
        
        if value.type == v_undefined : continue

        scope.ast.push(Token {
            type: tk_declare
            decl: decl
            value1: value
        })
    }
}

fn ast_return(p: Parser, scope: Scope) {

    let for_scope = scope.find_type2(sc_func, sc_vscope) ! p.error("Unexpected 'return' statement")
    if for_scope.type == sc_vscope {
        ast_vscope_return(p, scope, for_scope)
        return
    }

    let func = p.func
    if !isset(func) : p.error("Using 'return' outside a function")

    let rett_types = func.rett_types
    let rett_decls = func.rett_decls

    let value: ?Value = null
    
    if rett_types.length == 0 {
        let next = p.tok(true, true, false)
        if !p.word_is(";") && !p.word_is("}") && !p.on_newline : p.error("The function has a 'void' return type. We expected 'return' to be followed by a newline or ';'")
        if p.word_is(";") : p.tok(true, true)
    } else {
        let rdecl_i : uint = 0
        each rett_types as i, rett {
            if i > 0 : p.expect(",", true, true)

            let suggest_type = p.suggest_type
            p.suggest_type = rett
            let v = read_value(p, scope)
            p.suggest_type = suggest_type

            v = v.try_convert(p.get_ds(), rett)
            rett.compat_check(v.rett, p)

            if i == 0 && rett.fits_eax() {
                value = v
                continue
            }

            let rdecl = rett_decls.get(rdecl_i++) ! p.error("Missing generated return variable (bug)")
            let type_of = rdecl.type.array_of
            if !isset(type_of) : p.error("Missing generated return variable type (bug)")
            scope.ast.push(Token {
                type: tk_assign
                value1: vgen_ptrv(vgen_decl(rdecl), type_of, vgen_int(0, type_uint(p.build)))
                value2: v
            })
        }
    }

    scope.ast.push(Token { type: tk_inline_scope, scope1: func.scope_defer })

    scope.ast.push(Token {
        type: tk_return
        value1: value
    })

    scope.did_return = true
}

fn ast_vscope_return(p: Parser, scope: Scope, vscope: Scope) {

    let func = p.func
    if !isset(func) : p.error("Using 'return' outside a function")

    // Types
    let define_decls = false
    let decls = p.vscope_decls ?? <{
        define_decls = true
        let list = array[Decl]{}
        p.vscope_decls = list
        return list
    }

    // Read values
    let values = array[Value]{}
    let first = true
    while p.word_is(",") || first {

        if !first : p.tok(true, true)
        first = false

        if !define_decls {
            if values.length == decls.length {
                p.error("Too many return values")
            }
        }
        let v = read_value(p, scope)
        if define_decls {
            decls.push(Decl.new(v.rett, false))
        } else {
            let decl = decls.get(values.length) ! p.error("Value scope - cannot find variable (bug)")
            decl.type.compat_check(v.rett, p)
        }

        let decl = decls.get(values.length) ! p.error("Value scope | cannot find variable (bug)")
        decl.is_mut = true
        p.add_decl(decl)
        values.push(v)

        scope.ast.push(Token {
            type: tk_assign
            value1: vgen_decl(decl)
            value2: v
        })

        p.tok(true, true, false)
    }

    if values.length < decls.length {
        p.error("Missing values. You returned fewer values compared to your previous return statement")
    }

    scope.did_return = true
}

fn ast_while(p: Parser, scope: Scope) {
    let cond = read_value(p, scope)
    if !cond.rett.is_bool() : p.error("The while condition value must be of type bool, not: " + cond.rett)
    p.expect2("{", ":", true, true)
    let single = p.word_is(":")
    let sub = scope.sub_scope(sc_loop)

    let ds = p.decl_scope
    p.decl_scope = sub

    apply_issets(sub, cond.issets)

    read_ast(p, sub, single)

    p.decl_scope = ds
    scope.not_null_remove_check(sub)

    scope.ast.push(Token {
        type: tk_while
        value1: cond
        scope1: sub
    })
}

fn ast_each(p: Parser, scope: Scope) {
    let on = read_value(p, scope)
    let class = on.rett.class
    if !isset(class) || on.rett.nullable : p.error("Cannot use 'each' on type: " + on.rett)
    let func = class.funcs.get("_each") ! p.error("Cannot use 'each' on type: '" + on.rett + "'. This type does not have an '_each' function")

    p.expect("=>", true, true)
    let kname : ?String = null
    let vname = p.read_word(true, true) 
    p.tok(true, true, false)
    if p.word_is(",") {
        p.tok(true, true)
        kname = vname
        vname = p.read_word(true, true)
    }


    p.expect2("{", ":", true, true)
    let single = p.word_is(":")
    let sub = scope.sub_scope(sc_loop)

    // Set decls
    let idecl = Decl.new(type_uint(p.build), false)
    idecl.is_mut = true
    p.add_decl(idecl)
    sub.loop_idecl = idecl

    scope.ast.push(Token {
        type: tk_assign
        value1: vgen_decl(idecl)
        value2: vgen_int(0, idecl.type)
    })

    let on_cached = vgen_cached(on)
    scope.ast.push(Token {
        type: tk_statement
        value1: on_cached
    })

    // Fcall
    let values = array[Value]{ on_cached, vgen_decl(idecl) }
    let fcall = vgen_func_call(p.build, sub, vgen_func_ptr(func), values)
    let retvs = fcall.multi_values
    if !isset(retvs) : p.error("_each function must return atleast 2 values (key, value)")
    if retvs.length < 2 : p.error("_each function must return atleast 2 values (key, value)")

    // Check error
    let break_scope = sub.sub_scope(sc_default)
    break_scope.ast.push(Token {
        type: tk_break
    })
    break_scope.did_return = true
    fcall = Value { 
        type: v_errh
        errh: ErrorHandler {
            type: errh_break
            on: fcall
            scope: break_scope
            decl_err: null
            decl_msg: null
        }
        rett: fcall.rett
    }
    sub.ast.push(Token {
        type: tk_statement
        value1: fcall
    })

    // Declare values
    let vv = retvs.get(1) ! p.error("Missing _each return value 2 (bug)")
    let vdecl = Decl.new(vv.rett, false)
    sub.set_idf(p, vname, Idf.for_decl(vdecl))
    p.add_decl(vdecl)
    sub.ast.push(Token {
        type: tk_declare
        decl: vdecl
        value1: vv
    })

    if isset(kname) {
        let kv = retvs.get(0) ! p.error("Missing _each return value 1 (bug)")
        let kdecl = Decl.new(kv.rett, false)
        sub.set_idf(p, kname, Idf.for_decl(kdecl))
        p.add_decl(kdecl)
        sub.ast.push(Token {
            type: tk_declare
            decl: kdecl
            value1: kv
        })
    }

    // AST
    let ds = p.decl_scope
    p.decl_scope = sub
    read_ast(p, sub, single)
    p.decl_scope = ds

    scope.ast.push(Token {
        type: tk_each
        scope1: sub
    })
}

fn ast_if(p: Parser, scope: Scope) {
    let cond = read_value(p, scope)
    if !cond.rett.is_bool() : p.error("The if condition value must be of type bool, not: " + cond.rett)
    p.expect2("{", ":", true, true)
    let single = p.word_is(":")
    let sub = scope.sub_scope(sc_if)
    let sub_else = scope.sub_scope(sc_if)

    apply_issets(sub, cond.issets)

    read_ast(p, sub, single)

    if sub.did_return : apply_issets(scope, cond.not_issets)
    apply_issets(sub_else, cond.not_issets)

    let t = p.tok(true, true, false)
    if p.word_is("else") {
        t = p.tok(true, true)
        t = p.tok(true, true, false)
        if p.word_is("if") {
            t = p.tok(true, true)
            ast_if(p, sub_else)
        } else {
            p.expect2("{", ":", true, true)
            let single = p.word_is(":")
            read_ast(p, sub_else, single)
        }
    }

    scope.not_null_remove_check(sub)
    scope.not_null_remove_check(sub_else)
    apply_issets(scope, sub.not_null.intersect(sub_else.not_null))

    scope.ast.push(Token {
        type: tk_if
        value1: cond
        scope1: sub
        scope2: sub_else
    })
}

fn ast_throw(p: Parser, scope: Scope) {
    let func = p.func
    if !isset(func) : p.error("Using 'throw' outside a function")

    let err = p.read_word(true, false)
    let hash = func.errors.get(err) ! p.error("Unknown error '" + err + "'. Please add the error to your function declaration.")

    let b = p.build
    let g = b.valk_global("core", "error_code")
    scope.ast.push(Token {
        type: tk_assign
        value1: vgen_global(g)
        value2: vgen_int(hash, b.valk_type("type", "uint"))
    })

    scope.ast.push(Token { type: tk_inline_scope, scope1: func.scope_defer })

    scope.ast.push(Token {
        type: tk_return
        value1: func.empty_return_value()
    })

    scope.did_return = true
}

fn ast_break(p: Parser, scope: Scope) {

    let loop = scope.find_type(sc_loop) ! p.error("Using 'break' without being inside a loop")
    each loop.decls as decl {
        if !decl.type.is_gc() : continue
        scope.ast.push(Token {
            type: tk_assign
            value1: vgen_decl(decl)
            value2: vgen_null(decl.type)
        })
    }

    scope.ast.push(Token {
        type: tk_break
    })
    scope.did_return = true
}
fn ast_continue(p: Parser, scope: Scope) {

    let loop = scope.find_type(sc_loop) ! p.error("Using 'break' without being inside a loop")
    each loop.decls as decl {
        if !decl.type.is_gc() : continue
        scope.ast.push(Token {
            type: tk_assign
            value1: vgen_decl(decl)
            value2: vgen_null(decl.type)
        })
    }

    let idecl = loop.loop_idecl
    if isset(idecl) {
        scope.ast.push(Token {
            type: tk_assign
            value1: vgen_decl(idecl)
            value2: vgen_op(vgen_decl(idecl), vgen_int(1, idecl.type), op_add, idecl.type)
        })
    }
    scope.ast.push(Token {
        type: tk_continue
    })
    scope.did_return = true
}

fn ast_ir_comment(p: Parser, scope: Scope) {
    p.expect("(", false, false)

    p.expect_string(true, true)
    let comment = p.word().trim("\"")

    p.expect(")", true, true)

    scope.ast.push(Token {
        type: tk_ir_comment
        string1: comment
    })
}
