
class Enum {
    build: Build
    fc: Fc
    act: int
    name: String
    display_name: String
    chunk_type: ?Chunk
    type: ?Type (null)
    item_type: ?Type (null)
    item_chunks: Map[Chunk] (Map[Chunk].new())
    values: Map[?Chunk] (Map[?Chunk].new())
    values_int: Map[int] (Map[int].new())

    fn get_type() Type {
        let et = this.type
        if isset(et) : return et

        let b = this.build
        let chunk = this.chunk_type
        let fc = this.fc

        let type = b.valk_type("type", "int")
        if isset(chunk) {
            let p = Parser.new(chunk, null)
            type = read_type(p, fc.scope, true)
            let te = type.enum
            if isset(te) : p.error("You cannot use an enum type as the type for another enum")
        }
        this.item_type = type
        let etype = type.clone()
        etype.enum = this
        this.type = etype
        return etype
    }

    fn get_item_type() Type {
        this.get_type()
        let type = this.item_type ?! this.build.error("Missing item type for enum")
        return type
    }
}

// Build types
value b_exe (1)
value b_lib (2)
value b_doc (3)

// Scope
enum SCOPE {
    default
    fc
    nsc
    loop
    if
    func
    class
    vscope
}

// Parser
enum TOK {
    none
    end
    word
    at_word
    char
    string
    sign
    int
    float
    hex
    octal
    flag
}

// Access types
enum ACT {
    undefined (0)
    private (1)
    readonly (2)
    public (4)
}

// Alias
enum ALIAS {
    type
    value
    idf
}

// Types
enum TYPE {
    void
    ptr
    struct
    class
    voidptr
    int
    float
    undefined
    array
    error
    error_item
    func
    multi
    bool
    closure
    none
    promise
    any // For docs
    ref
    unsafe_ref
}

// Idf
enum IDF {
    type
    value
    decl
    func
    class
    scope
    global
    alias
    trait
    enum
    macro
    macro_values
    idf
    idf_group
    class_prop
    prop
}

// Class types
enum CT {
    class
    struct
    pointer
    int
    float
    bool
}

// Link
value link_default (0)
value link_dynamic (1)
value link_static (2)

// Libs
value libs_none (0)
value libs_use (1)
value libs_prefer (2)

// Token
enum AST {
    statement
    declare
    return
    while
    if
    assign
    break
    continue
    allocas
    gc_offsets
    ir_comment
    inline_scope
    each
    vscope_return
}

// Value
value v_func_ptr (1)
value v_string (2)
value v_decl (3)
value v_prop (4)
value v_int (5)
value v_func_call (6)
value v_multi_return (7)
value v_memcpy (8)
value v_op (9)
value v_ptrv (10)
value v_incr (11)
value v_decr (12)
value v_bool (13)
value v_cast (14)
value v_global (15)
value v_null (16)
value v_compare (17)
value v_and_or (18)
value v_class_init (19)
value v_buffer (20)
value v_not (21)
value v_undefined (22)
value v_wrap (23)
value v_ptr_offset (24)
value v_stack_alloc (25)
value v_this_or_that (26)
value v_declare (27)
value v_altv (28)
value v_altv_break (29)
value v_assign (30)
value v_ptr_of (31)
value v_vscope (32)
value v_setjmp (33)
value v_longjmp (34)
value v_grouped_values (35)
value v_export_symbol (36)
value v_atomic_op (37)
value v_float (38)
value v_err_code_reset (39)
value v_inline_scope (40)
value v_cond (41)
value v_phi (42)
value v_array_init (43)

// Ops
value op_none (0)
value op_add (1)
value op_sub (2)
value op_mul (3)
value op_div (4)
value op_mod (5)

value op_eq (6)
value op_ne (7)
value op_lte (8)
value op_lt (9)
value op_gte (10)
value op_gt (11)

value op_and (12)
value op_or (13)

value op_shl (14)
value op_shr (15)

value op_bit_and (16)
value op_bit_or (17)
value op_bit_xor (18)
value op_bit_not (19)

value cm_block_any (0)
value cm_block_if (1)
value cm_block_loop_class (2)
value cm_block_loop_global (3)
value cm_block_loop_props (4)
value cm_block_loop_tests (5)
value cm_block_loop_macro_values (6)
value cm_block_loop_class_props (7)

// Scope
value pat_parts (1)
value pat_optional (2)
value pat_repeat (3)
value pat_token (4)
value pat_value (5)
value pat_type (6)
value pat_suggest (7)
