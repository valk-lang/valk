
class Enum {
    build: Build
    fc: Fc
    act: int
    name: String
    display_name: String
    chunk_type: ?Chunk
    type: ?Type (null)
    item_type: ?Type (null)
    item_chunks: Map[Chunk] (Map[Chunk].new())
    values: Map[?Chunk] (Map[?Chunk].new())
    values_int: Map[int] (Map[int].new())

    fn get_type() Type {
        let et = this.type
        if isset(et) : return et

        let b = this.build
        let chunk = this.chunk_type
        let fc = this.fc

        let type = b.valk_type("type", "int")
        if isset(chunk) {
            let p = Parser.new(chunk, null)
            p.ctx.unit = fc.unit
            type = read_type(p, fc.scope, true)
            let te = type.enum
            if isset(te) : p.error("You cannot use an enum type as the type for another enum")
        }
        this.item_type = type
        let etype = type.clone()
        etype.enum = this
        this.type = etype
        return etype
    }

    fn get_item_type() Type {
        this.get_type()
        let type = this.item_type ?! this.build.error("Missing item type for enum")
        return type
    }
}

// Build types
enum BUILDTYPE {
    exe
    lib
    doc
    ir
}

// Link
enum LINK {
    default
    dynamic
    static
    framework
}

// Libs
enum LIBS {
    none
    use
    prefer
}

// Scope
enum SCOPE {
    default
    fc
    nsc
    loop
    if
    func
    class
    vscope
}

// Parser
enum TOK {
    none
    end
    word
    at_word
    char
    string
    sign
    int
    float
    hex
    octal
    flag
}

// Access types
enum ACT {
    undefined (0)
    private (1)
    readonly (2)
    public (4)
}

// Alias
enum ALIAS {
    type
    value
    idf
}

// Types
enum TYPE {
    void
    ptr
    null
    struct
    class
    voidptr
    int
    float
    undefined
    array
    error
    error_item
    func
    multi
    bool
    closure
    none
    promise
    any // For docs
    ref
    unsafe_ref
}

// Idf
enum IDF {
    type
    value
    decl
    func
    class
    scope
    global
    alias
    trait
    enum
    macro
    macro_values
    idf
    idf_group
    class_prop
    prop
}

// Class types
enum CT {
    class
    struct
    pointer
    int
    float
    bool
}

// Token
enum AST {
    statement
    declare
    return
    while
    if
    assign
    break
    continue
    allocas
    ir_comment
    inline_scope
    each
    vscope_return
    decl_offset
    unreachable
}

// Value
enum VAL {
    func_ptr
    string
    decl
    prop
    int // 5
    func_call // 6
    retv
    memcpy
    op
    ptrv // 10
    incr
    decr
    bool
    cast
    global // 15
    null
    compare
    and_or
    class_init
    buffer // 20
    not
    undefined
    wrap
    ptr_offset
    stack_alloc
    this_or_that
    declare
    altv
    altv_break
    assign
    ptr_of
    vscope
    setjmp
    longjmp
    grouped_values
    export_symbol
    atomic_op
    atomic_store
    atomic_load
    float
    inline_scope
    cond
    phi
    array_init
    load
}

// Ops
enum OP {
    none
    add
    sub
    mul
    div
    mod
    eq
    ne
    lte
    lt
    gte
    gt
    and
    or
    shl
    shr
    bit_and
    bit_or
    bit_xor
    bit_not
}

// Compile macro block types
enum CMB {
    any
    if
    loop_class
    loop_global
    loop_props
    loop_tests
    loop_macro_values
    loop_class_props
}

// Macro pattern types
enum MPAT {
    parts
    optional
    repeat
    token
    value
    type
    suggest
}
