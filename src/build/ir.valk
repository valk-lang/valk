

class IR {
    unit: Unit
    build: Build
    func_active: ?IRFunc (null)
    block_active: ?IRBlock (null)
    block_loop_cond: ?IRBlock (null)
    block_loop_after: ?IRBlock (null)
    block_vscope_after: ?IRBlock (null)
    //
    defined_globals: Array[Global] (Array[Global]{})
    defined_symbols: Array[String] (Array[String]{})
    extern_functions: Array[Func] (Array[Func]{})
    func_by_content: Map[Func] (Map[Func]{})
    //
    code_func_defs: StringComposer (StringComposer.new(4000))
    code_global_defs: StringComposer (StringComposer.new(4000))
    code_strings: StringComposer (StringComposer.new(16000))
    //
    stringc: uint (0)
    debug: bool (false)

    static fn new(u: Unit) IR {
        let ir = IR {
            unit: u
            build: u.build
        }
        return ir
    }

    fn reset() {
        this.func_active = null
        this.block_active = null
        this.block_loop_cond = null
        this.block_loop_after = null
        this.block_vscope_after = null
        // this.varc = 0
    }

    fn set_func(func: IRFunc) {
        this.func_active = func
        this.set_block(func.block_code)
    }
    fn func() IRFunc {
        let b = this.func_active
        if !isset(b) : this.error("Missing active func (bug)")
        return b
    }

    fn set_block(block: IRBlock) {
        this.block_active = block
    }
    fn block() IRBlock {
        let b = this.block_active
        if !isset(b) : this.error("Missing active block (bug)")
        return b
    }
    fn code() StringComposer {
        return this.block().code
    }
    fn var() String {
        let func = this.func_active ?! this.error("Missing IR function")
        return "%." + (func.varc++)
    }

    fn final_code() String {
        let final = StringComposer.new(32000)
        let funcs = this.unit.functions

        // Define strings
        each funcs as func {
            if !func.info_used : continue
            each func.strings as str {
                ir_string(this, str)
            }
            each func.functions_used as func {
                ir_check_func_definition(this, func)
            }
        }

        // LLVM internals
        this.ir_define_llvm_internals(final)
        final.append_str("\n");

        // Globals
        each this.unit.globals as g {
            if !g.is_used : continue
            ir_check_global_definition(this, g)
        }

        final.append(this.code_global_defs)
        final.append_str("\n");

        // Extern functions
        final.append(this.code_func_defs)
        final.append_str("\n");

        // Strings
        final.append(this.code_strings)
        final.append_str("\n");

        // Functions
        each funcs as func {
            if !func.info_used : continue
            if func.is_extern : continue
            if func.is_generic_base : continue
            if func.has_generic_args : continue

            final.append_str("; Function: ")
            final.append_str(func.display_name)
            final.append_str("\n")

            let fc = func.fc
            final.append_str("; Location: ")
            final.append_str(fc.path)
            let body = func.chunk_body
            if isset(body) {
                final.append_str(" @ Line: ")
                final.append_uint(body.line)
            }
            final.append_str("\n")

            // Check alias
            let pfunc = this.func_by_content.get(func.ir_code) !? null
            if isset(pfunc) {
                // Alias function found
                this.ir_write_func_alias(final, func, pfunc)
                continue
            }
            // No alias found
            this.func_by_content.set(func.ir_code, func)
            //
            final.append_str("define dso_local ")
            final.append_str(ir_type(func.rett_real))
            final.append_str(" @")
            final.append_str(func.export_name)
            final.append_str(func.ir_code)
            final.append_str("\n");
        }

        // Tags
        final.append_str("\n");
        final.append_str("attributes #0 = { \"frame-pointer\"=\"all\" }\n");
        final.append_str("\n");

        return final.to_string()
    }

    fn ir_write_func_alias(code: StringComposer, from: Func, to: Func) {
        code.append_str("@")
        code.append_str(from.export_name)
        code.append_str(" = alias ")

        code.append_str(ir_type(from.rett_real))

        // Args
        code.append_str(" (")
        let count = 0
        let args = from.args
        each args as arg, i {
            if count > 0 : code.append_str(", ")
            // ir_func_arg(header, arg.decl.type, null)
            code.append_str(ir_type(arg.decl.type))
            count++
        }
        // Infinite args
        if from.infinite_args {
            if count > 0 : code.append_str(", ")
            code.append_str("...")
        }
        //
        code.append_str("), ptr @")
        code.append_str(to.export_name)
        code.append_str("\n\n")
    }

    fn ir_define_llvm_internals(code: StringComposer) {
        code.append_str("declare ptr @llvm.frameaddress(i32) nocallback nofree nosync nounwind readnone willreturn\n")
        code.append_str("declare ptr @llvm.stacksave() nounwind\n")
        code.append_str("declare i32 @llvm.eh.sjlj.setjmp(ptr) nounwind returns_twice\n")
        code.append_str("declare void @llvm.eh.sjlj.longjmp(ptr) nounwind\n")
        code.append_str("declare void @_setjmp(ptr) nounwind\n")
        code.append_str("declare void @longjmp(ptr, i32) nounwind\n")
        code.append_str("declare void @llvm.memset.inline.p0.p0.i64(ptr, i8, i64, i1)\n")
        code.append_str("declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)\n")
    }

    fn error(msg: String) $exit {
        this.build.error("# IR Error: " + msg)
    }

}
