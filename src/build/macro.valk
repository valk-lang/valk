
struct Macro {
    name: String
    display_name: String
    pattern: Pattern (Pattern {
        type: pat_parts
        parts: Array[Pattern].new()
    })
    scope: Scope
    chunk: ?Chunk (null)
    is_value: bool (false)
}

struct Pattern {
    type: int // parts, optional, repeat, token, value, type
    token: String ("")
    name: String ("")
    parts: ?Array[Pattern] (null)
}


fn parse_macro_base(p: Parser, m: Macro) {

    let used_var_names = Array[String].new()
    parse_macro_pattern(p, m.pattern, used_var_names)

    if p.next_word_is("<{", true, true, false) {
        m.chunk = p.clone_chunk()
        m.is_value = true
        p.expect("<{", true, true)
        p.skip_body("}")
    } else {
        p.expect2("<{", "{", true, true)
        m.chunk = p.clone_chunk()
        p.skip_body("}")
    }
}

fn parse_macro_pattern(p: Parser, pat: Pattern, vars: Array[String]) {

    let parts = pat.parts
    if !isset(parts) : return

    while true {
        let t = p.tok(true, true, false)
        if t == tok_string {
            p.tok(true, true)
            parts.push(Pattern {
                type: pat_token
                token: p.word()
            })
            continue
        }

        if pat.type == pat_optional && parts.length == 0 {
            p.error("The first part of an 'optional' macro item must be valid token between double-quotes")
        }

        if p.word_is("V") || p.word_is("T") {
            p.tok(true, true)
            let is_value = p.word_is("V")
            p.expect(":", false, false)
            let name = p.read_word(false, false)
            if vars.contains(name) : p.error("Duplicate macro variable name: " + name)
            vars.push(name)
            parts.push(Pattern {
                type: is_value ? pat_value : pat_type
                name: name
            })
            continue
        }
        if p.word_is("optional") {
            p.tok(true, true)
            p.expect("(", false, false)
            let sub = Pattern {
                type: pat_optional
                parts: Array[Pattern].new()
            }
            parse_macro_pattern(p, sub, vars)
            p.expect(")", true, true)
            continue;
        }
        if p.word_is("repeat") {
            p.tok(true, true)
            p.expect("(", false, false)
            let name = p.read_word(true, true)
            p.expect(",", true, true)
            let sub = Pattern {
                type: pat_repeat
                name: name
                parts: Array[Pattern].new()
            }
            let subvars = Array[String].new()
            parse_macro_pattern(p, sub, subvars)
            p.expect(",", true, true)
            t = p.tok(true, true)
            if t != tok_string : p.error("The last argument for repeat() must a be token between double-quotes. This token represent the end of the repeated pattern. Invalid token: '" + p.word() + "'")

            p.expect(")", true, true)
            continue;
        }
        break
    }
}