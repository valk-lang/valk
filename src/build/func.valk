
class Arg {
    name: String
    type: Type
    chunk_value: ?Chunk (null)
    decl: Decl
    generic_name: String ("")
    is_generic: bool (false)
}

type ERR_TYPE (u32)

class FuncInfo {
    args: Array[Type] (Array[Type].new())
    rett_types: Array[Type] (Array[Type].new())
    errors: Map[ERR_TYPE] (Map[ERR_TYPE].new())
    infinite_args: bool (false)
    can_error: bool (false)

    fn first_rett() Type !missing {
        return this.rett_types.get(0) ! throw missing
    }

    fn clone() FuncInfo {
        return FuncInfo {
            args: this.args.copy()
            rett_types: this.rett_types.copy()
            errors: this.errors.copy()
            infinite_args: this.infinite_args
            can_error: this.errors.length > 0
        }
    }

    fn to_closure_type(b: Build) Type {
        let clo_fi = this.clone()
        let new_args = Array[Type].new()
        each clo_fi.args as type, i {
            if i == 0 : continue
            new_args.append(type)
        }
        clo_fi.args = new_args
        return type_closure(b, clo_fi)
    }

    fn get_real_types(b: Build) Array[Type] {
        if !this.can_error : return this.rett_types
        let res = this.rett_types.copy()
        res.append(b.error_code_type())
        res.append(b.error_msg_type())
        return res
    }
}

class FuncAST {
    build: Build
    func: Func
    //
    scope: Scope
    scope_alloca: Scope
    scope_defer: Scope
    // Closures
    bind_data: Array[Decl] (Array[Decl]{}) $lazy
    // Buffers
    buffers_used: Array[Decl] (Array[Decl]{}) $lazy
    buffers_free: Array[Decl] (Array[Decl]{}) $lazy
    // Stack
    decl_nr: uint (0)
    gc_decl_count: uint (0)
    define_decls: Array[Decl] (.{})
    alloca_size: uint (0)
    stable_alloca_size: uint (0)
    cache_stack_adr: ?Value (null)
    cache_stable_adr: ?Value (null)
    stable_stack_decl: ?Decl (null)
    // Tests
    test_entry_decl: ?Decl (null)

    fn free_buffers(keep_count: uint) {
        let list = this.buffers_used
        let free_count = list.length - keep_count
        while free_count-- > 0 {
            let decl = list.pop_last() ! break
            this.buffers_free.append(decl)
        }
    }
    fn reuse_buffer(decl: Decl) bool {
        let list = this.buffers_free
        if list.contains(decl) {
            list.remove_value(decl)
            this.buffers_used.append(decl)
            return true
        }
        return false
    }
}

class Func {
    unit: Unit
    build: Build
    fc: Fc
    parse_fc: Fc
    name: String
    test_name: String ("-nameless-test-")
    export_name: String
    display_name: String
    act: int
    class: ?Class (null)
    group: ?Group (null)

    // Chunks
    def_chunk: ?Chunk (null)
    chunk_args: ?Chunk (null)
    chunk_rett: ?Chunk (null)
    chunk_body: ?Chunk (null)

    // Arg / Return types
    args: Array[Arg] (Array[Arg]{})
    rett: Type
    rett_real: Type
    errors: Map[u32] (Map[u32]{})
    arg_scope: Scope

    // Generics
    generic_names: ?Map[GenericName] (null)
    generic_arg_names: Array[String] (Array[String]{}) $lazy
    generic_types: Map[Type] (Map[Type]{}) $lazy
    generics: ?Map[Func] (null)

    // AST
    fast_: ?FuncAST (null)
    ir_code: String ("")
    coro_count: uint (0)

    // Track used
    functions_used: Array[Func] (Array[Func]{})
    globals_used: Array[Global] (Array[Global]{})
    strings: Array[Str] (Array[Str]{})
    classes_used: Array[Class] (Array[Class]{})
    declared_variables: Array[Decl] (Array[Decl]{})

    // Info
    info_creates_objects: bool (false)
    info_calls_unknown_code: bool (false)
    info_used: bool (false)
    info_checked: bool (false)
    ast_has_gc_decls: bool (false)
    disable_gc_stack: bool (false)

    // Bools
    is_exit: bool (false)
    is_static: bool (false)
    is_extern: bool (false)
    infinite_args: bool (false)
    inline: bool (false)
    is_entrance: bool (false)
    is_generic_base: bool (false)
    parsed_args: bool (false)
    parsed_ast: bool (false)
    can_error: bool (false)
    is_hot: bool (false)
    is_test: bool (false)
    skip_ast: bool (false)
    is_mut: bool (false)
    imut_mode: bool (false)
    is_getter: bool (false)
    no_buffers: bool (false)
    generic_args_defined: bool (false)
    has_generic_args: bool (false)
    gen_docs: bool (true)

    fn fast() FuncAST {
        return this.fast_ ?! this.build.error("Missing function AST object (bug)")
    }

    fn info() FuncInfo {
        return FuncInfo {
            args: this.arg_types()
            rett_types: this.rett.unroll()
            errors: this.errors
            infinite_args: this.infinite_args
            can_error: this.can_error
        }
    }
    fn arg_types() Array[Type] {
        let types = Array[Type]{}
        each this.args as arg {
            types.append(arg.type)
        }
        return types
    }

    fn add_arg(name: String, type: Type) Arg {
        let decl = Decl.new(type, true)
        decl.name = name
        let arg = Arg {
            name: name
            type: type
            decl: decl
        }
        this.args.append(arg)
        return arg
    }

    fn wipe_ast() {
        let fast = this.fast_
        if isset(fast) : this.declared_variables = fast.scope.decls
        this.fast_ = null
    }
    fn wipe_ir() {
        this.ir_code = ""
    }

    fn parse_args(p: Parser) {

        if !this.is_getter : p.skip_body(")")

        let t = p.tok(true, true, false)
        if !p.sign_is("{") && !p.sign_is("!") && !p.sign_is(";") && t != TOK.flag {
            this.chunk_rett = p.clone_chunk()
            p.skip_type()
        }

        t = p.tok(true, true, false)
        while p.sign_is("!") {
            t = p.tok(true, true)
            t = p.tok(false, false)
            if t != TOK.word : p.error("Invalid error name: " + p.word())
            t = p.tok(true, true, false)
        }

        while t == TOK.flag {
            t = p.tok(true, true)
            t = p.tok(true, true, false)
        }

        if !this.is_extern {
            p.expect("{", true, true)
            this.chunk_body = p.clone_chunk()
            p.skip_body("}")
        }
    }

    fn get_buffer(type: Type, scope: Scope) Decl {
        let ts = type.size()
        let tt = type.type
        let is_pointer = type.is_pointer()
        let fast = this.fast()
        each fast.buffers_free as decl, i {
            if decl.type.is_pointer() == is_pointer && decl.type.size() == ts && decl.type.type == tt {
                decl.type = type
                fast.buffers_free.remove(i)
                fast.buffers_used.append(decl)
                scope.add_decl(decl)
                return decl
            }
        }
        let decl = Decl.new(type, false)
        decl.is_used = true
        decl.is_mut = true
        decl.is_buffer = true
        fast.buffers_used.append(decl)
        scope.add_decl(decl)
        return decl
    }

    fn init_ast_scope() {
        let b = this.build

        // Create scopes
        let scope = Scope.new(SCOPE.func, b)
        scope.parent = this.arg_scope
        scope.func = this
        //
        let scope_alloca = scope.sub_scope(SCOPE.default)
        let scope_defer = scope.sub_scope(SCOPE.default)

        let fast = FuncAST {
            build: b
            func: this
            scope: scope
            scope_alloca: scope_alloca
            scope_defer: scope_defer
        }

        this.fast_ = fast

        //
        if this.rett.count_types() > 0 : scope.must_return = true

        // Argument variable identifiers
        each this.args as arg {
            fast.scope.set_idf_build(b, arg.name, Idf.for_decl(arg.decl))
            fast.scope.add_decl(arg.decl)
        }

        // Reset
        this.functions_used.clear()
        this.globals_used.clear()
        this.strings.clear()
        this.classes_used.clear()

        if this.is_test {
            test_init_scope(fast)
        }
    }

    fn finish_ast_scope() {
        this.parsed_ast = true
        func_calculate_alloca_size(this)
        func_generate_alloca_scope(this)
    }

    fn used_in(scope: Scope) {
        let scope_func = scope.get_func() ! this.build.error("Function call outside a function (bug)")
        scope_func.functions_used.append(this, true)
    }

    fn mark_used() {
        if this.info_used : return
        this.info_used = true
        this.unit.is_used = true

        each this.functions_used as subfunc {
            if subfunc.info_creates_objects : this.info_creates_objects = true
            if subfunc.info_calls_unknown_code : this.info_calls_unknown_code = true
            subfunc.mark_used()
        }
        each this.globals_used as g {
            g.mark_used()
        }
        each this.classes_used as class {
            class.mark_used()
        }
        each this.strings as str {
            if str.is_used : continue
            str.is_used = true
        }
    }
}


fn read_inline_func(p: Parser, decl_scope: Scope, imut_mode: bool) Value {
    let func = p.func()

    let chunk_args = p.clone_chunk()

    let u = func.unit
    let ifunc = u.new_func(func.fc, func.parse_fc, func.act, null, null, chunk_args)
    ifunc.arg_scope.parent = decl_scope
    ifunc.imut_mode = imut_mode

    ifunc.parse_args(p)
    parse_func_args(ifunc)

    if p.loop_first_parse {
        ifunc.is_extern = true
        let body = ifunc.chunk_body
        if !isset(body) : p.error("Missing inline function body (bug)")
        p.set_chunk(body)
        p.skip_body("}")
        return vgen_null_fake(type_func(ifunc))
    }

    parse_func_ast(ifunc)
    func_ir(ifunc)

    let ifast = ifunc.fast()
    let bind_data = ifast.bind_data

    ifunc.wipe_ast()
    func.functions_used.append(ifunc)
    func.info_calls_unknown_code = true

    // Check if we can return a function pointer
    if bind_data.length == 0 {
        return vgen_func_ptr(ifunc)
    }

    // Return a closure otherwise
    let bind_values = Array[Value].new()
    each bind_data as decl {
        bind_values.append(vgen_decl(decl))
    }

    return closure_init_value(p.ctx, ifunc, bind_values, decl_scope)
}


fn read_func_call_arg_values(
    p: Parser,
    scope: Scope,
    on: Value,
    end_sign: String,
    arg_values: Array[Value]
) {
    let func : ?Func = null
    let args : ?Array[Arg] = null
    if on.type == VAL.func_ptr : func = on.func
    if isset(func) : args = func.args

    let on_rett = on.rett
    let func_info = on_rett.func_info
    if !isset(func_info) : p.error("Function call on a non-function value")

    let arg_types = func_info.args
    let inf_arg_type : ?Type = null
    if func_info.infinite_args : inf_arg_type = arg_types.get(arg_types.length - 1) !? null
    
    let i = arg_values.length
    if p.lsp : p.build.getlsp().check_sig_help_func(i, arg_types, inf_arg_type, args, func_info)

    p.tok(true, true, false)
    if p.sign_is(end_sign) : p.tok(true, true)
    while !p.sign_is(end_sign) {

        let arg : ?Arg = null
        if isset(args) : arg = args.get(i) !? <{
            if isset(inf_arg_type) : return null
            p.error("Too many arguments. Function type: " + on_rett)
        }

        let arg_type = arg_types.get(i++) !? <{
            if isset(inf_arg_type) : return inf_arg_type
            // if isset(func) : println("Function: " + func.display_name)
            p.error("Too many arguments. Function type: " + on_rett)
        }

        if p.lsp : p.build.getlsp().check_sig_help_func(i - 1, arg_types, inf_arg_type, args, func_info)
        p.tok(true, true, false)
        if p.lsp : p.build.getlsp().check_sig_help_func(i - 1, arg_types, inf_arg_type, args, func_info)

        if p.word_is("_") {
            // Default value
            if !isset(func) : p.error("Func argument has no default value. So you cannot use '_' here.")
            // let arg = func.args.get(i - 1) !? null
            if !isset(arg) : p.error("Func argument has no default value. So you cannot use '_' here.")
            let chunk = arg.chunk_value
            if !isset(chunk) : p.error("Func argument has no default value. So you cannot use '_' here.")
            p.tok(true, true)
            let v = func_arg_read_default_value(p, scope, func, arg, chunk)
            arg_values.append(v)
            p.expect2(",", end_sign, true, true)
            continue
        }

        p.set_suggest(arg_type)
        let value = read_value(p, scope)
        p.pop_suggest()

        if isset(arg) && arg.is_generic {
            arg_values.append(value)
        } else {
            value = value.try_convert(p.ctx, scope, arg_type)
            arg_type.compat_check(value.rett, p)
            arg_values.append(value)
        }

        p.expect2(",", end_sign, true, true)
    }
}


fn func_arg_read_default_value(p: Parser, scope: Scope, func: Func, arg: Arg, chunk: Chunk) Value {
    let sub = scope.sub_scope(SCOPE.default)
    sub.parent_idf = func.arg_scope
    //
    let sp = p.new_sub_parser(chunk)
    sp.set_suggest(arg.type)
    let v = read_value(sp, sub)
    arg.type.compat_check(v.rett, p)
    return v
}
