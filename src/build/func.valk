
struct Func {
    unit: Unit
    build: Build
    fc: Fc
    export_name: String
    display_name: String
    act: int
    scope: Scope
    //
    chunk_args: Chunk
    chunk_rett: ?Chunk (null)
    chunk_body: ?Chunk (null)
    //
    args: Array[Arg] (array[Arg]{})
    rett: ?Type (null)
    errors: Map[u32] (map[u32]{})
    decls: Array[Decl] (array[Decl]{})
    //
    ir_code: String ("")
    //
    is_exit: bool (false)
    is_static: bool (false)
    from_header: bool (false)
    infinite_args: bool (false)
    parse_last: bool (false)
    inline: bool (false)

    fn info() FuncInfo {
        return FuncInfo {
            args: this.arg_types()
            rett: this.rett @as Type
            errors: this.errors
            infinite_args: this.infinite_args
        }
    }
    fn arg_types() Array[Type] {
        let types = array[Type]{}
        each this.args as arg {
            types.push(arg.type)
        }
        return types
    }

    fn wipe_ast() {
        this.scope.identifiers.clear()
        this.scope.ast.clear()
    }
    fn wipe_ir() {
        this.ir_code = ""
    }

    fn parse_args(p: Parser) {

        p.skip_body(")")

        let t = p.tok(true, true, false)
        if !p.sign_is("{") && !p.sign_is("!") && !p.sign_is(";") {
            this.chunk_rett = p.clone_chunk()
            p.skip_type()
        }

        t = p.tok(true, true, false)
        while p.sign_is("!") {
            t = p.tok(true, true)
            t = p.tok(false, false)
            if t != tok_word : p.error("Invalid error name: " + p.word())
        }

        if !this.fc.is_header {
            p.expect("{", true, true)
            this.chunk_body = p.clone_chunk()
            p.skip_body("}")
        }
    }

    fn eax_rett() Type {
        let rett = this.rett
        if !isset(rett) : return type_void(this.build)
        return rett.fit_eax() ? rett : type_void(this.build)
    }
}

struct Arg {
    name: String
    type: Type
    chunk_value: ?Chunk (null)
    decl: Decl
}
