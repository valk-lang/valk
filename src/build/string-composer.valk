
use valk:gc
use valk:mem

class StringComposerBlock {
    data: gc:GcPtr
    size: uint
    used: uint (0)
    next: ?StringComposerBlock (null)

    + static fn new(size: uint) SELF {
        if size < 128 : size = 128
        let data = gc:alloc(size)
        return SELF {
            data: data
            size: size
        }
    }

    get space_left : uint {
        return this.size - this.used
    }
}

+ class StringComposer {
    first: StringComposerBlock
    current: StringComposerBlock
    length: uint (0)

    + static fn new(start_size: uint (256)) SELF {
        let block = StringComposerBlock.new(start_size)
        return SELF {
            first: block
            current: block
        }
    }

    fn new_block() StringComposerBlock {
        let current = this.current
        let new = StringComposerBlock.new(current.size * 2)
        current.next = new
        this.current = new
        return new
    }

    + fn append(buffer: SELF) {
        let block : ?StringComposerBlock = buffer.first
        while isset(block) {
            this.append_from_ptr(block.data, block.used)
            block = block.next
        }
    }

    + fn append_from_ptr(data: ptr, length: uint) {
        if length == 0 : return
        let offset : uint = 0
        while true {
            let block = this.current
            let left = block.space_left
            if left > length : left = length
            if left > 0 : mem:copy(data.@offset(offset), block.data.@offset(block.used), left)
            block.used += left
            offset += left
            length -= left
            if length > 0 {
                this.new_block()
                continue
            }
            break
        }
        this.length += offset
    }

    + fn append_byte(byte: u8) {
        if this.current.space_left == 0 : this.new_block()
        @ptrv(this.current.data, u8, this.current.used++) = byte
        this.length++
    }

    + fn append_str(str: String) {
        this.append_from_ptr(str.data, str.bytes)
    }
    + fn append_uint(value: uint) {
        let buf : [u8 x 64] = { 0... }
        let ilen = value.to_base_to_ptr(10, buf)
        this.append_from_ptr(buf, ilen)
    }
    + fn append_int(value: int) {
        let buf : [u8 x 64] = { 0... }
        let ilen = value.to_base_to_ptr(10, buf)
        this.append_from_ptr(buf, ilen)
    }

    + fn to_string() String {
        if this.length == 0 : return ""
        let str = String.make_empty(this.length)
        let block : ?StringComposerBlock = this.first
        let offset : uint = 0
        while isset(block) {
            mem:copy(block.data, str.data.@offset(offset), block.used)
            offset += block.used
            block = block.next
        }
        return str
    }

    + fn clear() {
        this.current = this.first
        this.first.used = 0
        this.first.next = null
        this.length = 0
    }
}
