
struct Unit {
    build: Build
    functions: Array[Func] (array[Func]{})
    globals: Array[Global] (array[Global]{})
    classes: Array[Class] (array[Class]{})
    aliasses: Array[Alias] (array[Alias]{})
    path_o: String
    path_ir: String
    path_json: String

    fn new_func(fc: Fc, act: int, name: ?String, chunk_args: Chunk) Func !dupe {

        let nsc = fc.nsc
        let n = name ?? ("anon_func_" + this.build.gen_func_name++)

        let f = Func {
            unit: this
            build: this.build
            fc: fc
            export_name: nsc.export_name(n)
            display_name: isset(name) ? nsc.display_name(name) : "<anonymous-function>"
            act: act
            chunk_args: chunk_args
        }

        if !fc.is_header : this.functions.push(f)

        nsc.scope.identifiers.set_unique(n, Idf.for_func(f)) ! throw dupe

        return f
    }

    fn new_class(fc: Fc, act: int, name: ?String, type: int, chunk: Chunk) Class !dupe {

        let nsc = fc.nsc
        let n = name ?? ((type == ct_struct ? "anon_struct_" : "anon_class_") + this.build.gen_func_name++)

        let class = Class {
            unit: this
            build: this.build
            fc: fc
            export_name: nsc.export_name(n)
            display_name: isset(name) ? nsc.display_name(name) : (type == ct_struct ? "<anonymous-struct>" : "<anonymous-class>")
            act: act
            type: type
            chunk: chunk
        }

        if !fc.is_header : this.classes.push(class)

        nsc.scope.identifiers.set_unique(n, Idf.for_class(class)) ! throw dupe

        return class
    }

    fn new_global(fc: Fc, act: int, name: String, chunk_type: Chunk, chunk_value: ?Chunk) Global !dupe {

        let g = Global {
            unit: this
            build: this.build
            fc: fc
            act: act
            chunk_type: chunk_type
            chunk_value: chunk_value
        }

        if !fc.is_header : this.globals.push(g)

        return g
    }
}
