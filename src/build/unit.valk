
use valk:json
use valk:fs
use helper

class Unit {
    build: Build
    name: String
    functions: Array[Func] (Array[Func]{})
    globals: Array[Global] (Array[Global]{})
    classes: Array[Class] (Array[Class]{})
    links: Array[Link] (Array[Link]{})
    strings: Map[Str] (.{})
    path_o: String
    path_ir: String
    path_ir_prev: String
    path_json: String
    _json: ?json:Value (null)
    _ir: ?IR (null)
    changed: bool (true)
    string_count: uint (0)
    is_used: bool (false)

    static fn new(b: Build, name: String, hash: String) Unit {
        let base = helper:add(b.cache_dir, name + "_" + hash)
        let path_o = base + ".o"
        let path_ir = base + ".ir"
        let path_ir_prev = base + "-prev.ir"
        let path_json = base + ".json"

        let u = Unit {
            build: b
            name: name
            path_o: path_o
            path_ir: path_ir
            path_ir_prev: path_ir_prev
            path_json: path_json
        }

        b.units.append(u)

        return u
    }

    fn ir() IR {
        let ir = this._ir
        if !isset(ir) {
            let irr = IR.new(this)
            this._ir = irr
            return irr
        }
        return ir
    }

    fn json() ?json:Value {
        let js = this._json
        if isset(js) : return js
        let content = fs:read(this.path_json) ! return null
        js = json:decode(content) ! return null
        this._json = js
        return js
    }

    fn wipe() {
        each this.functions as func {
            func.wipe_ir()
        }
        this.functions.clear()
        this.classes.clear()
        this.globals.clear()
    }

    fn new_func(fc: Fc, parse_fc: Fc, act: int, name: ?String, generic_names: ?Map[GenericName], chunk_args: ?Chunk, extern: bool (false)) Func {

        let nsc : ?Nsc = null
        let arg_scope = Scope.new(SCOPE.default, this.build, null)
        nsc = fc.nsc
        arg_scope.parent = fc.scope

        let n = name ?? ("anon_func_" + this.build.gen_func_name++)
        let ename = n
        let dname = name ?? "<anonymous-function>"
        if !extern {
            ename = nsc.export_name(n)
            dname = nsc.display_name(n)
        }

        let tvoid = type_void(this.build)

        let f = Func {
            unit: this
            build: this.build
            fc: fc
            parse_fc: parse_fc
            name: n
            export_name: ename
            display_name: dname
            act: act
            arg_scope: arg_scope
            chunk_args: chunk_args
            is_extern: extern
            info_calls_unknown_code: extern
            generic_names: generic_names
            is_generic_base: isset(generic_names)
            rett: tvoid
            rett_real: tvoid
        }

        let lsp = this.build.lsp
        if isset(lsp) {
            f.skip_ast = true
            if lsp.file_content.has(fc.path) || lsp.file_content.has(parse_fc.path) : f.skip_ast = false
            // if isset(fc) && fc.path == lsp.file : f.skip_ast = false
        }

        if f.is_generic_base {
            f.generics = Map[Func]{}
            f.gen_docs = false
        } else {
            this.build.functions.append(f)
            this.functions.append(f)
            this.build.ast_pipeline.append(f)
        }

        return f
    }

    fn new_class(fc: Fc, act: int, name: ?String, type: int, generic_names: ?Map[GenericName], chunk: ?Chunk) Class {

        let scope : Scope = Scope.new(SCOPE.class, this.build, null)
        let nsc = fc.nsc
        scope.parent = fc.scope
        scope.func = fc.scope.func

        let n = name ?? ((type == CT.struct ? "anon_struct_" : "anon_class_") + this.build.gen_func_name++)
        let ename = n
        let dname = name ?? (type == CT.struct ? "<anonymous-struct>" : "<anonymous-class>")
        ename = nsc.export_name(n)
        if nsc.pkc != this.build.nsc_main().pkc && nsc.pkc.name != "valk" {
            dname = nsc.display_name(n)
        }

        let class = Class {
            unit: this
            build: this.build
            fc: fc
            name: n
            export_name: ename
            display_name: dname
            act: act
            type: type
            scope: scope
            chunk: chunk
            generic_names: generic_names
            is_generic_base: isset(generic_names)
        }

        this.build.classes.append(class)
        this.classes.append(class)

        if class.is_generic_base {
            class.generics = Map[Class]{}
            class.gen_docs = false
        }

        return class
    }

    fn new_global(fc: Fc, act: int, name: String, export_name: String, display_name: String, chunk_type: ?Chunk, chunk_value: ?Chunk, extern: bool (false)) Global {

        let g = Global {
            unit: this
            build: this.build
            fc: fc
            act: act
            name: name
            export_name: export_name
            display_name: display_name
            ir_name: "@" + export_name
            chunk_type: chunk_type
            chunk_value: chunk_value
            is_extern: extern
        }

        if !extern {
            this.globals.append(g)
        }

        this.build.globals.append(g)

        return g
    }

    fn new_string(body: String) Str {
        let str = this.strings.get(body) !? <{
            let s = Str {
                unit: this
                body: body
                nr: this.string_count++
            }
            this.strings.set(body, s)
            return s
        }
        return str
    }
}

