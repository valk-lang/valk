

class IRFunc {
    ir: IR
    func: Func
    blocks: Array[IRBlock] (Array[IRBlock]{})
    block_start: IRBlock
    block_code: IRBlock
    blockc: uint (0)

    static fn new(ir: IR, func: Func) IRFunc {
        let irf = IRFunc {
            ir: ir
            func: func
            block_start: IRBlock.new("start")
            block_code: IRBlock.new("code")
        }
        irf.blocks.append(irf.block_start)
        irf.blocks.append(irf.block_code)
        return irf
    }

    fn new_block(name: String) IRBlock {
        let block = IRBlock.new(name + "_" + this.blockc++)
        this.blocks.append(block)
        return block
    }

    fn last_block() IRBlock {
        return this.blocks.get(0) ! this.ir.build.error("Missing blocks in IRFunc (bug)")
    }

    fn build() {
        this.write_func_code()
        this.func.ir_code = this.final_ir()
        this.wipe()
    }

    fn write_func_code() {
        this.ir.set_func(this)
        ir_ast(this.ir, this.func.fast().scope)
    }

    fn final_ir() String {
        let buffer = StringComposer.new(1024)

        buffer.append_str("; Function: ")
        buffer.append_str(this.func.display_name)
        buffer.append_str("\n")

        let fc = this.func.fc
        buffer.append_str("; Location: ")
        buffer.append_str(fc.path)
        let body = this.func.chunk_body
        if isset(body) {
            buffer.append_str(" @ Line: ")
            buffer.append_uint(body.line)
        }
        buffer.append_str("\n")

        ir_write_func_definition(buffer, this.func, false)

        let blocks = this.blocks
        each blocks as block, i {
            if i == 1 {
                buffer.append_str("  br label %");
                buffer.append_str(block.name);
                buffer.append_str("\n");
            }
            buffer.append_str(block.name)
            buffer.append_str(":\n")
            buffer.append(block.code)
        }

        buffer.append_str("}\n\n")

        return buffer.to_string()
    }

    fn wipe() {
        this.blocks.clear()
        this.block_start = IRBlock.new("start")
        this.block_code = IRBlock.new("code")
    }

    fn alloca(size: uint) String {
        let var = this.ir.var()
        let code = this.block_start.code
        code.append_str("  ")
        code.append_str(var)
        code.append_str(" = alloca [")
        code.append_str(size)
        code.append_str(" x i8], align 8\n")
        return var
    }
}

fn ir_check_func_definition(ir: IR, func: Func) {

    if func.has_generic_args || func.is_generic_base : return
    if !func.info_used : return
    if (func.is_extern || func.unit != ir.unit) && !ir.extern_functions.contains(func) {

        let name = "@" + func.export_name
        if ir.defined_symbols.contains(name) : return
        ir.defined_symbols.append(name)

        ir_write_func_definition(ir.code_func_defs, func, true)
        ir.extern_functions.append(func)
    }
}

fn ir_write_func_definition(code: StringComposer, func: Func, extern: bool) {

    code.append_str(extern ? "declare " : "define dso_local ")
    code.append_str(ir_type(func.rett_real))
    code.append_str(" @")
    code.append_str(func.export_name)
    code.append_str("(")

    let count = 0

    // Args
    let args = func.args
    each args as arg, i {
        if count > 0 : code.append_str(", ")
        let decl = arg.decl
        let arg_name : ?String = null
        if !extern {
            if decl.is_arg && decl.is_mut : arg_name = decl.ir_name + "_init"
            else: arg_name = decl.ir_name
        }
        ir_func_arg(code, decl.type, arg_name)
        count++
    }

    // Infinite args
    if func.infinite_args {
        if count > 0 : code.append_str(", ")
        code.append_str("...")
    }

    if extern {
        code.append_str(")\n")
    } else {
        code.append_str(")")
        if func.inline {
            code.append_str(" alwaysinline")
        }
        if func.is_hot {
            code.append_str(" hot")
        }
        if !func.disable_gc_stack {
            code.append_str(" #0")
        }
        code.append_str(" {\n")
    }
}


fn ir_func_arg(code: StringComposer, type: Type, name: ?String) {
    code.append_str(ir_type(type))
    code.append_str(" noundef")
    if type.is_pointer() && !type.nullable : code.append_str(" nonnull")

    if isset(name) {
        code.append_str(" ")
        code.append_str(name)
    }
}
