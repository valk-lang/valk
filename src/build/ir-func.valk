
use valk:utils

struct IRFunc {
    ir: IR
    func: Func
    blocks: Array[IRBlock] (array[IRBlock]{})
    block_start: IRBlock
    block_code: IRBlock
    blockc: uint (0)

    static fn new(ir: IR, func: Func) IRFunc {
        let irf = IRFunc {
            ir: ir
            func: func
            block_start: IRBlock.new("start")
            block_code: IRBlock.new("code")
        }
        ir.functions.push(irf)
        irf.blocks.push(irf.block_start)
        irf.blocks.push(irf.block_code)
        return irf
    }

    fn new_block(name: String) IRBlock {
        let block = IRBlock.new(name + "_" + this.blockc++)
        this.blocks.push(block)
        return block
    }

    fn last_block() IRBlock {
        return this.blocks.get(0) ! this.ir.build.error("Missing blocks in IRFunc (bug)")
    }

    fn build() {
        this.write_func_code()
        this.func.ir_code = this.final_ir()
        this.wipe()
        println(this.func.ir_code)
    }

    fn write_func_code() {

        ir_write_func_definition(this.block_start.code, this.func, false)

        this.ir.set_func(this)
        ir_ast(this.ir, this.func.scope)

        this.ir.code().append_str("}\n")
    }

    fn final_ir() String {
        let buffer = utils:ByteBuffer.new(1024)
        let blocks = this.blocks
        each blocks as block {
            buffer.append(block.code)
        }
        return buffer.to_string()
    }

    fn wipe() {
        this.blocks.clear()
    }
}

fn ir_check_func_definition(ir: IR, func: Func) {
}

fn ir_write_func_definition(code: utils:ByteBuffer, func: Func, extern: bool) {

    code.append_str(extern ? "declare " : "define dso_local ")
    code.append_str(ir_type(func.rett_eax()))
    code.append_str(" @")
    code.append_str(func.export_name)
    code.append_str("(")

    let count = 0

    // This
    let arg_self = func.arg_self
    if isset(arg_self) {
        let decl = arg_self.decl
        ir_func_arg(code, decl.type, !extern ? decl.ir_name : null @as ?String)
        count++
    }

    // Args
    let args = func.args
    each args as i, arg {
        if count > 0 : code.append_str(", ")
        let decl = arg.decl
        ir_func_arg(code, decl.type, !extern ? decl.ir_name : null @as ?String)
        count++
    }

    // Multi return
    let rdecls = func.rett_decls
    each rdecls as i, decl {
        if count > 0 : code.append_str(", ")
        ir_func_arg(code, decl.type, !extern ? decl.ir_name : null @as ?String)
        count++
    }

    // Infinite args
    if func.infinite_args {
        if count > 0 : code.append_str(", ")
        code.append_str("...")
    }

    if extern {
        code.append_str(")\n")
    } else {
        code.append_str(")")
        if func.inline {
            code.append_str(" alwaysinline")
        }
        code.append_str(" {\n")
    }
}


fn ir_func_arg(code: utils:ByteBuffer, type: Type, name: ?String) {
    code.append_str(ir_type(type))
    code.append_str(" noundef")
    if type.is_pointer && !type.nullable : code.append_str(" nonnull")

    if isset(name) {
        code.append_str(" ")
        code.append_str(name)
    }
}
