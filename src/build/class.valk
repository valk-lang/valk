
struct Class {
    unit: Unit
    build: Build
    fc: Fc
    act: int
    name: String
    export_name: String
    display_name: String
    chunk: Chunk
    type: int
    _type: ?Type (null)
    scope: Scope
    //
    size: uint (0)
    props: Map[Prop] (map[Prop]{})
    funcs: Map[Func] (map[Func]{})
    pool_index: uint (0)
    gc_prop_count: uint (0)
    vtable: ?Global (null)
    //
    generic_names: ?Array[String] (null)
    generics: ?Map[Class] (null)
    //
    is_signed: bool (false)
    size_known: bool (false)
    is_generic_base: bool (false)
    parsed_props: bool (false)
    packed: bool (false)

    fn get_type() Type {
        let t = this._type
        if !isset(t) {
            // Create type
            let b = this.build
            let ct = this.type
            let tt = ty_class
            if ct == ct_class : tt = ty_class
            else if ct == ct_struct : tt = ty_struct
            else if ct == ct_int : tt = ty_int
            else if ct == ct_float : tt = ty_float
            else if ct == ct_pointer : tt = ty_ptr
            else if ct == ct_bool : tt = ty_bool
            else : b.error("Unknown type in function Class.get_type() (compiler bug)")
            let is_pointer = ct == ct_class || ct == ct_struct || ct == ct_pointer
            let n = Type {
                type: tt
                build: b
                class: this
                is_signed: this.is_signed
                is_pointer: is_pointer
            }
            this._type = n
            return n
        }
        return t
    }

    fn determine_size() !unable {
        let ct = this.type
        if this.size > 0 {
            this.size_known = true
            return 
        }

        let b = this.build

        // Check if vtable needs to be added
        if this.funcs.has("_gc_mark") || this.funcs.has("_gc_unmark") || this.funcs.has("_gc_free") {
            let name = this.name + "_VTABLE";
            let dname = this.display_name + "_VTABLE";
            let ename = this.export_name + "_VTABLE";
            let u = this.build.generic_unit()
            let vt = u.new_global(null, act_private_fc, name, ename, dname, null, null)

            let type_ptr = type_ptr(b)
            vt.type = type_ptr
            vt.shared = true

            let v = Value{ type: v_static_array, values: array[Value]{}, rett: type_ptr }
            let vv = v.values
            if isset(vv) {
                let f1 = this.funcs.get("_gc_mark") ? null
                let f2 = this.funcs.get("_gc_unmark") ? null
                let f3 = this.funcs.get("_gc_free") ? null
                vv.push(isset(f1) ? vgen_func_ptr(f1) : vgen_null(type_ptr))
                vv.push(isset(f2) ? vgen_func_ptr(f2) : vgen_null(type_ptr))
                vv.push(isset(f3) ? vgen_func_ptr(f3) : vgen_null(type_ptr))
            }
            vt.default_value = v

            this.vtable = vt
        }
        let vtable = this.vtable
        if isset(vtable) {
            let name = "_VTABLE"
            let prop = Prop {
                name: name
                type: type_ptr(b)
                class: this
                act: act_private_fc
                index: this.props.length()
            }
            if this.funcs.has(name) : b.error("Property name is already used for a function: " + name)
            this.props.set_unique(name, prop) ! b.error("Duplicate property name: " + name)
        }

        //
        let props = this.props

        // Resort properties
        let gc_prop_count : uint = 0
        let props_new = map[Prop]{}
        each props as name, prop {
            if prop.type.is_gc() {
                props_new.set(name, prop)
                gc_prop_count++
            }
        }
        if props_new.length() > 0 {
            each props as name, prop {
                if !prop.type.is_gc() {
                    props_new.set(name, prop)
                }
            }
            props = props_new
        }
        this.gc_prop_count = gc_prop_count

        // Calculate size
        let size : uint = 0
        each props as name, prop {
            let prop_size = prop.type.size()
            if prop_size == 0 : throw unable
            if !this.packed : size += size % prop_size
            size += prop_size
        }

        // Round off
        let ptr_size = this.build.ptr_size
        if size % ptr_size != 0 {
            size += ptr_size - (size % ptr_size)
        }

        if b.verbose >= 0 : b.log("> Determine class size: " + this.display_name + " | size: " + size)

        this.size = size
        this.size_known = true

        // Determine pool index
        if size <= 16 * ptr_size {
            let i : uint = size / ptr_size - 1
            this.pool_index = i
        } else {
            let cmp = 16 * ptr_size * 2
            let i : uint = 16
            while size > cmp {
                cmp *= 2
                i++
            }
            this.pool_index = i
        }
    }

    fn determine_prop_offsets() {
        let offset : int = 0
        let props = this.props
        each props as name, prop {
            let ps = prop.type.size() @as int
            let skip = this.packed ? 0 : (offset % ps)
            prop.offset = offset + skip
            offset += skip + ps
        }
    }

    fn is_structural() bool {
        return this.type == ct_struct || this.type == ct_class
    }
}

struct Prop {
    name: String
    type: Type
    class: Class
    act: int
    index: uint
    offset: int (0)
    chunk: ?Chunk (null)
}
