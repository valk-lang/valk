
header "llvm" as llvm

use helper
use valk:fs

fn stage_object(u: Unit) {

    let b = u.build
    if b.verbose > 2 : b.log("> Stage 3.4: Generating object file: " + u.path_o)

    // Get full ir
    let ir = u.ir()
    let code = ir.final_code()
    let hash = helper:ctxhash(code)

    // Check if hash changed
    let prev_hash = ""
    let json = u.json()
    if isset(json) {
        let h = json.get("hash") ? null
        if isset(h) {
            prev_hash = h.string() ? ""
        }
    }

    println(hash + " vs " + prev_hash)

    if hash != prev_hash {
        // Hash changed, update object file
        fs:write(u.path_ir, code) ! b.error("Failed to write IR to file: " + u.path_ir)
        build_object(u)
    }
}

fn build_object(u: Unit) {

    let b = u.build
    let ctx = llvm:LLVMContextCreate()
    llvm:LLVMContextSetOpaquePointers(ctx, true)

    let mod = llvm:LLVMModuleCreateWithNameInContext("valk_module".data_ptr(), ctx);

    let msg: ?cstring = null
    let buf: ?llvm:LLVMMemoryBufferRef = null
    llvm:LLVMCreateMemoryBufferWithContentsOfFile(u.path_ir.data_ptr(), @ptr_of(buf), @ptr_of(msg))
    if isset(msg) {
        b.error("LLVM parse error:\n" + msg)
    }

    if !isset(buf) : b.error("LLVM failed to load IR content")
    llvm:LLVMParseIRInContext(ctx, buf, @ptr_of(mod), @ptr_of(msg));
    if isset(msg) {
        b.error("LLVM parse error:\n" + msg)
    }

    if !llvm:LLVMVerifyModule(mod, llvm:LLVMReturnStatusAction, @ptr_of(msg)) && isset(msg) {
        b.error("LLVM verify error:\n" + msg)
    }

//     // Compile
//     error = NULL;
//     LLVMSetTarget(nsc_mod, data->triple);
//     LLVMSetDataLayout(nsc_mod, data->data_layout);

//     if (b->optimize) {
//         if (b->verbose > 2)
//             printf("LLVM optimize: %s\n", path_o);
//         stage_5_optimize(nsc_mod);
//     }

//     if(b->verbose > 2)
//         printf("LLVM write: %s\n", path_o);
//     if (LLVMTargetMachineEmitToFile(data->target_machine, nsc_mod, path_o, LLVMObjectFile, &error) != 0) {
//         fprintf(stderr, "Failed to emit machine code!\n");
//         fprintf(stderr, "Error: %s\n", error);
//         LLVMDisposeMessage(error);
//         exit(1);
//     }

//     size_t mem = get_mem_usage();
//     if (mem > b->mem_objects)
//         b->mem_objects = mem;
//     // printf("Object created: %s\n", outpath);
//     LLVMDisposeMessage(error);
//     LLVMDisposeModule(nsc_mod);
//     LLVMContextDispose(ctx);

// #ifndef WIN32
//     pthread_exit(NULL);
// #endif
//     return NULL;
}

