
class Allocator {
    g: Global
    size: uint
    props: ?Func
    onfree: ?Func

    static fn get_allocator(ctx: Context, type: Type) SELF {
        //
        type = type.get_inline()
        let size = type.size()
        if size == 0 : ctx.error("Unknown type size: " + type)
        let _, psize = ctx.build.get_pool_index(size)
        //
        let func_props : ?Func = null
        let func_onfree : ?Func = null
        if type.type == TYPE.class {
            let class = type.class
            if isset(class) {
                func_props = SELF.get_struct_props_func(class)
                func_onfree = class.get_func("gc_free") !? null
                ctx.uses_class(class)
            }
        }

        if isset(func_props) : ctx.uses_func(func_props)
        if isset(func_onfree) : ctx.uses_func(func_onfree)

        //
        let sig = "ALC_" + psize + "__" + (isset(func_props) ? func_props.export_name : "null") + "__" + (isset(func_onfree) ? func_onfree.export_name : "null")
        ctx.build.allocators.get(sig) -> alc {
            ctx.uses_global(alc.g)
            return alc
        }

        let u = ctx.build.generated_unit()
        let fc = ctx.build.generated_fc()
        let g = u.new_global(fc, act_default, sig, sig, sig, null, null, false)
        g.type = ctx.build.valk_type("gc", "Pool")
        g.shared = false
        ctx.uses_global(g)
        let alc = Allocator {
            g: g
            size: psize
            props: func_props
            onfree: func_onfree
        }
        ctx.build.allocators.set(sig, alc)
        return alc
    }

    static fn get_struct_props_func(class: Class) ?Func {
        let f = class._props_func
        if isset(f) : return f
        let _props = class.funcs.get("_props") !? null
        let props  = class.props
        let has_gc_props = false
        each props as prop, name {
            if prop.type.is_gc() {
                has_gc_props = true
                break
            }
        }
        if !has_gc_props {
            if isset(_props) : return _props
            return null
        }

        // Generate function
        let b = class.build
        let scope = Scope.new(SCOPE.default, b, null)
        let ctx = Context{ build: b }

        // Identifiers
        let lifo_type = b.valk_type("gc", "Lifo")
        let idf = Idf.for_type(lifo_type)
        scope.set_idf(ctx, "LIFO_TYPE", idf)
        idf = Idf.for_type(class.get_type())
        scope.set_idf(ctx, "CLASS_TYPE", idf)


        // Code
        let code = StringComposer.new(4096)
        code.append_str("item: ptr, list: LIFO_TYPE) {\n")
            // code.append_str("print(\"%{ this.display_name }\n\")\n")

        // Loop props
        each props as prop, name, i {
            if !prop.type.is_gc() : continue
            code.append_str("list.add(item.@offset(")
            code.append_uint(prop.offset)
            code.append_str("))\n")
        }

        if isset(_props) {
            idf = Idf.for_func(_props)
            scope.set_idf(ctx, "_PROPS", idf)
            code.append_str("_PROPS(item.@cast(CLASS_TYPE), list)\n")
        }

        // Func end
        code.append_str("}\n")

        // Parse
        let content = code.to_string()
        let chunk = Chunk.new(b, content, class.fc)
        let sp = Parser.new(chunk, null)

        // let fc = b.generated_fc()
        f = class.unit.new_func(class.fc, class.fc, act_default, class.name + ".LIST_PROPS", null, chunk, false)
        f.arg_scope.parent = scope
        f.disable_gc_stack = true
        scope.func = f

        //
        sp.ctx.func = f
        f.parse_args(sp)
        parse_func_args(f)
        code.clear()

        class._props_func = f
        return f
    }
}