
use valk:mem

struct Parser {
    chunk: Chunk
    build: Build
    parent: ?Parser (null)
    // Content
    data: ptr
    len: uint
    i: uint
    line: uint
    col: uint
    // Result
    word_adr: ptr (null @as ptr)
    word_len: uint (0)
    last_tok: int (0)
    last_char: u8 (0)
    // Bools
    on_newline: bool (true)

    fn tok(allow_space: bool, allow_newline: bool, update: bool (true)) int {
        // Backup
        let i = this.i
        let line = this.line
        let col = this.col
        let word_start = i
        //
        let t = tok_end
        let word_len: uint = 0
        let word_end_offset: uint = 0
        // Chunk
        let chunk = this.chunk
        let len = this.len
        let data = this.data
        let on_newline = false
        let is_word = false
        let is_number = false

        while true {
            // Detect end of file
            if this.i >= len {
                t = tok_end
                break
            }

            // Get byte
            let ch = @ptrv(data, u8, this.i++)
            this.col++

            // Invalid
            if ch > 126 {
                this.error("Parse error, unsupported character/byte: " + ch)
            }
            
            // Ignore chars
            if ch < 33 {
                if ch == ' ' || ch == '\r' || ch == '\t' {
                    if !allow_space {
                        this.i--
                        this.col--
                        t = tok_none
                        break
                    }
                    continue
                }
                if ch == '\n' {
                    if !allow_space || !allow_newline {
                        this.i--
                        this.col--
                        t = tok_none
                        break
                    }
                    on_newline = true
                    this.line++
                    this.col = 1
                    continue
                }
                this.error("Parse error, unsupported character/byte: " + ch)
            }

            // Comment
            if ch == '/' && @ptrv(data, u8, this.i) == '/' {
                // Skip
                while this.i < len {
                    if @ptrv(data, u8, this.i++) == '\n' : break
                }
                on_newline = true
                this.line++
                this.col = 1
                continue
            }

            word_start = this.i - 1

            // Word
            if ch.is_alpha() || ch == '_' || ch == '@' {
                this.skip_word()
                t = ch == '@' ? tok_at_word : tok_word
                break
            }

            // Number
            if ch.is_number() {
                t = this.skip_number()
                break
            }

            // String
            if ch == '\"' {
                this.skip_string()
                t = tok_string
                word_start++
                word_end_offset = 1
                break
            }

            // Char
            if ch == '\'' {
                ch = @ptrv(data, u8, this.i++)
                this.col++
                if ch == '\'' {
                    this.error("Missing character between single quotes")
                }
                if ch == '\\' {
                    ch = @ptrv(data, u8, this.i++)
                    this.col++
                }
                if ch == 0 {
                    this.error("Unexpected end of file")
                }
                this.last_char = ch
                t = tok_char
                ch = @ptrv(data, u8, this.i++)
                if ch != '\'' {
                    this.error("Missing single quote, found: '" + ch.to_ascii_string() + "'")
                }
                word_start++
                word_end_offset = 1
                break
            }

            // Signs
            let next = @ptrv(data, u8, this.i)
            if ch == '<' && (next == '{' || next == '<' || next == '=') {
                this.i++
                this.col++
            } else if ch == '>' && (next == '>' || next == '=') {
                this.i++
                this.col++
            } else if ch == '=' && (next == '=') {
                this.i++
                this.col++
            } else if ch == '!' && (next == '=') {
                this.i++
                this.col++
            } else if ch == '+' && (next == '=' || next == '+') {
                this.i++
                this.col++
            } else if ch == '-' && (next == '=' || next == '-') {
                this.i++
                this.col++
            } else if ch == '%' && (next == '=') {
                this.i++
                this.col++
            } else if ch == '*' && (next == '=') {
                this.i++
                this.col++
            } else if ch == '/' && (next == '=') {
                this.i++
                this.col++
            } else if ch == '?' && (next == '?') {
                this.i++
                this.col++
            }

            // Sign
            t = tok_sign
            break
        }

        this.word_adr = data + word_start
        this.word_len = this.i - word_start - word_end_offset
        this.last_tok = t

        this.on_newline = on_newline
        if !update {
            this.i = i
            this.line = line
            this.col = col
        }

        return t
    }

    fn next_if(ch: u8) bool {
        if @ptrv(this.data, u8, this.i) == ch {
            this.i++
            if ch == '\n' {
                this.line++
                this.col = 1
            } else {
                this.col++
            }
            return true
        }
        return false
    }

    fn clone_chunk() Chunk {
        let chunk = this.chunk
        return Chunk {
            build: chunk.build
            fc: chunk.fc
            content: chunk.content
            i: chunk.i
            line: chunk.line
            col: chunk.col
        }
    }

    static fn new(chunk: Chunk, parent: ?Parser) Parser {
        return Parser{
            chunk: chunk
            build: chunk.build
            parent: parent
            data: chunk.content.data_ptr()
            len: chunk.content.bytes
            i: chunk.i
            line: chunk.line
            col: chunk.col
        }
    }

    fn new_sub_parser(chunk: Chunk) Parser {
        return Parser.new(chunk, this)
    }

    fn skip_word() {
        let len = this.len
        let data = this.data

        while this.i < len {
            let ch = @ptrv(data, u8, this.i++)
            this.col++
            if !ch.is_alpha_numeric() && ch != '_' {
                this.i--
                this.col--
                break
            }
        }
    }
    fn skip_number() int {
        let len = this.len
        let data = this.data
        let first = true
        let t = tok_int
        let prev_ch = @ptrv(data, u8, this.i - 1)

        while this.i < len {
            let ch = @ptrv(data, u8, this.i++)
            this.col++
            if first && prev_ch == '0' {
                first = false
                if ch == 'x' {
                    t = tok_hex
                    continue
                }
                if ch == 'c' {
                    t = tok_octal
                    continue
                }
            }
            if t == tok_hex {
                if !ch.is_hex() {
                    this.i--
                    this.col--
                    break
                }
            } else if t == tok_octal {
                if !ch.is_octal() {
                    this.i--
                    this.col--
                    break
                }
            } else if t == tok_int {
                if ch == '.' {
                    t = tok_float
                    continue
                }
                if !ch.is_number() {
                    this.i--
                    this.col--
                    break
                }
            } else if t == tok_float {
                if !ch.is_number() {
                    this.i--
                    this.col--
                    break
                }
            }
        }
        return t
    }
    fn skip_string() {
        let len = this.len
        let data = this.data

        while this.i < len {
            let ch = @ptrv(data, u8, this.i++)
            this.col++
            if ch == '\\' {
                this.i++
                this.col++
                continue
            }
            if ch == '"' {
                break
            }
        }
    }

    fn skip_type() {
        let t = this.tok(true, true)

        if this.word_is("(") { this.skip_body(")"); return }
        else if this.word_is("<{") || this.word_is("{") { this.skip_body("}"); return }
        else if this.word_is("[") { this.skip_body("]"); return }

        // TODO
    }
    fn skip_body(close_sign: String) {
        let depth = 1
        let scope_ends = array[String]{}
        scope_ends.push(close_sign)
        while true {
            let t = this.tok(true, true)
            if t == tok_end : break
            if this.word_is("(") || this.word_is("{") || this.word_is("<{") || this.word_is("[") {
                depth++
                if this.word_is("(") : scope_ends.push(")")
                else if this.word_is("<{") || this.word_is("{") : scope_ends.push("}")
                else if this.word_is("[") : scope_ends.push("]")
                continue
            }
            if this.word_is(")") || this.word_is("}") || this.word_is("]") {
                depth--
                let expect = scope_ends.pop() ? "???"
                if !this.word_is(expect) {
                    this.error("Incorrect scope ending. Expected '" + expect + "', Found: '" + this.word() + "'")
                }
                if depth == 0 : break
                continue
            }
        }
        if depth != 0 {
            this.error("Missing scope closing character, expected to find: '" + close_sign + "'")
        }
    }

    fn word() String {
        return String.make_from_ptr(this.word_adr, this.word_len)
    }
    fn word_is(word: String) bool {
        if this.word_len != word.bytes : return false
        return mem:equal(this.word_adr, word.data_ptr(), word.bytes)
    }
    fn sign_is(sign: String) bool {
        if this.last_tok != tok_sign : return false
        return this.word_is(sign)
    }
    fn read_word(allow_space: bool, allow_newline: bool) String {
        let t = this.tok(allow_space, allow_newline)
        if t != tok_word : this.error("Invalid identifier name: '" + this.word() + "'")
        return this.word()
    }

    // Expects
    fn expect(word: String, allow_space: bool, allow_newline: bool) {
        let t = this.tok(allow_space, allow_newline)
        if !Parser.tok_has_word(t) : this.error("Expected token: '" + word + "'")
        let w = this.word()
        if w != word : this.error("Expected token: '" + word + "', instead of: '" + w + "'")
    }
    fn expect_string(allow_space: bool, allow_newline: bool) {
        let t = this.tok(allow_space, allow_newline)
        if t != tok_string : this.error("Expected a string between doubles quotes, found: '" + this.word() + "'")
    }

    // Misc
    static fn tok_has_word(tok: int) bool {
        return tok == tok_word || tok == tok_int || tok == tok_float || tok == tok_hex || tok == tok_octal || tok == tok_sign
    }

    fn tok_to_str(tok: int) String {
        if Parser.tok_has_word(tok) : return this.word()
        return "(token: " + tok + ")"
    }

    // Error handler
    exit_fn error(msg: String) {

        let chunk = this.chunk
        let content = chunk.content
        let data = this.data
        let len = this.len

        this.i--
        this.col--

        println("------------------------------------")
        println("# Parser error")
        println("# Line: " + this.line + " | Col: " + this.col)
        println("# Error: " + msg)

        let i = this.i
        let starti = i
        let endi = i
        while starti > 0 && @ptrv(data, u8, starti - 1) != '\n' {
            starti--
        }
        while endi < len && @ptrv(data, u8, endi + 1) != '\n' {
            endi++
        }

        let before_len = i - starti
        if before_len > 15 {
            starti = i - 15
            before_len = 15
        }
        let after_len = 34 - before_len

        let line_len = endi - starti + 1
        let line = String.make_from_ptr(data + starti, line_len)
        println("------------------------------------")
        println(line)

        let c : uint = before_len
        while c-- > 1 {
            print("-")
        }
        if before_len > 0 : print(" ")
        print("^ ")
        c = after_len
        while c-- > 0 {
            print("-")
        }
        print("\n")

        exit(1)
    }
}
