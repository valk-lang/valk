
struct Parser {
    chunk: Chunk
    parent: ?Parser (null)
    // Content
    data: ptr
    len: uint
    i: uint
    line: uint
    col: uint
    // Word
    word_adr: ptr (null @as ptr)
    word_len: uint (0)
    char: u8 (0)
    // Scope ends
    scope_ends: Array[u8] (array[u8]{})
    // Bools
    on_newline: bool (true)

    fn tok(allow_space: bool, allow_newline: bool, update: bool (true)) int {
        // Backup
        let i = this.i
        let line = this.line
        let col = this.col
        //
        let t = tok_end
        let word_len: uint = 0
        // Chunk
        let chunk = this.chunk
        let len = this.len
        let data = this.data
        let on_newline = false
        let is_word = false
        let is_number = false

        while this.i < len {
            let ch = @ptrv(data, u8, this.i++)
            this.col++

            // Invalid
            if ch > 126 {
                this.error("Parse error, unsupported character/byte: " + ch)
            }
            
            // Ignore chars
            if ch < 33 {
                if ch == ' ' || ch == '\r' || ch == '\t' {
                    if !allow_space {
                        this.i--
                        this.col--
                        t = tok_none
                        break
                    }
                    continue
                }
                if ch == '\n' {
                    if !allow_space || !allow_newline {
                        this.i--
                        this.col--
                        t = tok_none
                        break
                    }
                    on_newline = true
                    this.line++
                    this.col = 1
                    continue
                }
                this.error("Parse error, unsupported character/byte: " + ch)
            }

            // Comment
            if ch == '/' && @ptrv(data, u8, this.i) == '/' {
                // Skip
                while this.i < len {
                    if @ptrv(data, u8, this.i++) == '\n' : break
                }
                on_newline = true
                this.line++
                this.col = 1
                continue
            }

            // Word
            if ch.is_alpha() || ch == '_' {
                let start = this.i - 1
                this.word_adr = data + start
                this.skip_word()
                this.word_len = this.i - start
                t = tok_word
                break
            }

            // Number
            if ch.is_number() {

            }

            // String
            if ch == '\"' {
                let start = this.i - 1
                this.word_adr = data + start
                this.skip_string()
                this.word_len = this.i - start
                t = tok_string
                break
            }

            // Char
            if ch == '\'' {
                ch = @ptrv(data, u8, this.i++)
                this.col++
                if ch == '\'' {
                    this.error("Missing character between single quotes")
                }
                if ch == '\\' {
                    ch = @ptrv(data, u8, this.i++)
                    this.col++
                }
                if ch == 0 {
                    this.error("Unexpected end of file")
                }
                this.char = ch
                t = tok_char
                ch = @ptrv(data, u8, this.i++)
                if ch != '\'' {
                    this.error("Missing single quote, found: '" + ch.to_ascii_string() + "'")
                }
                break
            }

            // Brackets
            if ch == '(' {
                if update : this.scope_ends.push(')')
                t = tok_bracket_open
                break
            }
            if ch == '[' {
                if update : this.scope_ends.push(']')
                t = tok_sq_bracket_open
                break
            }
            if ch == '{' {
                if update : this.scope_ends.push('}')
                t = tok_curly_open
                break
            }
            if ch == '<' && @ptrv(data, u8, this.i) == '{' {
                this.i++
                if update : this.scope_ends.push('}')
                t = tok_ltcurly_open
                break
            }
            if ch == ')' {
                let ch_close = this.scope_ends.pop() ! this.error("Unexpected closing bracket: ')'")
                if ch != ch_close : this.error("Incorrect closing character: found ')', but expected '" + ch_close.to_ascii_string() + "'")
                t = tok_bracket_close
                break
            }
            if ch == ']' {
                let ch_close = this.scope_ends.pop() ! this.error("Unexpected closing bracket: ']'")
                if ch != ch_close : this.error("Incorrect closing character: found ']', but expected '" + ch_close.to_ascii_string() + "'")
                t = tok_sq_bracket_close
                break
            }
            if ch == '}' {
                let ch_close = this.scope_ends.pop() ! this.error("Unexpected closing bracket: '}'")
                if ch != ch_close : this.error("Incorrect closing character: found '}', but expected '" + ch_close.to_ascii_string() + "'")
                t = tok_curly_close
                break
            }

            // Sign

            //
            this.error("Parse error, unexpected byte: " + ch)
        }

        this.on_newline = on_newline
        if !update {
            this.i = i
            this.line = line
            this.col = col
        }

        return t
    }

    fn next_if(ch: u8) bool {
        if @ptrv(this.data, u8, this.i) == ch {
            this.i++
            if ch == '\n' {
                this.line++
                this.col = 1
            } else {
                this.col++
            }
            return true
        }
        return false
    }

    fn clone_chunk() Chunk {
        let chunk = this.chunk
        return Chunk {
            fc: chunk.fc
            content: chunk.content
            i: chunk.i
            line: chunk.line
            col: chunk.col
        }
    }

    static fn create(chunk: Chunk, parent: ?Parser) Parser {
        return Parser{
            chunk: chunk
            parent: parent
            data: chunk.content.data_ptr()
            len: chunk.content.bytes
            i: chunk.i
            line: chunk.line
            col: chunk.col
        }
    }

    fn create_sub_parser(chunk: Chunk) Parser {
        return Parser.create(chunk, this)
    }

    fn skip_word() {
        let len = this.len
        let data = this.data

        while this.i < len {
            let ch = @ptrv(data, u8, this.i++)
            this.col++
            if !ch.is_alpha() && ch != '_' {
                this.i--
                this.col--
                break
            }
        }
    }
    fn skip_string() {
        let len = this.len
        let data = this.data

        while this.i < len {
            let ch = @ptrv(data, u8, this.i++)
            this.col++
            if ch == '\\' {
                this.i++
                this.col++
                continue
            }
            if ch == '"' {
                break
            }
        }
    }
    fn skip_func_args() {
    }
    fn skip_func_body() {
    }

    exit_fn error(msg: String) {
        println("# Line: " + this.line + " | Col: " + this.col)
        println("# Error: " + msg)
        exit(1)
    }

    fn check_scope_end() {
        if this.scope_ends.length > 0 {
            let end_tok = this.scope_ends.pop() ! return
            this.error("Missing scope ending: '" + end_tok.to_ascii_string() + "'")
        }
    }

    static fn tok_to_str(tok: int) String {
        if tok == tok_bracket_close : return ")"
        if tok == tok_sq_bracket_close : return "]"
        if tok == tok_curly_close : return "}"
        return ""
    }
}
