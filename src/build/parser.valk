
use valk:mem

struct Parser {
    chunk: Chunk
    parent: ?Parser (null)
    // Content
    data: ptr
    len: uint
    i: uint
    line: uint
    col: uint
    // Word
    word_adr: ptr (null @as ptr)
    word_len: uint (0)
    char: u8 (0)
    // Scope ends
    scope_ends: Array[u8] (array[u8]{})
    // Bools
    on_newline: bool (true)

    fn tok(allow_space: bool, allow_newline: bool, update: bool (true)) int {
        // Backup
        let i = this.i
        let line = this.line
        let col = this.col
        //
        let t = tok_end
        let word_len: uint = 0
        // Chunk
        let chunk = this.chunk
        let len = this.len
        let data = this.data
        let on_newline = false
        let is_word = false
        let is_number = false

        while true {
            // Detect end of file
            if this.i >= len {
                t = tok_end
                break
            }

            // Get byte
            let ch = @ptrv(data, u8, this.i++)
            this.col++

            // Invalid
            if ch > 126 {
                this.error("Parse error, unsupported character/byte: " + ch)
            }
            
            // Ignore chars
            if ch < 33 {
                if ch == ' ' || ch == '\r' || ch == '\t' {
                    if !allow_space {
                        this.i--
                        this.col--
                        t = tok_none
                        break
                    }
                    continue
                }
                if ch == '\n' {
                    if !allow_space || !allow_newline {
                        this.i--
                        this.col--
                        t = tok_none
                        break
                    }
                    on_newline = true
                    this.line++
                    this.col = 1
                    continue
                }
                this.error("Parse error, unsupported character/byte: " + ch)
            }

            // Comment
            if ch == '/' && @ptrv(data, u8, this.i) == '/' {
                // Skip
                while this.i < len {
                    if @ptrv(data, u8, this.i++) == '\n' : break
                }
                on_newline = true
                this.line++
                this.col = 1
                continue
            }

            // Word
            if ch.is_alpha() || ch == '_' {
                let start = this.i - 1
                this.word_adr = data + start
                this.skip_word()
                this.word_len = this.i - start
                t = tok_word
                break
            }

            // Number
            if ch.is_number() {
                let start = this.i - 1
                this.word_adr = data + start
                t = this.skip_number()
                this.word_len = this.i - start
                break
            }

            // String
            if ch == '\"' {
                let start = this.i - 1
                this.word_adr = data + start
                this.skip_string()
                this.word_len = this.i - start
                t = tok_string
                break
            }

            // Char
            if ch == '\'' {
                ch = @ptrv(data, u8, this.i++)
                this.col++
                if ch == '\'' {
                    this.error("Missing character between single quotes")
                }
                if ch == '\\' {
                    ch = @ptrv(data, u8, this.i++)
                    this.col++
                }
                if ch == 0 {
                    this.error("Unexpected end of file")
                }
                this.char = ch
                t = tok_char
                ch = @ptrv(data, u8, this.i++)
                if ch != '\'' {
                    this.error("Missing single quote, found: '" + ch.to_ascii_string() + "'")
                }
                break
            }

            // Brackets
            if ch == '(' {
                if update : this.scope_ends.push(')')
                t = tok_bracket_open
                break
            }
            if ch == '[' {
                if update : this.scope_ends.push(']')
                t = tok_sq_bracket_open
                break
            }
            if ch == '{' {
                if update : this.scope_ends.push('}')
                t = tok_curly_open
                break
            }
            if ch == '<' && @ptrv(data, u8, this.i) == '{' {
                this.i++
                if update : this.scope_ends.push('}')
                t = tok_ltcurly_open
                break
            }
            if ch == ')' {
                let ch_close = this.scope_ends.pop() ! this.error("Unexpected closing bracket: ')'")
                if ch != ch_close : this.error("Incorrect closing character: found ')', but expected '" + ch_close.to_ascii_string() + "'")
                t = tok_bracket_close
                break
            }
            if ch == ']' {
                let ch_close = this.scope_ends.pop() ! this.error("Unexpected closing bracket: ']'")
                if ch != ch_close : this.error("Incorrect closing character: found ']', but expected '" + ch_close.to_ascii_string() + "'")
                t = tok_sq_bracket_close
                break
            }
            if ch == '}' {
                let ch_close = this.scope_ends.pop() ! this.error("Unexpected closing bracket: '}'")
                if ch != ch_close : this.error("Incorrect closing character: found '}', but expected '" + ch_close.to_ascii_string() + "'")
                t = tok_curly_close
                break
            }

            // Sign
            t = tok_sign
            this.word_adr = data + this.i - 1
            this.word_len = 1
            break
            //
            // this.error("Parse error, unexpected byte: " + ch)
        }

        this.on_newline = on_newline
        if !update {
            this.i = i
            this.line = line
            this.col = col
        }

        return t
    }

    fn next_if(ch: u8) bool {
        if @ptrv(this.data, u8, this.i) == ch {
            this.i++
            if ch == '\n' {
                this.line++
                this.col = 1
            } else {
                this.col++
            }
            return true
        }
        return false
    }

    fn clone_chunk() Chunk {
        let chunk = this.chunk
        return Chunk {
            fc: chunk.fc
            content: chunk.content
            i: chunk.i
            line: chunk.line
            col: chunk.col
        }
    }

    static fn create(chunk: Chunk, parent: ?Parser) Parser {
        return Parser{
            chunk: chunk
            parent: parent
            data: chunk.content.data_ptr()
            len: chunk.content.bytes
            i: chunk.i
            line: chunk.line
            col: chunk.col
        }
    }

    fn create_sub_parser(chunk: Chunk) Parser {
        return Parser.create(chunk, this)
    }

    fn skip_word() {
        let len = this.len
        let data = this.data

        while this.i < len {
            let ch = @ptrv(data, u8, this.i++)
            this.col++
            if !ch.is_alpha_numeric() && ch != '_' {
                this.i--
                this.col--
                break
            }
        }
    }
    fn skip_number() int {
        let len = this.len
        let data = this.data
        let first = true
        let t = tok_int
        let prev_ch = @ptrv(data, u8, this.i - 1)

        while this.i < len {
            let ch = @ptrv(data, u8, this.i++)
            this.col++
            if first && prev_ch == '0' {
                first = false
                if ch == 'x' {
                    t = tok_hex
                    continue
                }
                if ch == 'c' {
                    t = tok_octal
                    continue
                }
            }
            if t == tok_hex {
                if !ch.is_hex() {
                    this.i--
                    this.col--
                    break
                }
            } else if t == tok_octal {
                if !ch.is_octal() {
                    this.i--
                    this.col--
                    break
                }
            } else if t == tok_int {
                if ch == '.' {
                    t = tok_float
                    continue
                }
                if !ch.is_number() {
                    this.i--
                    this.col--
                    break
                }
            } else if t == tok_float {
                if !ch.is_number() {
                    this.i--
                    this.col--
                    break
                }
            }
        }
        return t
    }
    fn skip_string() {
        let len = this.len
        let data = this.data

        while this.i < len {
            let ch = @ptrv(data, u8, this.i++)
            this.col++
            if ch == '\\' {
                this.i++
                this.col++
                continue
            }
            if ch == '"' {
                break
            }
        }
    }
    fn skip_func_args() {
    }
    fn skip_func_body() {
    }

    fn word() String {
        return String.make_from_ptr(this.word_adr, this.word_len)
    }
    fn word_is(sign: String) bool {
        if sign.bytes != this.word_len : return false
        let adr = this.word_adr
        let data = sign.data_ptr()
        return mem:equal(adr, data, sign.bytes)
    }

    fn sign_is(sign: String) bool {
        let adr = this.word_adr
        let data = sign.data_ptr()
        return mem:equal(adr, data, sign.bytes)
    }

    fn check_scope_end() {
        if this.scope_ends.length > 0 {
            let end_tok = this.scope_ends.pop() ! return
            this.error("Missing scope ending: '" + end_tok.to_ascii_string() + "'")
        }
    }

    fn read_word(allow_space: bool, allow_newline: bool, update: bool (true)) String !not_a_word {
        let t = this.tok(allow_space, allow_newline, update)
        if t != tok_word : throw not_a_word
        return this.word()
    }
    fn read_id(allow_space: bool, allow_newline: bool) String {
        let word = this.read_word(allow_space, allow_newline) ! this.error("Invalid identifier name")
        return word
    }

    static fn tok_has_word(tok: int) bool {
        return tok == tok_word || tok == tok_int || tok == tok_float || tok == tok_hex || tok == tok_octal || tok == tok_sign
    }

    fn tok_to_str(tok: int) String {
        if Parser.tok_has_word(tok) : return this.word()
        if tok == tok_bracket_close : return ")"
        if tok == tok_sq_bracket_close : return "]"
        if tok == tok_curly_close : return "}"
        if tok == tok_bracket_open : return "("
        if tok == tok_sq_bracket_open : return "["
        if tok == tok_curly_open : return "{"
        if tok == tok_ltcurly_open : return "<{"
        return "(token: " + tok + ")"
    }

    // Error handler
    exit_fn error(msg: String) {

        let chunk = this.chunk
        let content = chunk.content
        let data = this.data
        let len = this.len

        this.i--
        this.col--

        println("------------------------------------")
        println("# Parser error")
        println("# Line: " + this.line + " | Col: " + this.col)
        println("# Error: " + msg)

        let i = this.i
        let starti = i
        let endi = i
        while starti > 0 && @ptrv(data, u8, starti - 1) != '\n' {
            starti--
        }
        while endi < len && @ptrv(data, u8, endi + 1) != '\n' {
            endi++
        }

        let before_len = i - starti
        if before_len > 15 {
            starti = i - 15
            before_len = 15
        }
        let after_len = 34 - before_len

        let line_len = endi - starti + 1
        let line = String.make_from_ptr(data + starti, line_len)
        println("------------------------------------")
        println(line)

        let c : uint = before_len
        while c-- > 1 {
            print("-")
        }
        if before_len > 0 : print(" ")
        print("^ ")
        c = after_len
        while c-- > 0 {
            print("-")
        }
        print("\n")

        exit(1)
    }
}
