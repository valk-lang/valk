
use helper

fn stage_types(b: Build) {

    if b.verbose > 2 : b.log("> Stage 2.4: Read types for functions & globals")

    each b.units as unit {
        each unit.functions as func {
            parse_func_args(func)
        }
    }

    stage_ast(b)
}

fn parse_func_args(func: Func) {
    let p = Parser.new(func.chunk_args, null)

    while true {
        let t = p.tok(true, true)

        if p.sign_is(")") {
            break
        }
        if t == tok_at_word {
            if p.word_is("@infinite") {
                func.infinite_args = true
                p.expect(")", true, true)
                break
            }
        }
        if t != tok_word {
            p.error("Invalid argument name: " + p.word())
        }
        // Name
        let name = p.word()
        p.expect(":", true, true)
        // Type
        let type = read_type(p, func.fc.scope, true)
        // Arg
        let arg = Arg{
            name: name
            type: type
            decl: Decl.new(type, true)
        }
        func.args.push(arg)
        func.scope.set_idf(p, name, Idf.for_decl(arg.decl))
        // Default value
        t = p.tok(true, true, false)
        if p.sign_is("(") {
            p.tok(true, true)
            arg.chunk_value = p.clone_chunk()
            p.skip_body(")")
        }
        // Next
        t = p.tok(true, true)
        if p.sign_is(",") : continue
        if p.sign_is(")") : break
        p.error_token()
    }

    // Return type
    let t = p.tok(true, true, false)
    if !p.sign_is("{") && !p.sign_is("!") && !p.sign_is(";") {
        // Must be on same line
        func.rett = read_type(p, func.fc.scope, false)
    } else {
        func.rett = type_void(p.build)
    }

    p.tok(true, true)
    while p.sign_is("!") {
        let t = p.tok(false, false)
        if t != tok_word : p.error("Invalid error name syntax: " + p.word())
        let name = p.word()
        let val = helper:ctxhash_u32(name)
        if func.errors.has(name) : p.error("Duplicate error name: " + name)
        if func.errors.has_value(val) : p.error("It seems that 2 different error names are resolving to the same hash, try picking a different error name: " + name)
        func.errors.set(name, val)
    }
}
