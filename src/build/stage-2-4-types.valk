
use helper

fn stage_types(b: Build) {

    if b.verbose > 2 : b.log("> Stage 2.4: Read types for functions & globals")

    each b.units as unit {
        each unit.functions as func {
            parse_func_args(func)
        }
    }

    each b.globals as g {
        parse_global_type(g)
    }

    stage_ast(b)
}

fn parse_func_args(func: Func) {

    if func.parsed_args : return
    func.parsed_args = true

    let p = Parser.new(func.chunk_args, null)

    while true {
        let t = p.tok(true, true)

        if p.sign_is(")") {
            break
        }
        if t == tok_at_word {
            if p.word_is("@infinite") {
                func.infinite_args = true
                p.expect(")", true, true)
                break
            }
        }
        if t != tok_word {
            p.error("Invalid argument name: " + p.word())
        }
        // Name
        let name = p.word()
        p.expect(":", true, true)
        // Type
        let type = read_type(p, func.scope, true)
        // Arg
        let arg = Arg{
            name: name
            type: type
            decl: Decl.new(type, true)
        }
        func.args.push(arg)
        func.scope.set_idf(p, name, Idf.for_decl(arg.decl))
        // Default value
        t = p.tok(true, true, false)
        if p.sign_is("(") {
            p.tok(true, true)
            arg.chunk_value = p.clone_chunk()
            p.skip_body(")")
        }
        // Next
        t = p.tok(true, true)
        if p.sign_is(",") : continue
        if p.sign_is(")") : break
        p.error_token()
    }

    // Return type
    let t = p.tok(true, true, false)
    if !p.sign_is("{") && !p.sign_is("!") && !p.sign_is(";") && !p.sign_is("$") {
        // Must be on same line
        let scope = func.scope
        if p.sign_is("(") {
            p.tok(true, true)
            let types = p.read_types(scope, ")", true)
            each types as type {
                if type.is_void() && types.length > 1 : p.error("You cannot use 'void' in a list of types")
                func.add_rett(type)
            }
        } else {
            let rett = read_type(p, scope, false)
            func.add_rett(rett)
        }
        func.scope.must_return = true
    }

    t = p.tok(true, true)
    while p.sign_is("!") {
        t = p.tok(false, false)
        if t != tok_word : p.error("Invalid error name syntax: " + p.word())
        let name = p.word()
        let val = helper:ctxhash_u32(name)
        if func.errors.has(name) : p.error("Duplicate error name: " + name)
        if func.errors.has_value(val) : p.error("It seems that 2 different error names are resolving to the same hash, try picking a different error name: " + name)
        func.errors.set(name, val)
        func.can_error = true
        t = p.tok(true, true)
    }

    while t == tok_flag {
        let name = p.word()
        if p.word_is("$entrance") {
            func.is_entrance = true
        } else if p.word_is("$parse_last") {
            func.parse_last = true
        } else {
            p.error("Unknown flag: " + p.word())
        }
        t = p.tok(true, true)
    }
}


fn parse_global_type(g: Global) {
    let chunk = g.chunk_type
    if !isset(chunk) : return
    let p = Parser.new(chunk, null)
    let type = read_type(p, g.fc.scope, true)
    g.type = type
}
