
fn parse_match_value(p: Parser, scope: Scope) Value {

    let b = p.build
    let on = read_value(p, scope)

    let rett = type_void(b)
    let returns_a_value = false
    let decls = Array[Decl].new()

    // Check return type
    let t = p.tok(true, false, false)
    if p.word_is(":") {
        p.tok(true, true)
        rett = read_type(p, scope, true)
        returns_a_value = true
        // Result buffer variables
        let retts = rett.unroll()
        each retts as rett {
            let decl = Decl.new(rett, false)
            decl.is_used = true
            decl.is_mut = true
            decls.push(decl)
            scope.add_decl(decl)
        }
    }

    p.expect("{", true, true)

    let root_scope = scope.sub_scope(sc_default)

    let main_ast = root_scope
    let if_scope = main_ast.sub_scope(sc_if)
    let else_scope = main_ast.sub_scope(sc_if)
    let default_reached = false

    // Parse match items
    while true {
        p.tok(true, true, false)
        if p.word_is("}") {
            p.tok(true, true)
            break
        }
        if default_reached {
            p.error("You cannot define cases after the 'default' case. You should move the 'default' case to the bottom of the list.")
        }
        let is_default = false
        let cond : ?Value = null
        if p.word_is("default") {
            p.tok(true, true)
            is_default = true
            default_reached = true
            if_scope = main_ast
        } else {
            p.set_suggest(on.rett)
            let itemv = read_value(p, main_ast)
            p.pop_suggest()

            let condv = match_compare_value(p, on, itemv)
            apply_issets(if_scope, condv.issets)
            cond = condv

            main_ast.ast.push(Token {
                type: tk_if
                value1: condv
                scope1: if_scope
                scope2: else_scope
            })
        }

        p.expect("=>", true, true)

        let sub = if_scope.sub_scope(sc_default)
        let itemv = read_inline_scope_value(p, sub)
        let did_return = itemv.rett.is_none()

        if returns_a_value && !did_return {
            itemv = vgen_unroll_inline_scope(itemv)
            // itemv = itemv.try_convert(p.get_ds(), rett)
            rett.compat_check(itemv.rett, p)

            let values = itemv.unroll()
            each decls as i, decl {
                let val = values.get(i) ! p.error("Missing match value (bug)")
                if_scope.ast.push(Token {
                    type: tk_declare
                    decl: decl
                    value1: val
                })
            }
        }

        if isset(cond) {
            if did_return : apply_issets(scope, cond.not_issets)
            apply_issets(else_scope, cond.not_issets)
        }

        if !is_default {
            main_ast = else_scope
            if_scope = else_scope.sub_scope(sc_if)
            else_scope = else_scope.sub_scope(sc_if)
        }
    }

    let matchv = vgen_inline_scope(root_scope, rett)

    if !returns_a_value {
        return matchv
    }

    let result = Array[Value].new()
    each decls as decl {
        let v = vgen_decl(decl)
        v.pre_value = matchv
        result.push(v)
    }

    return vgen_grouped_values(b, result)
}

fn match_compare_value(p: Parser, on: Value, value: Value) Value {

    let b = p.build

    let l, r = match_op_values(b, on, value)
    l.rett.compat_check(r.rett, p)
    let comp = vgen_compare(l, r, op_eq, type_valk(b, "bool"))

    return comp
}
