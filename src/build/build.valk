
use helper
use lsp
use valk:ansi

class Build {
    mode: int (BUILDTYPE.exe)
    target: Target
    verbose: int (0)
    path_out: String
    cache_dir: String
    config_dir: String
    files: Array[String]
    pkc_by_dir: Map[Pkc] (Map[Pkc]{})
    nsc_by_dir: Map[Nsc] (Map[Nsc]{})
    pkc_valk_: ?Pkc (null)
    nsc_main_: ?Nsc (null)
    fc_by_path: Map[Fc] (Map[Fc]{})
    main_func: ?Func (null)
    main_unit_: ?Unit (null)
    generated_main_func: ?Func (null)
    generated_unit_: ?Unit (null)
    generated_fc_: ?Fc (null)
    //
    units: Array[Unit] (Array[Unit]{})
    fc_pipeline: Array[Fc] (Array[Fc]{})
    ast_pipeline: Array[Func] (Array[Func]{})
    links_named: Map[Link] (Map[Link]{})
    links: Array[Link] (Array[Link]{})
    aliasses: Array[Alias] (Array[Alias]{})
    classes: Array[Class] (Array[Class]{})
    objects: Map[Class] (Map[Class]{})
    modes: Array[Class] (Array[Class]{})
    globals: Array[Global] (Array[Global]{})
    globals_used: Array[Global] (Array[Global]{})
    classes_used: Array[Class] (Array[Class]{})
    extends: Array[Chunk] (Array[Chunk]{})
    functions: Array[Func] (Array[Func]{})
    tests: Array[Func] (Array[Func]{})
    vtable_indexes: Map[uint] (Map[uint]{})
    enums: Array[Enum] (Array[Enum]{})
    //
    functions_tracking_globals: Array[Func] (Array[Func]{})
    functions_tracking_classes: Array[Func] (Array[Func]{})
    // Compile macro
    cm_defs: Map[String] (Map[String].new())
    //
    lsp: ?lsp:Lsp (null)
    build_errors: Array[BuildError] (Array[BuildError]{})
    parse_errors: Array[ParseError] (Array[ParseError]{})
    warnings: Array[String] (Array[String]{})
    //
    ptr_size: uint (8)
    gen_func_name: uint (0)
    LOC: uint (0)
    LOCP: uint (0)
    vtable_index_count: uint (0)
    //
    cli: helper:CLIArgs
    class_sizes_known: bool (false)
    new_globals_used: bool (false)
    new_classes_used: bool (false)
    no_warn: bool (false)
    is_test: bool (false)
    is_clean_build: bool (false)
    is_static: bool (false)
    optimize: bool (true)
    debug: bool (false)
    run: bool (false)
    is_watch: bool (false)

    fn getlsp() lsp:Lsp {
        return this.lsp ?! this.error("Missing LSP object")
    }

    fn error_emoji(emoji: String, msg: String) $exit {
        msg = ansi:supported() ? emoji + " " + msg : "> " + msg
        this.error(msg)
    }
    fn error(msg: String) $exit {

        let lsp = this.lsp
        if isset(lsp) {
            this.build_errors.append(BuildError {
                type: err_type_error
                msg: msg
            })
            cothrow build_error, "Build error"
        }

        println("# Build error")
        println("-----------------------------")
        println(msg.trim("\n"))
        println("-----------------------------")

        if this.is_watch {
            cothrow build_error, "Build error"
        }

        exit(1)
    }
    fn warn(msg: String) {
        this.build_errors.append(BuildError {
            type: err_type_warn
            msg: msg
        })
    }
    fn warnLsp(msg: String, start: Chunk, end: Chunk) {
        this.parse_errors.append(ParseError {
            chunk: start
            chunk_end: end
            msg: msg
            type: err_type_warn
        })
    }
    fn print_warnings() {
        if this.no_warn : return
        each this.build_errors as err {
            if err.type == err_type_warn {
                println("Warn: " + err.msg)
            }
        }
    }

    fn pkc_valk() Pkc {
        let pkc = this.pkc_valk_
        if isset(pkc) : return pkc
        this.error("Cannot find valk package (bug)")
    }
    fn nsc_main() Nsc {
        let nsc = this.nsc_main_
        if isset(nsc) : return nsc
        this.error("Cannot find main:main namespace (bug)")
    }
    fn generated_fc() Fc {
        let fc = this.generated_fc_
        if isset(fc) : return fc
        let nsc = this.nsc_main()
        let scope = nsc.scope.sub_scope(SCOPE.fc)
        fc = Fc{
            nsc: nsc
            build: this
            unit: nsc.default_unit
            path: "<valk-generated-code>"
            start: null
            scope: scope
            is_lsp_file: false
            ignore_act: true
            is_generated: true
        }
        scope.fc = fc
        this.generated_fc_ = fc
        return fc
    }
    fn generated_unit() Unit {
        let u = this.generated_unit_
        if isset(u) : return u
        this.error("Cannot find unit for generated functions (bug)")
    }
    fn fake_func() Func {
        let tvoid = type_void(this)
        let fc = this.generated_fc()
        let fake_func = Func {
            unit: this.generated_unit()
            build: this
            fc: fc
            parse_fc: fc
            name: "fake"
            export_name: "fake"
            display_name: "fake"
            rett: tvoid
            rett_real: tvoid
            arg_scope: Scope.new(SCOPE.func, this)
            act: 0
        }
        return fake_func
    }

    fn log(msg: String) {
        println(msg)
    }

    fn valk_idf(ns: String, name: String) Idf {
        let pkc = this.pkc_valk()
        let nsc = pkc.namespaces.get(ns) ! this.error("Compiler bug | Missing valk namespace: " + ns)
        return nsc.scope.identifiers.get(name) ! this.error("Compiler bug | Missing valk identifier: " + name)
    }
    fn valk_func(ns: String, name: String) Func {
        let idf = this.valk_idf(ns, name)
        let func = idf.func
        if !isset(func) : this.error("Compiler bug | Identifier is not a function")
        return func
    }
    fn valk_class(ns: String, name: String) Class {
        let idf = this.valk_idf(ns, name)
        let class = idf.class
        if !isset(class) : this.error("Compiler bug | Identifier is not a class")
        return class
    }
    fn valk_class_func(ns: String, name: String, fn: String) Func {
        let class = this.valk_class(ns, name)
        return class.funcs.get(fn) ! this.error("Compiler bug | Missing valk class function: " + fn)
    }
    fn valk_global(ns: String, name: String) Global {
        let idf = this.valk_idf(ns, name)
        let g = idf.global
        if !isset(g) : this.error("Compiler bug | Identifier is not a global variable")
        return g
    }
    fn valk_type(ns: String, name: String) Type {
        let class = this.valk_class(ns, name)
        return class.get_type()
    }
    fn error_code_type() Type {
        return this.valk_type("type", "u32")
    }
    fn error_msg_type() Type {
        return this.valk_type("type", "String")
    }
    fn array_of_string_type() Type {
        let a = this.valk_class("type", "Array")
        let s = this.valk_type("type", "String")
        let gtypes = Array[Type]{ s }
        let g = get_class_generic(this, a, gtypes)
        return g.get_type()
    }
    fn bool_type() Type {
        let class = this.valk_class("type", "bool")
        return class.get_type()
    }

    fn set_cm_defs(cli: helper:CLIArgs) {
        this.cm_defs.set("OS", this.target.os)
        this.cm_defs.set("ARCH", this.target.arch)
        this.cm_defs.set("TEST", this.is_test ? "1" : "0")
        this.cm_defs.set("STATIC", this.is_static ? "1" : "0")
        this.cm_defs.set("GC_DEBUG", "0")
        this.cm_defs.set("DEBUG", this.debug ? "1" : "0")

        let defs = cli.get_all("--def")
        each defs as def {
            let split = def.split(",")
            each split as pair {
                pair = pair.trim(" ")
                let split2 = pair.split("=")
                if split2.length == 1 {
                    this.cm_defs.set(pair, "1")
                } else {
                    let name = split2.get(0) ! continue
                    let val = split2.get(1) ! continue
                    this.cm_defs.set(name, val)
                }
            }
        }
    }

    fn main_idf(name: String) Idf {
        let nsc = this.nsc_main()
        return nsc.scope.identifiers.get(name) ! this.error("Compiler bug | Missing valk-main identifier: " + name)
    }
    fn main_global(name: String) Global {
        let idf = this.main_idf(name)
        let g = idf.global
        if !isset(g) : this.error("Compiler bug | Identifier is not a global variable")
        return g
    }

    fn get_vtable_index(name: String) uint {
        let indexes = this.vtable_indexes
        let index = indexes.get(name) ! {
            let index = this.vtable_index_count++
            indexes.set(name, index)
            return index
        }
        return index
    }

    fn get_pool_index(size: uint) (uint, uint) {
        let ptr_size = this.ptr_size
        // Determine pool index
        let until : uint = 16 * ptr_size
        if size <= until {
            let i : uint = size / ptr_size
            let isize = i * ptr_size
            if i * size_of(ptr) == size : i--
            return (i, isize)
        }
        let i : uint = 16
        let isize = until * 2
        while isize < size {
            i++
            isize *= 2
        }
        return (i, isize)
    }

    fn is_ir() bool { return this.mode == BUILDTYPE.ir }
    fn main_unit() Unit {
        return this.main_unit_ ?? <{
            let u = Unit.new(this, "main", helper:ctxhash(this.config_dir))
            this.main_unit_ = u
            return u
        }
    }
}
