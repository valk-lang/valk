
use helper
use lsp
use valk:ansi

class Build {
    mode: int (b_exe)
    target: Target
    verbose: int (0)
    path_out: String
    cache_dir: String
    config_dir: String
    files: Array[String]
    pkc_by_dir: Map[Pkc] (Map[Pkc]{})
    nsc_by_dir: Map[Nsc] (Map[Nsc]{})
    pkc_valk_: ?Pkc (null)
    nsc_main_: ?Nsc (null)
    fc_by_path: Map[Fc] (Map[Fc]{})
    main_func: ?Func (null)
    generated_main_func: ?Func (null)
    generated_unit_: ?Unit (null)
    generated_fc_: ?Fc (null)
    //
    units: Array[Unit] (Array[Unit]{})
    fc_pipeline: Array[Fc] (Array[Fc]{})
    ast_pipeline: Array[Func] (Array[Func]{})
    links_named: Map[Link] (Map[Link]{})
    links: Array[Link] (Array[Link]{})
    aliasses: Array[Alias] (Array[Alias]{})
    classes: Array[Class] (Array[Class]{})
    objects: Map[Class] (Map[Class]{})
    modes: Array[Class] (Array[Class]{})
    globals: Array[Global] (Array[Global]{})
    extends: Array[Chunk] (Array[Chunk]{})
    functions: Array[Func] (Array[Func]{})
    tests: Array[Func] (Array[Func]{})
    vtable_indexes: Map[uint] (Map[uint]{})
    enums: Array[Enum] (Array[Enum]{})
    // Compile macro
    cm_defs: Map[String] (Map[String].new())
    //
    lsp: ?lsp:Lsp (null)
    build_errors: Array[BuildError] (Array[BuildError]{})
    parse_errors: Array[ParseError] (Array[ParseError]{})
    warnings: Array[String] (Array[String]{})
    //
    ptr_size: uint (8)
    gen_func_name: uint (0)
    LOC: uint (0)
    vtable_index_count: uint (0)
    //
    cli: helper:CLIArgs
    class_sizes_known: bool (false)
    no_warn: bool (false)
    is_test: bool (false)
    is_clean_build: bool (false)
    is_static: bool (false)
    optimize: bool (true)
    run: bool (false)

    fn getlsp() lsp:Lsp {
        return this.lsp ?! this.error("Missing LSP object")
    }

    fn error_emoji(emoji: String, msg: String) $exit {
        msg = ansi:supported() ? emoji + " " + msg : "> " + msg
        build_error(msg)
    }
    fn error(msg: String) $exit {

        let lsp = this.lsp
        if isset(lsp) {
            this.build_errors.push(BuildError {
                type: err_type_error
                msg: msg
            })
            cothrow build_error, "Build error"
        }

        build_error(msg)
    }
    fn warn(msg: String) {
        this.build_errors.push(BuildError {
            type: err_type_warn
            msg: msg
        })
    }
    fn print_warnings() {
        if this.no_warn : return
        each this.build_errors as err {
            if err.type == err_type_warn {
                println("Warn: " + err.msg)
            }
        }
    }

    fn pkc_valk() Pkc {
        let pkc = this.pkc_valk_
        if isset(pkc) : return pkc
        this.error("Cannot find valk package (bug)")
    }
    fn nsc_main() Nsc {
        let nsc = this.nsc_main_
        if isset(nsc) : return nsc
        this.error("Cannot find main:main namespace (bug)")
    }
    fn generated_fc() Fc {
        let fc = this.generated_fc_
        if isset(fc) : return fc
        let nsc = this.nsc_main()
        fc = Fc{
            nsc: nsc
            header_nsc: nsc
            build: this
            unit: nsc.default_unit
            path: "<valk-generated-code>"
            start: null
            scope: nsc.scope.sub_scope(sc_fc)
            is_header: false
            is_lsp_file: false
            ignore_act: true
            is_generated: true
        }
        return fc
    }
    fn generated_unit() Unit {
        let u = this.generated_unit_
        if isset(u) : return u
        this.error("Cannot find unit for generated functions (bug)")
    }

    fn log(msg: String) {
        println(msg)
    }

    fn valk_idf(ns: String, name: String) Idf {
        let pkc = this.pkc_valk()
        let nsc = pkc.namespaces.get(ns) ! this.error("Compiler bug | Missing valk namespace: " + ns)
        return nsc.scope.identifiers.get(name) ! this.error("Compiler bug | Missing valk identifier: " + name)
    }
    fn valk_func(ns: String, name: String) Func {
        let idf = this.valk_idf(ns, name)
        let func = idf.func
        if !isset(func) : this.error("Compiler bug | Identifier is not a function")
        return func
    }
    fn valk_class(ns: String, name: String) Class {
        let idf = this.valk_idf(ns, name)
        let class = idf.class
        if !isset(class) : this.error("Compiler bug | Identifier is not a class")
        return class
    }
    fn valk_class_func(ns: String, name: String, fn: String) Func {
        let class = this.valk_class(ns, name)
        return class.funcs.get(fn) ! this.error("Compiler bug | Missing valk class function: " + fn)
    }
    fn valk_global(ns: String, name: String) Global {
        let idf = this.valk_idf(ns, name)
        let g = idf.global
        if !isset(g) : this.error("Compiler bug | Identifier is not a global variable")
        return g
    }
    fn valk_type(ns: String, name: String) Type {
        let class = this.valk_class(ns, name)
        return class.get_type()
    }
    fn array_of_string_type() Type {
        let a = this.valk_class("type", "Array")
        let s = this.valk_type("type", "String")
        let gtypes = Array[Type]{ s }
        let g = get_class_generic(this, a, gtypes)
        return g.get_type()
    }
    fn bool_type() Type {
        let class = this.valk_class("type", "bool")
        return class.get_type()
    }

    fn set_cm_defs(cli: helper:CLIArgs) {
        this.cm_defs.set("OS", this.target.os)
        this.cm_defs.set("ARCH", this.target.arch)
        this.cm_defs.set("TEST", this.is_test ? "1" : "0")
        this.cm_defs.set("STATIC", this.is_static ? "1" : "0")

        let defs = cli.get_all("--def")
        each defs as def {
            let split = def.split(",")
            each split as pair {
                pair = pair.trim(" ")
                let split2 = pair.split("=")
                if split2.length == 1 {
                    this.cm_defs.set(pair, "1")
                } else {
                    let name = split2.get(0) ! continue
                    let val = split2.get(1) ! continue
                    this.cm_defs.set(name, val)
                }
            }
        }
    }

    fn main_idf(name: String) Idf {
        let nsc = this.nsc_main()
        return nsc.scope.identifiers.get(name) ! this.error("Compiler bug | Missing valk-main identifier: " + name)
    }
    fn main_global(name: String) Global {
        let idf = this.main_idf(name)
        let g = idf.global
        if !isset(g) : this.error("Compiler bug | Identifier is not a global variable")
        return g
    }

    fn get_vtable_index(name: String) uint {
        let indexes = this.vtable_indexes
        let index = indexes.get(name) ! {
            let index = this.vtable_index_count++
            indexes.set(name, index)
            return index
        }
        return index
    }
}
