

fn func_ref_value_to_closure(v: Value, scope: Scope) Value {
    return closure_init_value(v, null, scope)
}

fn closure_init_value(fptr: Value, bind_values: ?Array[Value], scope: Scope) Value {

    let b = fptr.rett.build
    let fi = fptr.rett.func_info
    if !isset(fi) : b.error("Missing closure function info (bug)")

    // Generate data class
    let data_type = type_void(b)
    if isset(bind_values) {
        if bind_values.length > 0 {
            // let data_class = ...
            // data_type = data_class.get_type()
        }
    }

    // Generate closure type
    let closure_class = b.valk_class("core", "Closure")
    // let closure_generic_types = Array[Type].new()
    // closure_generic_types.push(fptr.rett)
    // closure_generic_types.push(data_type)
    // let closure_class = get_class_generic(b, closure_class_base, closure_generic_types)

    // Init data class instance
    let data : Value = vgen_null(b.valk_type("type", "ptr"))
    if isset(bind_values) {
        if bind_values.length > 0 {
            let values_data = Map[Value].new()
            // TODO...
        }
    }

    // Init closure class instance
    let values_closure = Map[Value].new()
    values_closure.set("func", fptr)
    values_closure.set("data", data)

    let v = vgen_class_init(closure_class, scope, values_closure)
    v = vgen_cast(v, type_closure(b, fi))
    return v
}
