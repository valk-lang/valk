

fn func_ref_value_to_closure(ctx: Context, v: Value, decl_scope: Scope) Value {
    let func = v.func
    if !isset(func) : ctx.error("Missing function object in fptr value (bug)")
    return closure_init_value(ctx, func, null, decl_scope)
}

fn closure_init_value(ctx: Context, inner_function: Func, bind_values: ?Array[Value], decl_scope: Scope) Value {

    let b = ctx.build
    let fi = inner_function.info()
    // let b = fptr.rett.build
    // let fi = fptr.rett.func_info
    // if !isset(fi) : b.error("Missing closure function info (bug)")

    let parent_func = decl_scope.func
    if !isset(parent_func) : b.error("Missing closure parent function (bug)")

    // Init data class instance
    let data : Value = vgen_null(b.valk_type("gc", "GcPtr"))
    let data_rett = data.rett
    let data_class : ?Class = null
    if isset(bind_values) {
        if bind_values.length > 0 {
            data_class = closure_gen_data_class(b, parent_func.unit, bind_values)
            let values_data = Map[Value].new()
            each bind_values as bv, i {
                values_data.set("data_" + i, bv)
            }
            data = vgen_class_init(ctx, data_class.@cast(Class), decl_scope, null, values_data)
            data.rett = data_rett
        }
    }

    // Generate closure type
    let closure_class = b.valk_class("core", "Closure")
    let outer_func = generate_closure_outer_function(parent_func, inner_function, fi, data_class, bind_values)
    parent_func.functions_used.append(outer_func)
    outer_func.functions_used.append(inner_function)
    // outer_func.used_in(decl_scope)
    // inner_func.used_in(decl_scope)

    // Init closure class instance
    let values_closure = Map[Value].new()
    values_closure.set("outer_func", vgen_func_ptr(outer_func))
    values_closure.set("data", data)

    // Generate correct function info
    let clo_fi = outer_func.info()
    clo_fi = clo_fi.clone()
    let new_args = Array[Type].new()
    each clo_fi.args as type, i {
        if i == 0 : continue
        new_args.append(type)
    }
    clo_fi.args = new_args

    // 
    let v = vgen_class_init(ctx, closure_class, decl_scope, null, values_closure)
    v = vgen_cast(v, type_closure(b, clo_fi))
    return v
}

fn generate_closure_outer_function(parent: Func, inner_function: Func, fi: FuncInfo, data_class: ?Class, bind_values: ?Array[Value]) Func {
    let u = parent.unit
    let b = u.build
    let func = u.new_func(parent.fc, parent.fc, ACT.public, null, null, null)

    // Define function arguments
    let closure_class = b.valk_class("core", "Closure")
    let data_arg = func.add_arg("closure_obj", closure_class.get_type())
    let limit = fi.args.length - (isset(data_class) ? data_class.props.length : 0)
    each fi.args as arg_type, i {
        if i == limit : break
        func.add_arg("arg" + i, arg_type)
    }

    // Return types
    func.rett = inner_function.rett
    func.rett_real = inner_function.rett_real

    // Errors
    func.can_error = fi.can_error
    func.errors = fi.errors

    //
    let ctx = Context {
        build: b
        unit: u
        func: func
    }

    ////////////////////////
    // AST
    ////////////////////////

    func.init_ast_scope()
    let fast = func.fast()
    let ast = fast.scope.ast

    // Read data
    let inner_func = vgen_func_ptr(inner_function)

    // Push arguments
    let inner_values = Array[Value]{}
    each func.args as arg, i {
        if i == 0 : continue
        inner_values.append(vgen_decl(arg.decl))
    }

    // Push bind values
    if isset(data_class) && isset(bind_values) {
        let prop_data = closure_class.props.get("data") ! b.error("Missing closure 'data' property (bug)")
        let on = vgen_prop(prop_data, vgen_decl(data_arg.decl))
        each bind_values as val {
            let prop = val.bind_prop
            if isset(prop) : inner_values.append(vgen_prop(prop, on))
        }
    }

    // Call inner function
    let inner_call = vgen_func_call(b, fast.scope, inner_func, inner_values)

    if fi.can_error {
        // Pass error
        inner_call = value_pass_handler(ctx, fast.scope, inner_call)
    }

    // Return value
    if fi.rett_types.length > 0 {
        ast_gen_return(ctx, func, fast.scope, inner_call)
    } else {
        ast.append(Token {
            type: AST.statement
            value1: inner_call
        })

        let values = Array[Value]{}
        each func.rett_real.unroll() as type {
            values.append(vgen_empty_value(type))
        }
        ast_return_value(func, fast.scope, vgen_grouped_values(b, values))
        // ast_return_value(func, fast.scope, null)
    }

    func.finish_ast_scope()
    func_ir(func)
    func.wipe_ast()

    return func
}

fn closure_gen_data_class(b: Build, u: Unit, bind_values: Array[Value]) Class {

    let dclass = u.new_class(b.generated_fc(), ACT.public, null, CT.class, null, null)

    each bind_values as val, i {
        let name = "data_" + i
        let prop = Prop {
            name: name
            type: val.rett
            class: dclass
            act: ACT.public
        }
        dclass.props.set(name, prop)
        val.bind_prop = prop
    }

    dclass.determine_size() ! b.error("Cannot determine closure data class size (bug)")

    return dclass
}
