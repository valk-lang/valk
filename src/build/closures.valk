

fn func_ref_value_to_closure(v: Value, decl_scope: Scope) Value {
    return closure_init_value(v, null, decl_scope)
}

fn closure_init_value(fptr: Value, bind_values: ?Array[Value], decl_scope: Scope) Value {

    let b = fptr.rett.build
    let fi = fptr.rett.func_info
    if !isset(fi) : b.error("Missing closure function info (bug)")

    let parent_func = decl_scope.func
    if !isset(parent_func) : b.error("Missing closure parent function (bug)")

    // Generate closure type
    let closure_class = b.valk_class("core", "Closure")
    let outer_func = generate_closure_outer_function(parent_func, fi, bind_values, decl_scope)

    // Init data class instance
    let data : Value = vgen_null(b.valk_type("type", "ptr"))
    if isset(bind_values) {
        if bind_values.length > 0 {
            let values_data = Map[Value].new()
            // TODO...
        }
    }

    // Init closure class instance
    let values_closure = Map[Value].new()
    values_closure.set("inner_func", fptr)
    values_closure.set("outer_func", vgen_func_ptr(outer_func))
    values_closure.set("data", data)

    let v = vgen_class_init(closure_class, decl_scope, values_closure)
    v = vgen_cast(v, type_closure(b, fi))
    return v
}

fn generate_closure_outer_function(parent: Func, fi: FuncInfo, bind_values: ?Array[Value], decl_scope: Scope) Func {
    let u = parent.unit
    let b = u.build
    let func = u.new_func(parent.fc, act_public, null, null, null)

    // Generate data class
    let data_type = type_ptr(b)
    if isset(bind_values) {
        if bind_values.length > 0 {
            // let data_class = ...
            // data_type = data_class.get_type()
        }
    }

    // Define function arguments
    let data_arg = func.add_arg("closure_data", data_type)
    each fi.args as i, arg_type {
        func.add_arg("arg" + i, arg_type)
    }
    // Return types
    each fi.rett_types as i, rett {
        func.add_rett(rett)
    }
    if func.rett_types.length > 0 {
        func.scope.must_return = true
    }
    // Errors
    func.can_error = fi.can_error
    func.errors = fi.errors

    ////////////////////////
    // AST
    ////////////////////////

    func.init_ast_scope()
    let ast = func.scope.ast

    // Read data
    let closure_class = b.valk_class("core", "Closure")
    let prop_inner = closure_class.props.get("inner_func") ! b.error("Missing closure 'inner_func' property (bug)")
    let inner_func = vgen_prop(prop_inner, vgen_decl(data_arg.decl))
    inner_func = vgen_cast(inner_func, type_func_info(b, fi))

    // Push arguments
    let inner_values = array[Value]{}
    each func.args as i, arg {
        if i == 0 : continue
        inner_values.push(vgen_decl(arg.decl))
    }

    // Push bind values
    if isset(bind_values) {
        if bind_values.length > 0 {
            // let data_class = ...
            // data_type = data_class.get_type()
            each bind_values as value {
            }
        }
    }

    // Call inner function
    let inner_call = vgen_func_call(b, decl_scope, inner_func, inner_values)
    if fi.rett_types.length > 0 {
        ast_gen_return(func, func.scope, array[Value]{ inner_call })
    } else {
        ast.push(Token {
            type: tk_statement
            value1: inner_call
        })
        ast_return_value(func, func.scope, null)
    }

    func.finish_ast_scope()
    func.parsed_ast = true

    func_ir(func)

    return func
}