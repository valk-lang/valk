
fn ir_comment(ir: IR, text: String) {
    let code = ir.code()
    code.append_str("; ")
    code.append_str(text)
    code.append_str("\n")
}
fn ir_jump(ir: IR, block: IRBlock) {
    let code = ir.code()
    code.append_str("  br label %")
    code.append_str(block.name)
    code.append_str("\n")
}
fn ir_cond_jump(ir: IR, cond: String, block1: IRBlock, block2: IRBlock) {
    let code = ir.code()
    code.append_str("  br i1 ")
    code.append_str(cond)
    code.append_str(", label %")
    code.append_str(block1.name)
    code.append_str(", label %")
    code.append_str(block2.name)
    code.append_str("\n")
}

fn ir_store(ir: IR, var: String, val: String, type: String) {
    let code = ir.code()
    code.append_str("  store ")
    code.append_str(type)
    code.append_str(" ")
    code.append_str(val)
    code.append_str(", ptr ")
    code.append_str(var)
    code.append_str(", align 8\n")
}
fn ir_load(ir: IR, from: String, type: String) String {
    let var = ir.var()
    let code = ir.code()
    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = load ")
    code.append_str(type)
    code.append_str(", ptr ")
    code.append_str(from)
    code.append_str(", align 8\n")
    return var
}

fn ir_ret(ir: IR, val: String, type: String) {
    let code = ir.code()
    code.append_str("  ret ")
    code.append_str(type)
    code.append_str(" ")
    code.append_str(val)
    code.append_str("\n")
}
fn ir_ret_void(ir: IR) {
    let code = ir.code()
    code.append_str("  ret void\n")
}
fn ir_gep(ir: IR, on: String, offset: uint) String {
    let var = ir.var()
    let code = ir.code()
    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = getelementptr i8, ptr ")
    code.append_str(on)
    code.append_str(", i32 ")
    code.append_str(offset)
    code.append_str("\n")
    return var
}
fn ir_gep_typed(ir: IR, on: String, type: String, offset: String, offset_type: String) String {
    let var = ir.var()
    let code = ir.code()
    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = getelementptr ")
    code.append_str(type)
    code.append_str(", ptr ")
    code.append_str(on)
    code.append_str(", ")
    code.append_str(offset_type)
    code.append_str(" ")
    code.append_str(offset)
    code.append_str("\n")
    return var
}

fn ir_func_ptr(ir: IR, func: Func) String {
    ir_check_func_definition(ir, func)
    return "@" + func.export_name
}

fn ir_call(ir: IR, on: String, info: FuncInfo, values: Array[Value]) String {
    let code = ir.code()
    let rett = ir_type(info.rett_eax() ? type_void(ir.build))
    let rett_void = rett == "void"

    let ir_values = array[String]{}
    each values as i, value {
        ir_values.push(ir_value(ir, value))
    }

    let var = ""
    code.append_str("  ")
    if !rett_void {
        var = ir.var()
        code.append_str(var)
        code.append_str(" = ")
    }
    code.append_str("call ")
    code.append_str(rett)
    code.append_str(" ")

    if info.infinite_args {
        let args = info.args
        code.append_str("(")
        each args as i, type {
            if i > 0 : code.append_str(", ")
            code.append_str(ir_type(type))
        }
        code.append_str(", ...) ")
    }
    code.append_str(on)
    code.append_str("(")
    each ir_values as i, value {
        if i > 0 : code.append_str(", ")
        let v = values.get(i) ! continue
        code.append_str(ir_type(v.rett))
        code.append_str(" ")
        code.append_str(value)
    }
    code.append_str(")\n")

    return var
}

fn ir_memcpy(ir: IR, from: String, to: String, len: String) {
    let code = ir.code()
    code.append_str("  call void @llvm.memcpy.p0.p0.i64(ptr ")
    code.append_str(to)
    code.append_str(", ptr ")
    code.append_str(from)
    code.append_str(", i64 ")
    code.append_str(len)
    code.append_str(", i1 0)\n")
}

fn ir_op(ir: IR, left: String, right: String, op: int, rett: Type) String {

    let is_float = rett.is_float()
    let ir_type = ir_type(rett)
    let var = ir.var()
    let code = ir.code()

    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = ")
    if op == op_add : code.append_str(is_float ? "fadd " : "add ")
    else if op == op_sub : code.append_str(is_float ? "fsub " : "sub ")
    else if op == op_mul : code.append_str(is_float ? "fmul " : "mul ")
    else if op == op_div {
        if is_float : code.append_str("fdiv ")
        else if rett.is_signed : code.append_str("sdiv ")
        else : code.append_str("udiv ")
    }
    else if op == op_mod {
        if is_float : code.append_str("frem ")
        else if rett.is_signed : code.append_str("srem ")
        else : code.append_str("urem ")
    }
    else if op == op_bit_and : code.append_str("and ")
    else if op == op_bit_or : code.append_str("or ")
    else if op == op_bit_xor : code.append_str("xor ")
    else if op == op_shl : code.append_str("shl ")
    else if op == op_shr : code.append_str("lshr ")
    else : ir.error("Unknown IR math operation: " + op + " (bug)")
    code.append_str(ir_type)
    code.append_str(" ")
    code.append_str(left)
    code.append_str(", ")
    code.append_str(right)
    code.append_str("\n")

    return var
}

fn ir_compare(ir: IR, op: int, left: String, right: String, type: Type) String {
    let var = ir.var()
    let code = ir.code()
    let is_signed = type.is_signed
    let is_float = type.is_float()

    let sign = is_float ? "oeq" : "eq"
    if op == op_ne : sign = is_float ? "one" : "ne"
    else if op == op_lt {
        if is_float : sign = "olt"
        else if is_signed : sign = "slt"
        else : sign = "ult"
    }else if op == op_lte {
        if is_float : sign = "ole"
        else if is_signed : sign = "sle"
        else : sign = "ule"
    } else if op == op_gt {
        if is_float : sign = "ogt"
        else if is_signed : sign = "sgt"
        else : sign = "ugt"
    } else if op == op_gte {
        if is_float : sign = "oge"
        else if is_signed : sign = "sge"
        else : sign = "uge"
    }

    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = ")
    code.append_str(is_float ? "fcmp " : "icmp ")
    code.append_str(sign)
    code.append_str(" ")
    code.append_str(ir_type(type))
    code.append_str(" ")
    code.append_str(left)
    code.append_str(", ")
    code.append_str(right)
    code.append_str("\n")

    return var
}

fn ir_and_or(ir: IR, op: int, b_current: IRBlock, left: String, b_right: IRBlock, right: String, b_last: IRBlock) String {

    let is_or = op == op_or

    let b_after = ir.func().new_block("and_or_after")

    if is_or : ir_cond_jump(ir, left, b_after, b_right)
    else : ir_cond_jump(ir, left, b_right, b_after)

    ir.set_block(b_last)
    ir_jump(ir, b_after)

    ir.set_block(b_after)
    return ir_phi(ir, is_or ? "true" : "false", b_current, right, b_last, "i1")
}

fn ir_phi(ir: IR, v1: String, b1: IRBlock, v2: String, b2: IRBlock, type: String) String {
    let var = ir.var()
    let code = ir.code()

    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = phi ")
    code.append_str(type)
    code.append_str(" [ ")
    code.append_str(v1)
    code.append_str(", %")
    code.append_str(b1.name)
    code.append_str(" ], [ ")
    code.append_str(v2)
    code.append_str(", %")
    code.append_str(b2.name)
    code.append_str(" ]\n")

    return var
}

fn ir_cast(ir: IR, val: String, from: Type, to: Type) String {

    let result = val
    let code = ir.code()

    let ir_from = ir_type(from)
    let ir_to = ir_type(to)

    let ptr_int_type = "i64"

    if from.is_pointer && !to.is_pointer {
        // Ptr to int
        let var = ir.var()
        let int_type = ir_type_int(to.size())
        code.append_str("  ")
        code.append_str(var)
        code.append_str(" = ptrtoint ptr ")
        code.append_str(result)
        code.append_str(" to ")
        code.append_str(int_type)
        code.append_str("\n")
        result = var

        if(to.is_float()){
            let var = ir.var()
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = uitofp ")
            code.append_str(int_type)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ")
            code.append_str(ir_to)
            code.append_str("\n")
            result = var
        }

    } else if (!from.is_pointer) {

        let from_int = from.is_int() || from.is_bool()
        let from_float = !from_int

        let to_int = to.is_pointer || to.is_int() || to.is_bool()
        let to_float = !to_int

        if from.size() < to.size() {
            // Ext
            let var = ir.var()
            let new_type = from_int ? ir_type_int(to.size()) : ir_type_float(to.size())
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = ")
            if from_int : code.append_str(from.is_signed ? "sext" : "zext")
            else : code.append_str("fpext")
            code.append_str(" ")
            code.append_str(ir_from)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ")
            code.append_str(new_type)
            code.append_str("\n")
            ir_from = new_type
            result = var
        } else if from.size() > to.size() {
            // Trunc
            let var = ir.var()
            let new_type = from_int ? ir_type_int(to.size()) : ir_type_float(to.size())
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = ")
            code.append_str(from_int ? "trunc" : "fptrunc")
            code.append_str(" ")
            code.append_str(ir_from)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ")
            code.append_str(new_type)
            code.append_str("\n")
            ir_from = new_type
            result = var
        }
        if to.is_pointer {
            if from_float {
                let var = ir.var()
                code.append_str("  ")
                code.append_str(var)
                code.append_str(" = fptoui ")
                code.append_str(ir_from)
                code.append_str(" ")
                code.append_str(result)
                code.append_str(" to ")
                code.append_str(ptr_int_type)
                code.append_str("\n")
                result = var
                ir_from = ptr_int_type
            }

            let var = ir.var()
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = inttoptr ")
            code.append_str(ir_from)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ptr\n")
            result = var
        } else if from_int && to_float {
            let var = ir.var()
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = ")
            code.append_str(from.is_signed ? "sitofp" : "uitofp")
            code.append_str(" ")
            code.append_str(ir_from)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ")
            code.append_str(ir_to)
            code.append_str("\n")
            result = var
        } else if from_float && to_int {
            let var = ir.var()
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = ")
            code.append_str(to.is_signed ? "fptosi" : "fptoui")
            code.append_str(" ")
            code.append_str(ir_from)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ")
            code.append_str(ir_to)
            code.append_str("\n")
            result = var
        }
    }

    return result
}

fn ir_class_init(ir: IR, class: Class, init: Value, values: Map[Value]) String {

    let ir_values = map[String]{}
    each values as name, value {
        ir_values.set(name, ir_value(ir, value))
    }

    let ob = ir_value(ir, init) 

    each ir_values as name, value {
        let prop = class.props.get(name) ! continue
        let gep = ir_gep(ir, ob, prop.offset)
        ir_store(ir, gep, value, ir_type(prop.type))
    }

    return ob
}
