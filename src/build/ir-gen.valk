
fn ir_jump(ir: IR, block: IRBlock) {
    let code = ir.code()
    code.append_str("  br label %");
    code.append_str(block.name);
    code.append_str("\n");
}
fn ir_cond_jump(ir: IR, cond: String, block1: IRBlock, block2: IRBlock) {
    let code = ir.code()
    code.append_str("  br i1 ");
    code.append_str(cond);
    code.append_str(", label %");
    code.append_str(block1.name);
    code.append_str(", label %");
    code.append_str(block2.name);
    code.append_str("\n");
}

fn ir_store(ir: IR, var: String, val: String, type: String) {
    let code = ir.code()
    code.append_str("  store ")
    code.append_str(type)
    code.append_str(" ")
    code.append_str(val)
    code.append_str(", ptr ")
    code.append_str(var)
    code.append_str(", align 8\n")
}
fn ir_load(ir: IR, from: String, type: String) String {
    let var = ir.var()
    let code = ir.code()
    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = load ")
    code.append_str(type)
    code.append_str(", ptr ")
    code.append_str(from)
    code.append_str(", align 8\n")
    return var
}

fn ir_ret(ir: IR, val: String, type: String) {
    let code = ir.code()
    code.append_str("  ret ")
    code.append_str(type)
    code.append_str(" ")
    code.append_str(val)
    code.append_str("\n")
}
fn ir_ret_void(ir: IR) {
    let code = ir.code()
    code.append_str("  ret void\n")
}
fn ir_gep(ir: IR, on: String, offset: uint) String {
    let var = ir.var()
    let code = ir.code()
    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = getelementptr i8, ptr ")
    code.append_str(on)
    code.append_str(", i32 ")
    code.append_str(offset)
    code.append_str("\n")
    return var
}
fn ir_gep_typed(ir: IR, on: String, type: String, offset: String) String {
    let var = ir.var()
    let code = ir.code()
    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = getelementptr ")
    code.append_str(type)
    code.append_str(", ptr ")
    code.append_str(on)
    code.append_str(", i32 ")
    code.append_str(offset)
    code.append_str("\n")
    return var
}

fn ir_func_ptr(ir: IR, func: Func) String {
    ir_check_func_definition(ir, func)
    return "@" + func.export_name
}

fn ir_call(ir: IR, on: String, info: FuncInfo, values: Array[Value]) String {
    let code = ir.code()
    let rett = ir_type(info.rett_eax() ? type_void(ir.build))
    let rett_void = rett == "void"

    let ir_values = array[String]{}
    each values as i, value {
        ir_values.push(ir_value(ir, value))
    }

    let var = ""
    code.append_str("  ")
    if !rett_void {
        var = ir.var()
        code.append_str(var)
        code.append_str(" = ")
    }
    code.append_str("call ")
    code.append_str(rett)
    code.append_str(" ")

    if info.infinite_args {
        let args = info.args
        code.append_str("(")
        each args as i, type {
            if i > 0 : code.append_str(", ")
            code.append_str(ir_type(type))
        }
        code.append_str(", ...) ")
    }
    code.append_str(on)
    code.append_str("(")
    each ir_values as i, value {
        if i > 0 : code.append_str(", ")
        let v = values.get(i) ! continue
        code.append_str(ir_type(v.rett))
        code.append_str(" ")
        code.append_str(value)
    }
    code.append_str(")\n")

    return var
}

fn ir_memcpy(ir: IR, from: String, to: String, len: String) {
    let code = ir.code()
    code.append_str("  call void @llvm.memcpy.p0.p0.i64(ptr ")
    code.append_str(to)
    code.append_str(", ptr ")
    code.append_str(from)
    code.append_str(", i64 ")
    code.append_str(len)
    code.append_str(", i1 0)\n")
}

fn ir_op(ir: IR, left: String, right: String, op: int, rett: Type) String {

    let is_float = rett.is_float()
    let ir_type = ir_type(rett)
    let var = ir.var()
    let code = ir.code()

    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = ")
    if op == op_add : code.append_str(is_float ? "fadd " : "add ")
    else if op == op_sub : code.append_str(is_float ? "fsub " : "sub ")
    else if op == op_mul : code.append_str(is_float ? "fmul " : "mul ")
    else if op == op_div {
        if is_float : code.append_str("fdiv ")
        else if rett.is_signed : code.append_str("sdiv ")
        else : code.append_str("udiv ")
    }
    else if op == op_mod {
        if is_float : code.append_str("frem ")
        else if rett.is_signed : code.append_str("srem ")
        else : code.append_str("urem ")
    }
    else if op == op_bit_and : code.append_str("and ")
    else if op == op_bit_or : code.append_str("or ")
    else if op == op_bit_xor : code.append_str("xor ")
    else if op == op_shl : code.append_str("shl ")
    else if op == op_shr : code.append_str("lshr ")
    else : ir.error("Unknown IR math operation: " + op + " (bug)")
    code.append_str(ir_type);
    code.append_str(" ");
    code.append_str(left);
    code.append_str(", ");
    code.append_str(right);
    code.append_str("\n");

    return var;
}

fn ir_compare(ir: IR, op: int, left: String, right: String, type: Type) String {
    let var = ir.var()
    let code = ir.code()
    let is_signed = type.is_signed
    let is_float = type.is_float()

    let sign = is_float ? "oeq" : "eq"
    if op == op_ne : sign = is_float ? "one" : "ne"
    else if op == op_lt {
        if is_float : sign = "olt"
        else if is_signed : sign = "slt"
        else : sign = "ult"
    }else if op == op_lte {
        if is_float : sign = "ole"
        else if is_signed : sign = "sle"
        else : sign = "ule"
    } else if op == op_gt {
        if is_float : sign = "ogt"
        else if is_signed : sign = "sgt"
        else : sign = "ugt"
    } else if op == op_gte {
        if is_float : sign = "oge"
        else if is_signed : sign = "sge"
        else : sign = "uge"
    }

    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = ")
    code.append_str(is_float ? "fcmp " : "icmp ")
    code.append_str(sign)
    code.append_str(" ")
    code.append_str(type)
    code.append_str(" ")
    code.append_str(left)
    code.append_str(", ")
    code.append_str(right)
    code.append_str("\n")

    return var
}