
fn ir_comment(ir: IR, text: String) {
    let code = ir.code()
    code.append_str("; ")
    code.append_str(text)
    code.append_str("\n")
}
fn ir_jump(ir: IR, block: IRBlock) {
    let code = ir.code()
    code.append_str("  br label %")
    code.append_str(block.name)
    code.append_str("\n")
}
fn ir_cond_jump(ir: IR, cond: String, block1: IRBlock, block2: IRBlock) {
    let code = ir.code()
    code.append_str("  br i1 ")
    code.append_str(cond)
    code.append_str(", label %")
    code.append_str(block1.name)
    code.append_str(", label %")
    code.append_str(block2.name)
    code.append_str("\n")
}

fn ir_store(ir: IR, var: String, val: String, type: String) {
    let code = ir.code()
    code.append_str("  store ")
    code.append_str(type)
    code.append_str(" ")
    code.append_str(val)
    code.append_str(", ptr ")
    code.append_str(var)
    code.append_str(", align 8\n")
}
fn ir_load(ir: IR, from: String, type: String) String {
    let var = ir.var()
    let code = ir.code()
    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = load ")
    code.append_str(type)
    code.append_str(", ptr ")
    code.append_str(from)
    code.append_str(", align 8\n")
    return var
}

fn ir_ret(ir: IR, val: String, type: String) {
    let code = ir.code()
    code.append_str("  ret ")
    code.append_str(type)
    code.append_str(" ")
    code.append_str(val)
    code.append_str("\n")
}
fn ir_ret_void(ir: IR) {
    let code = ir.code()
    code.append_str("  ret void\n")
}
fn ir_gep(ir: IR, on: String, offset: int) String {
    let var = ir.var()
    let code = ir.code()
    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = getelementptr i8, ptr ")
    code.append_str(on)
    code.append_str(", i32 ")
    code.append_str(offset)
    code.append_str("\n")
    return var
}
fn ir_gep_typed(ir: IR, on: String, type: String, offset: String, offset_type: String) String {
    let var = ir.var()
    let code = ir.code()
    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = getelementptr ")
    code.append_str(type)
    code.append_str(", ptr ")
    code.append_str(on)
    code.append_str(", ")
    code.append_str(offset_type)
    code.append_str(" ")
    code.append_str(offset)
    code.append_str("\n")
    return var
}

fn ir_func_ptr(ir: IR, func: Func) String {
    ir_check_func_definition(ir, func)
    return "@" + func.export_name
}

fn ir_call(ir: IR, on: String, info: FuncInfo, values: Array[String]) String {
    let code = ir.code()
    let rett = ir_type(info.rett_eax() ? type_void(ir.build))
    let rett_void = rett == "void"
    let arg_types = info.args
    let rett_types = info.rett_types

    let var = ""
    code.append_str("  ")
    if !rett_void {
        var = ir.var()
        code.append_str(var)
        code.append_str(" = ")
    }
    code.append_str("call ")
    code.append_str(rett)
    code.append_str(" ")

    if info.infinite_args {
        code.append_str("(")
        each arg_types as i, type {
            if i > 0 : code.append_str(", ")
            code.append_str(ir_type(type))
        }
        each rett_types as i, type {
            if i == 0 && type.fits_eax() : continue
            if i > 0 || arg_types.length > 0 : code.append_str(", ")
            code.append_str("ptr")
        }
        code.append_str(", ...) ")
    }
    code.append_str(on)
    code.append_str("(")
    let rett_i : uint = 0
    each values as i, value {
        if i > 0 : code.append_str(", ")
        let type = arg_types.get(i) ? <{
            if info.infinite_args {
                let type = arg_types.get(arg_types.length - 1) ? null
                if isset(type) : return type
            }
            let rett = rett_types.get(rett_i++) ! break
            if rett_i == 1 && rett.fits_eax() : rett = rett_types.get(rett_i++) ! break
            return type_ptr(ir.build)
        }
        code.append_str(ir_type(type))
        code.append_str(" ")
        code.append_str(value)
    }
    code.append_str(")\n")

    return var
}

fn ir_memcpy(ir: IR, from: String, to: String, len: String) {
    let code = ir.code()
    code.append_str("  call void @llvm.memcpy.p0.p0.i64(ptr ")
    code.append_str(to)
    code.append_str(", ptr ")
    code.append_str(from)
    code.append_str(", i64 ")
    code.append_str(len)
    code.append_str(", i1 0)\n")
}

fn ir_op(ir: IR, left: String, right: String, op: int, rett: Type) String {

    let is_float = rett.is_float()
    let ir_type = ir_type(rett)
    let var = ir.var()
    let code = ir.code()

    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = ")
    if op == op_add : code.append_str(is_float ? "fadd " : "add ")
    else if op == op_sub : code.append_str(is_float ? "fsub " : "sub ")
    else if op == op_mul : code.append_str(is_float ? "fmul " : "mul ")
    else if op == op_div {
        if is_float : code.append_str("fdiv ")
        else if rett.is_signed : code.append_str("sdiv ")
        else : code.append_str("udiv ")
    }
    else if op == op_mod {
        if is_float : code.append_str("frem ")
        else if rett.is_signed : code.append_str("srem ")
        else : code.append_str("urem ")
    }
    else if op == op_bit_and : code.append_str("and ")
    else if op == op_bit_or : code.append_str("or ")
    else if op == op_bit_xor : code.append_str("xor ")
    else if op == op_shl : code.append_str("shl ")
    else if op == op_shr : code.append_str("lshr ")
    else : ir.error("Unknown IR math operation: " + op + " (bug)")
    code.append_str(ir_type)
    code.append_str(" ")
    code.append_str(left)
    code.append_str(", ")
    code.append_str(right)
    code.append_str("\n")

    return var
}

fn ir_compare(ir: IR, op: int, left: String, right: String, type: Type) String {
    let var = ir.var()
    let code = ir.code()
    let is_signed = type.is_signed
    let is_float = type.is_float()

    let sign = is_float ? "oeq" : "eq"
    if op == op_ne : sign = is_float ? "one" : "ne"
    else if op == op_lt {
        if is_float : sign = "olt"
        else if is_signed : sign = "slt"
        else : sign = "ult"
    }else if op == op_lte {
        if is_float : sign = "ole"
        else if is_signed : sign = "sle"
        else : sign = "ule"
    } else if op == op_gt {
        if is_float : sign = "ogt"
        else if is_signed : sign = "sgt"
        else : sign = "ugt"
    } else if op == op_gte {
        if is_float : sign = "oge"
        else if is_signed : sign = "sge"
        else : sign = "uge"
    }

    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = ")
    code.append_str(is_float ? "fcmp " : "icmp ")
    code.append_str(sign)
    code.append_str(" ")
    code.append_str(ir_type(type))
    code.append_str(" ")
    code.append_str(left)
    code.append_str(", ")
    code.append_str(right)
    code.append_str("\n")

    return var
}

fn ir_and_or(ir: IR, op: int, b_current: IRBlock, left: String, b_right: IRBlock, right: String, b_last: IRBlock) String {

    let is_or = op == op_or

    let b_after = ir.func().new_block("and_or_after")

    if is_or : ir_cond_jump(ir, left, b_after, b_right)
    else : ir_cond_jump(ir, left, b_right, b_after)

    ir.set_block(b_last)
    ir_jump(ir, b_after)

    ir.set_block(b_after)
    return ir_phi(ir, is_or ? "true" : "false", b_current, right, b_last, "i1")
}

fn ir_phi(ir: IR, v1: String, b1: IRBlock, v2: String, b2: IRBlock, type: String) String {
    let var = ir.var()
    let code = ir.code()

    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = phi ")
    code.append_str(type)
    code.append_str(" [ ")
    code.append_str(v1)
    code.append_str(", %")
    code.append_str(b1.name)
    code.append_str(" ], [ ")
    code.append_str(v2)
    code.append_str(", %")
    code.append_str(b2.name)
    code.append_str(" ]\n")

    return var
}

fn ir_phi_many(ir: IR, values: Array[String], blocks: Array[IRBlock], type: String) String {
    let var = ir.var()
    let code = ir.code()

    code.append_str("  ")
    code.append_str(var)
    code.append_str(" = phi ")
    code.append_str(type)
    code.append_str(" ")
    each values as i, v {
        let block = blocks.get(i) ! break
        if i > 0 : code.append_str(", ")
        code.append_str("[ ")
        code.append_str(v)
        code.append_str(", %")
        code.append_str(block.name)
        code.append_str(" ]")
    }
    code.append_str("\n")

    return var
}

fn ir_cast(ir: IR, val: String, from: Type, to: Type) String {

    let result = val
    let code = ir.code()

    let ir_from = ir_type(from)
    let ir_to = ir_type(to)

    let ptr_int_type = "i64"

    if from.is_pointer && !to.is_pointer {
        // Ptr to int
        let var = ir.var()
        let int_type = ir_type_int(to.size())
        code.append_str("  ")
        code.append_str(var)
        code.append_str(" = ptrtoint ptr ")
        code.append_str(result)
        code.append_str(" to ")
        code.append_str(int_type)
        code.append_str("\n")
        result = var

        if(to.is_float()){
            let var = ir.var()
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = uitofp ")
            code.append_str(int_type)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ")
            code.append_str(ir_to)
            code.append_str("\n")
            result = var
        }

    } else if (!from.is_pointer) {

        let from_int = from.is_int() || from.is_bool()
        let from_float = !from_int

        let to_int = to.is_pointer || to.is_int() || to.is_bool()
        let to_float = !to_int

        if from.size() < to.size() {
            // Ext
            let var = ir.var()
            let new_type = from_int ? ir_type_int(to.size()) : ir_type_float(to.size())
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = ")
            if from_int : code.append_str(from.is_signed ? "sext" : "zext")
            else : code.append_str("fpext")
            code.append_str(" ")
            code.append_str(ir_from)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ")
            code.append_str(new_type)
            code.append_str("\n")
            ir_from = new_type
            result = var
        } else if from.size() > to.size() {
            // Trunc
            let var = ir.var()
            let new_type = from_int ? ir_type_int(to.size()) : ir_type_float(to.size())
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = ")
            code.append_str(from_int ? "trunc" : "fptrunc")
            code.append_str(" ")
            code.append_str(ir_from)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ")
            code.append_str(new_type)
            code.append_str("\n")
            ir_from = new_type
            result = var
        }
        if to.is_pointer {
            if from_float {
                let var = ir.var()
                code.append_str("  ")
                code.append_str(var)
                code.append_str(" = fptoui ")
                code.append_str(ir_from)
                code.append_str(" ")
                code.append_str(result)
                code.append_str(" to ")
                code.append_str(ptr_int_type)
                code.append_str("\n")
                result = var
                ir_from = ptr_int_type
            }

            let var = ir.var()
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = inttoptr ")
            code.append_str(ir_from)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ptr\n")
            result = var
        } else if from_int && to_float {
            let var = ir.var()
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = ")
            code.append_str(from.is_signed ? "sitofp" : "uitofp")
            code.append_str(" ")
            code.append_str(ir_from)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ")
            code.append_str(ir_to)
            code.append_str("\n")
            result = var
        } else if from_float && to_int {
            let var = ir.var()
            code.append_str("  ")
            code.append_str(var)
            code.append_str(" = ")
            code.append_str(to.is_signed ? "fptosi" : "fptoui")
            code.append_str(" ")
            code.append_str(ir_from)
            code.append_str(" ")
            code.append_str(result)
            code.append_str(" to ")
            code.append_str(ir_to)
            code.append_str("\n")
            result = var
        }
    }

    return result
}

fn ir_class_init(ir: IR, class: Class, init: Value, values: Map[Value]) String {

    ir_define_vtable(ir, class)

    let ir_values = Map[String].new()
    each values as name, value {
        ir_values.set(name, ir_value(ir, value))
    }

    let b = ir.build
    let ob = ir_value(ir, init) 

    if class.type == ct_class {
        // let gtable = class.vtable_index_g;
        // if !isset(gtable) : ir.error("Missing class gc vtable index (bug)")

        ir_comment(ir, "SET VTABLE INDEX")
        let gep = ir_gep(ir, ob, -2)
        // let index = ir_global_load(ir, gtable)
        ir_store(ir, gep, class.gctable_index, "i16")
    }

    each ir_values as name, value {
        ir_comment(ir, "SET PROP: " + name)
        let prop = class.props.get(name) ! continue
        let gep = ir_gep(ir, ob, prop.offset)
        ir_store(ir, gep, value, ir_type(prop.type))
    }

    return ob
}

fn ir_gc_update_prop(ir: IR, on: String, prop_ref: String, new_value: String) String {
    let b = ir.build

    let state_g = b.valk_global("gc", "color_state")
    ir_check_global_definition(ir, state_g, true)
    let type_u32 = b.valk_type("type", "u32")
    let type_ptr = b.valk_type("type", "ptr")

    // Load on-color
    let on_color_gep = ir_gep_typed(ir, on, "i32", "-2", "i32")
    let on_color = ir_load(ir, on_color_gep, "i32")

    // Blocks
    let b_current = ir.block()
    let func = ir.func()
    let b_code = func.new_block("if_not_blank")
    let b_shared = func.new_block("if_shared")
    let b_not_shared = func.new_block("if_not_shared")
    let b_has_old = func.new_block("if_has_old_value")
    let b_colors_eq = func.new_block("if_colors_eq")
    let b_after = func.new_block("after_not_blank")

    // On color != blank
    let comp_on = ir_compare(ir, op_ne, on_color, "0", type_u32)
    ir_cond_jump(ir, comp_on, b_code, b_after)
    ir.set_block(b_code)

    // If shared
    let comp_is_shared = ir_compare(ir, op_eq, on_color, "2", type_u32)
    ir_cond_jump(ir, comp_is_shared, b_shared, b_not_shared)
    ir.set_block(b_shared)

    // call gc:share
    let share = b.valk_func("gc", "share_item_null_check")
    let share_fptr = vgen_func_ptr(share)
    let share_values = array[String]{ new_value }
    let share_call = ir_call(ir, ir_value(ir, share_fptr), share.info(), share_values)

    ir_jump(ir, b_after)

    // Disable color from on-item
    ir.set_block(b_not_shared)
    let state = ir_load(ir, state_g.ir_name, "ptr")
    let state_gep = ir_gep_typed(ir, state, "i8", on_color, "i32")
    ir_store(ir, state_gep, "0", "i8")

    // Load old value
    let oldv = ir_load(ir, prop_ref, "ptr")
    let comp_not_null = ir_compare(ir, op_ne, oldv, "null", type_ptr)
    ir_cond_jump(ir, comp_not_null, b_has_old, b_after)
    ir.set_block(b_has_old)

    // Load old-color
    let oldv_color_gep = ir_gep_typed(ir, oldv, "i32", "-2", "i32")
    let oldv_color = ir_load(ir, on_color_gep, "i32")

    // On color == Old value color
    let comp_color_eq = ir_compare(ir, op_eq, on_color, oldv_color, type_u32)
    ir_cond_jump(ir, comp_color_eq, b_colors_eq, b_after)

    ir.set_block(b_colors_eq)
    // Add old value to still-used list
    let link = b.valk_func("gc", "add_still_used")
    let fptr = vgen_func_ptr(link)
    let values = array[String]{ oldv }
    let call = ir_call(ir, ir_value(ir, fptr), link.info(), values)
    
    // Jump to after block
    ir_jump(ir, b_after)
    ir.set_block(b_after)

    return new_value;
}

fn ir_global(ir: IR, g: Global) String {
    ir_check_global_definition(ir, g, true)
    return g.ir_name
}
fn ir_global_load(ir: IR, g: Global) String {
    let ref = ir_global(ir, g)
    if g.is_const : return ref
    let type = g.type
    if !isset(type) : ir.error("Missing global type (bug)")
    return ir_load(ir, ref, ir_type(type))
}
