
use valk:fs
use valk:time
use valk:gc
use helper

@ignore_access

fn run_build(args: Array[String], dirs: Array[String], files: Array[String], modtimes: Map[uint]) {

    let b = init(args.copy()) !? <{
        println(EMSG)
        return null
    }

    if isset(b) {
        b.is_watch = true
        await co run(b) _
        each b.nsc_by_dir as nsc, dir {
            dirs.append(dir, true)
        }
        each b.fc_by_path as fc, path {
            files.append(path, true)
            modtimes.set(path, helper:modified_time(path) !? 0)
        }
    }
}

fn build_watch(args: Array[String], arg_files: Array[String], dir: ?String) {

    // Test leak
    // gc:verify = true

    let files = arg_files.copy()
    let dirs = Array[String]{}
    if isset(dir) : dirs.append(dir)

    let modtimes = Map[uint]{}

    while true {
        println("> Files changed - build")
        println((gc:mem_usage_shared / 1024 / 1024) + "mb")
        // println((gc:mem_shared) + "b (s)")

        run_build(args, dirs, files, modtimes)

        // Clean up + Leak test
        gc:collect()

        // Find new files in directories
        if find_new_files(dirs, files, modtimes) : continue

        //
        if files.length == 0 {
            println("# No files to watch")
            exit(1)
        }

        // Watch for file changes
        let count = 0
        while true {
            if count++ % 3 == 0 {
                if find_new_files(dirs, files, modtimes) : break
            }
            let has_changes = false
            each files as file, i {
                let mod = helper:modified_time(file) ! {
                    println("> File removed: " + file)
                    files.remove(i--)
                    has_changes = true
                    break
                }
                if mod != modtimes.get(file) !? 0 {
                    modtimes.set(file, mod)
                    has_changes = true
                    break
                }
            }
            if has_changes : break
            time:sleep_ms(500)
        }
    }
}

fn find_new_files(dirs: Array[String], files: Array[String], modtimes: Map[uint]) bool {
    let count = files.length
    each dirs as dir {
        let dfiles = fs:files_in(dir, false, true, false)
        each dfiles as path {
            if path.ends_with(".valk") && !files.contains(path) {
                files.append(path)
                modtimes.set(path, helper:modified_time(path) !? 0)
                println("> New file: " + path)
            }
        }
    }
    return files.length > count
}
