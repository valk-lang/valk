
use valk:fs
use valk:time
use helper

fn build_watch(args: Array[String], arg_files: Array[String], dir: ?String) {

    let files = arg_files.copy()
    let dirs = Array[String]{}
    if isset(dir) : dirs.append(dir)

    let modtimes = Map[uint]{}

    while true {
        println("> Files changed - build")

        let b = init(args.copy()) !? <{
            println(EMSG)
            return null
        }

        if isset(b) {
            b.is_watch = true
            let t = co run(b)
            await t _
            each b.nsc_by_dir as nsc, dir {
                dirs.append(dir, true)
            }
            each b.fc_by_path as fc, path {
                files.append(path, true)
                modtimes.set(path, helper:modified_time(path) !? 0)
            }
        }

        // Find new files in directories
        if find_new_files(dirs, files, modtimes) : continue

        //
        if files.length == 0 {
            println("# No files to watch")
            exit(1)
        }

        // Watch for file changes
        let count = 0
        while true {
            if count++ % 3 == 0 {
                if find_new_files(dirs, files, modtimes) : break
            }
            let has_changes = false
            each files as file, i {
                let mod = helper:modified_time(file) ! {
                    println("> File removed: " + file)
                    files.remove(i--)
                    has_changes = true
                    break
                }
                if mod != modtimes.get(file) !? 0 {
                    modtimes.set(file, mod)
                    has_changes = true
                    break
                }
            }
            if has_changes : break
            time:sleep_ms(300)
        }
    }
}

fn find_new_files(dirs: Array[String], files: Array[String], modtimes: Map[uint]) bool {
    let count = files.length
    each dirs as dir {
        let dfiles = fs:files_in(dir, false, true, false)
        each dfiles as path {
            if path.ends_with(".valk") && !files.contains(path) {
                files.append(path)
                modtimes.set(path, helper:modified_time(path) !? 0)
                println("> New file: " + path)
            }
        }
    }
    return files.length > count
}