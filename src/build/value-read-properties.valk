
fn value_read_array_init(p: Parser, scope: Scope, base: Value, sub_type: Type, size: uint) Value {

    let b = p.build
    let type_uint = b.valk_type("type", "uint")

    let prev_suggest = p.suggest_type
    p.suggest_type = sub_type

    let last_values : ?Array[Value] = null
    
    let values = Array[Value]{}
    while !p.next_word_is("}", true, true, true) {
        if p.sign_is(",") {
            p.tok(true, true, true)
            continue
        }
        if p.sign_is("...") {
            p.tok(true, true, true)
            if !isset(last_values) : p.error("No value to repeat")
            while values.length < size {
                let all = last_values
                if all.length == 0 : p.error("No value to repeat")
                each all as v {
                    if values.length == size : break
                    values.append(v)
                }
            }
            continue
        }

        if values.length == size : p.error("Too many values")

        p.assign_to = vgen_ptrv(base, sub_type, vgen_int(values.length, type_uint))
        let v = read_value(p, scope)
        let all = v.unroll()

        each all as v {
            if values.length == size : p.error("Too many values")
            v = v.try_convert(p.ctx, scope, sub_type)
            sub_type.compat_check(v.rett, p.ctx)
            values.append(v)
        }
        last_values = all
    }

    if values.length < size : p.error("Missing array values. Expected amount '%size', but found '%{values.length}'")

    p.suggest_type = prev_suggest

    let asize = values.length
    let atype = type_array(b, sub_type, asize)

    let v = vgen_array_init(p.ctx, scope, base, values, sub_type, atype)
    return vgen_this_but_that(v, base)
}
