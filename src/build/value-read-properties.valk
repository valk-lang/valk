
fn value_read_array_init(p: Parser, scope: Scope, base: ?Value, sub_type: ?Type, size: uint) Value {

    let b = p.build
    let type_uint = b.valk_type("type", "uint")

    // let sub_type = array_type.sub_type
    // if !isset(sub_type) : p.bug("Missing array type info")
    // let size = array_type.array_size

    let prev_suggest = p.suggest_type
    p.suggest_type = sub_type

    let last_values : ?Array[Value] = null
    
    let values = Array[Value]{}
    while !p.next_word_is("]", true, true, true) {
        if p.sign_is(",") {
            p.tok(true, true, true)
            continue
        }
        if p.sign_is("...") {
            if !isset(last_values) : p.error("No value to repeat")
            while values.length < size {
                let all = last_values
                each all as v {
                    if values.length == size : break
                    values.append(v)
                }
            }
            break
        }

        if size > 0 && values.length == size : p.error("Too many values")

        if isset(base) && isset(sub_type) : p.assign_to = vgen_ptrv(base, sub_type, vgen_int(values.length, type_uint))

        let v = read_value(p, scope)
        let all = v.unroll()

        each all as v {
            if size > 0 && values.length == size : p.error("Too many values")
            if !isset(sub_type) : sub_type = v.rett
            v = v.try_convert(p, scope, sub_type)
            sub_type.compat_check(v.rett, p)
            values.append(v)
        }
        last_values = all
    }

    if values.length < size : p.error("Missing array values. Expected '%size', but found '%{values.length}'")

    p.suggest_type = prev_suggest

    if !isset(sub_type) : p.error("Cannot determine the type for the array items")

    let asize = values.length
    let atype = type_array(b, sub_type, asize)
    if !isset(base) {
        let decl = Decl.new(atype, false)
        decl.name = "array"
        decl.is_mut = true
        scope.add_decl(decl)
        base = vgen_decl(decl)
    }

    let v = vgen_array_init(scope, base, values, sub_type, atype)
    return vgen_this_but_that(v, base)
}
