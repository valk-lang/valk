
value errh_break (1)
value errh_value (2)
value errh_ignore (3)

struct ErrorHandler {
    type: int
    on: Value
    err_check: Value
    scope: Scope
    decl_err: ?Decl (null)
    decl_msg: ?Decl (null)
}

fn value_error_handling(p: Parser, scope: Scope, on: Value, info: FuncInfo) Value {

    let b = p.build

    p.expect3("!", "!?", "_", true, true)
    // Ignore error 
    if p.word_is("_") {
        let v = vgen_error_code_reset(on)
        v.rett = type_void(b)
        return v
    }
    let expect_value = p.word_is("!?")

    // ?! (1,2)       => multi-value[this_or_that[err-check, right[x], on[x] ]] : right.rett
    // ! (1,2)        => this_but[cond-value[err-check, right], on] : void
    // ! return (1,2) => multi-value[this_but[cond-value[err-check, right[x]], on[x] ]] : on.rett

    // Handle error
    let sub = scope.sub_scope(sc_default)

    // Variables
    let g_err_code = b.valk_global("core", "error_code")
    let g_err_msg = b.valk_global("core", "error_msg")

    let decl_err = p.create_decl("E", g_err_code.get_type())
    let decl_msg = p.create_decl("EMSG", g_err_msg.get_type())
    decl_err.is_used = false
    decl_msg.is_used = false
    sub.set_idf(p, "E", Idf.for_decl(decl_err))
    sub.set_idf(p, "EMSG", Idf.for_decl(decl_msg))

    sub.ast.push(Token {
        type: tk_declare
        decl: decl_err
        value1: vgen_global(g_err_code)
    })
    sub.ast.push(Token {
        type: tk_declare
        decl: decl_msg
        value1: vgen_global(g_err_msg)
    })
    sub.ast.push(Token {
        type: tk_assign
        value1: vgen_global(g_err_code)
        value2: vgen_int(0, g_err_code.get_type())
    })

    // Err check
    let err_check = vgen_error_check(b)
    err_check.pre_value = on
    // err_check = vgen_error_code_reset(err_check)

    // Left / Right
    // let fcall = on.extract_func_call_value() ! p.error("Using error handling on a non-function call value")
    p.set_suggest(on.rett)
    let alt = read_inline_scope_value(p, sub)
    p.pop_suggest()

    if !expect_value {
        let v = vgen_this_but_that(vgen_cond_value(err_check, alt), on)
        if !alt.rett.is_none() : v.rett = type_void(b)
        return v
    }

    // Type check
    alt = vgen_unroll_inline_scope(alt)

    //
    let left_values = on.unroll()
    let right_values = alt.unroll()
    let result = Array[Value].new()

    each left_values as i, left {
        let right = right_values.get(i) ! continue

        let rett = left.rett
        right = right.try_convert(p.get_ds(), left.rett)
        if right.rett.nullable : rett = rett.get_nullable()
        rett.compat_check(right.rett, p)
        let v = vgen_this_that(err_check, right, left, rett)
        result.push(v)
    }

    return vgen_grouped_values(b, result)

    // let returns_void = on.rett.is_void()
    // let t = p.tok(true, true)

    // let g_code = b.valk_global("core", "error_code")
    // let g_msg = b.valk_global("core", "error_msg")
    // let g_code_type = g_code.type
    // if !isset(g_code_type) : p.error("Missing global type for error-code (bug)")
    // let err_check = vgen_error_check(b)

    // let decl_err: ?Decl = null
    // let decl_msg: ?Decl = null

    // let sign = p.word()
    // let sub = scope.sub_scope(sc_default)

    // if sign == "!" || sign == "?" {
    //     t = p.tok(true, true, false)
    //     if p.word_is("(") {
    //         p.expect("(", true, true)
    //         let name_err = p.read_word(true, true)
    //         let decl_err_ = Decl.new(b.valk_type("type", "u32"), false)
    //         decl_err_.name = name_err
    //         decl_err_.is_mut = true
    //         sub.set_idf(p, name_err, Idf.for_decl(decl_err_))
    //         p.add_decl(decl_err_)
    //         decl_err = decl_err_

    //         p.expect2(",", ")", true, true)
    //         if p.word_is(",") {
    //             let name_msg = p.read_word(true, true)
    //             let decl_msg_ = Decl.new(b.valk_type("type", "String"), false)
    //             decl_msg_.is_mut = true
    //             decl_msg_.name = name_msg
    //             sub.set_idf(p, name_msg, Idf.for_decl(decl_msg_))
    //             p.add_decl(decl_msg_)
    //             decl_msg = decl_msg_

    //             p.expect(")", true, true)
    //         }
    //         t = p.tok(true, true, false)
    //     }
    // }

    // if sign == "!" {
    //     let single = !p.sign_is("{")
    //     if !single : p.expect("{", true, true)
    //     read_ast(p, sub, single)
    //     if !sub.did_return : p.error("Expected the code after '!' to end with: return, exit, continue, break or throw")

    //     let errh = Value { 
    //         type: v_errh
    //         errh: ErrorHandler {
    //             type: errh_break
    //             on: fcall
    //             err_check: err_check
    //             scope: sub
    //             decl_err: decl_err
    //             decl_msg: decl_msg
    //         }
    //         rett: on.rett
    //     }

    //     let copies = Array[Value].new()
    //     each fcall_return_values as retv {
    //         let copy = vgen_wrap(retv)
    //         copy.pre_value = errh
    //         copies.push(copy)
    //     }

    //     return vgen_multi_return(b, errh, copies)

    // } else if sign == "?" {

    //     p.set_suggest(on.rett)
    //     let alt = read_value(p, sub)
    //     p.pop_suggest()

    //     let errh = Value { 
    //         type: v_errh
    //         errh: ErrorHandler {
    //             type: errh_value
    //             on: fcall
    //             err_check: err_check
    //             scope: sub
    //             decl_err: decl_err
    //             decl_msg: decl_msg
    //         }
    //         rett: on.rett
    //     }

    //     let on_values = on.unroll()
    //     let alt_values = alt.unroll()

    //     if alt_values.length != on_values.length : p.error("Right side of '?' must return the same amount of values as the function")

    //     let retts = Array[Type].new()
    //     let result_values = Array[Value].new()
    //     each on_values as i, onv {
    //         let altv = alt_values.get(i) ! p.error("Missing alternative value (bug)")

    //         let rett = onv.rett
    //         if altv.rett.nullable : rett = rett.get_nullable()
    //         altv = altv.try_convert(p.get_ds(), rett)
    //         rett.compat_check(altv.rett, p)
    //         retts.push(rett)

    //         let v = vgen_this_that(err_check, altv, onv, rett)
    //         v.pre_value = errh

    //         result_values.push(v)
    //     }

    //     errh.rett = type_multi(b, retts)

    //     return vgen_multi_return(b, errh, result_values)

    // } else if sign == "_" {
    //     if !returns_void : p.error("You can only ignore errors using '_' when the function has a 'void' return type. Return type is '" + on.rett + "'")
    //     return vgen_error_code_reset(on)
    // }
    // p.error("Missing error handler. Expected: '!', '?' or '_'. But found: '" + p.word() + "'")
}
