
value errh_break (1)
value errh_value (2)
value errh_ignore (3)

class ErrorHandler {
    type: int
    on: Value
    err_check: Value
    scope: Scope
    decl_err: ?Decl (null)
    decl_msg: ?Decl (null)
}

global errh_tokens : ?Array[String] (null)

fn value_error_handling(p: Parser, scope: Scope, on: Value, errors: Map[ERR_TYPE]) Value {

    if !on.can_error() : p.error("Error handler on a value that does not return errors")

    let b = p.build
    let ctx = p.ctx

    let tokens = errh_tokens ?? <{
        let list = Array[String]{ "!", "!?", "!>", "!!", "_", "->" }
        errh_tokens = list
        return list
    }
    p.expect_many(tokens, true, false)

    // Ignore error 
    if p.word_is("_") {
        let w = vgen_wrap(on)
        w.rett = type_void(b)
        return w
    }
    // Success handler
    if p.word_is("->") {
        return value_success_handler(p, scope, on)
    }
    // Ignore error 
    if p.word_is("!>") {
        return value_pass_handler(ctx, scope, on)
    }
    // Panic on error 
    if p.word_is("!!") {
        return value_panic_handler(p, scope, on, "Error at: " + p.clone_chunk().path_and_line())
    }

    let expect_value = p.word_is("!?")

    // Handle error
    let sub = scope.sub_scope(SCOPE.default)

    // Variables
    let code = on.func_err_code ?! ctx.error("Missing error code (bug)")
    let msg = on.func_err_msg ?! ctx.error("Missing error message (bug)")
    let w = vgen_wrap(code)
    w.rett = type_error(b, errors)
    sub.set_idf(p, "E", Idf.for_value(w))
    sub.set_idf(p, "EMSG", Idf.for_value(msg))
    sub.ast.append(tgen_statement(code))
    sub.ast.append(tgen_statement(msg))

    // Left return value
    let left = on.trim_errors()

    // Alternative value
    p.set_suggest(left.rett)
    let alt = read_inline_scope_value(p, sub)
    alt = vgen_unroll_inline_scope(alt)
    p.pop_suggest()

    if expect_value {
        alt = alt.try_convert(p.ctx, scope, left.rett)
        let matched_type = left.rett.match_nullable(alt.rett)
        matched_type.compat_check(alt.rett, p.ctx)
    }

    return vgen_error_handler(p.ctx, scope, on, left, alt, expect_value)
}

fn vgen_error_handler(ctx: Context, scope: Scope, on: Value, left: Value, alt: Value, merge_values: bool) Value {

    // ?! (1,2)       => multi-value[this_or_that[err-check, reset+alt[x], on[x] ]] : alt.rett
    // ! (1,2)        => this_but[cond-value[err-check, reset+alt], on] : void
    // ! return (1,2) => multi-value[this_but[cond-value[err-check, reset+alt[x]], on[x] ]] : on.rett

    let b = on.rett.build
    let err_check = vgen_error_check(b, on)

    if !merge_values {
        // {statement} ! ...code...
        let condv = vgen_cond_value(err_check, alt)

        // Code that exits
        if alt.rett.is_none() {
            return vgen_this_but_that(condv, left)
        }
        // Code that continues
        condv.rett = type_void(b)
        return condv
    }

    // Multi values
    return vgen_this_or_that(err_check, alt, left, alt.rett)
}

fn value_success_handler(p: Parser, scope: Scope, on: Value) Value {

    if !on.can_error() : p.error("Error handler on non-function call value (2): " + on.type)

    let left = on.trim_errors()
    let on_values = left.unroll()
    if on_values.length == 0 : p.error("You cannot use the '->' success handler on a function call that does not return a value")
    let multi = on_values.length > 1

    let expect_close_bracket = multi
    if multi : p.expect("(", true, true)
    else : expect_close_bracket = p.next_word_is("(", true, true, true)

    let b = p.build
    let decls = Array[Decl].new()
    let sub = scope.sub_scope(SCOPE.default)
    let if_scope = scope.sub_scope(SCOPE.if)

    each on_values as onv, i {
        if i > 0 : p.expect(",", true, true)
        p.expect_name(true, true)
        let name = p.word()

        let decl = Decl.new(onv.rett, false)
        decls.append(decl)
        sub.add_decl(decl)

        if_scope.set_idf(p, name, Idf.for_decl(decl))
        if_scope.ast.append(Token {
            type: AST.declare
            decl: decl
            value1: onv
        })
    }

    if expect_close_bracket : p.expect(")", true, true)

    let else_scope = scope.sub_scope(SCOPE.if)
    sub.ast.append(Token {
        type: AST.if
        value1: vgen_not(vgen_error_check(b, on))
        scope1: if_scope
        scope2: else_scope
    })

    p.expect2(":", "{", true, true)
    let single_line = p.word_is(":")

    read_ast(p, if_scope, single_line)

    return vgen_inline_scope(sub, type_void(b))
}

fn value_panic_handler(p: Parser, scope: Scope, on: Value, msg: String) Value {

    if !on.can_error() : p.error("Error handler on non-function call value (3): " + on.type)

    let b = p.build

    let sub = scope.sub_scope(SCOPE.default)
    let alt = vgen_inline_scope(sub, type_void(b))

    let panic_func = b.valk_func("core", "panic")
    let values = Array[Value]{ Str.new_value(msg, p.ctx) }
    let fptr = vgen_func_ptr(panic_func)
    let call = vgen_func_call(b, scope, fptr, values)

    sub.ast.append(Token {
        type: AST.statement
        value1: call
    })

    // Err check
    let err_check = vgen_error_check(b, on)
    let condv = vgen_cond_value(err_check, alt)
    return vgen_this_but_that(condv, on.trim_errors())
}

fn value_pass_handler(ctx: Context, scope: Scope, on: Value) Value {

    if !on.can_error() : ctx.error("Error handler on non-function call value (4): " + on.type)

    let b = ctx.build
    let func = ctx.getFunc()

    let sub = scope.sub_scope(SCOPE.default)
    let alt = vgen_inline_scope(sub, type_void(b))

    let values = Array[Value]{}
    each func.rett.unroll() as type {
        values.append(vgen_empty_value(type) ?! continue)
    }
    values.append(on.func_err_code ?! ctx.error("Missing error code (bug)"))
    values.append(on.func_err_msg ?! ctx.error("Missing error message (bug)"))
    ast_return_value(func, sub, vgen_grouped_values(b, values))

    // Err check
    let err_check = vgen_error_check(b, on)
    let condv = vgen_cond_value(err_check, alt)
    return vgen_this_but_that(condv, on.trim_errors())
}