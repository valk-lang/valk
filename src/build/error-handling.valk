
value errh_break (1)
value errh_value (2)
value errh_ignore (3)

struct ErrorHandler {
    type: int
    on: Value
    err_check: Value
    scope: Scope
    decl_err: ?Decl (null)
    decl_msg: ?Decl (null)
}

fn value_error_handling(p: Parser, scope: Scope, on: Value, info: FuncInfo) Value {

    let b = p.build

    p.expect3("!", "!?", "_", true, true)
    // Ignore error 
    if p.word_is("_") {
        let v = vgen_error_code_reset(on)
        v.rett = type_void(b)
        return v
    }
    let expect_value = p.word_is("!?")

    // ?! (1,2)       => multi-value[this_or_that[err-check, right[x], on[x] ]] : right.rett
    // ! (1,2)        => this_but[cond-value[err-check, right], on] : void
    // ! return (1,2) => multi-value[this_but[cond-value[err-check, right[x]], on[x] ]] : on.rett

    // Handle error
    let sub = scope.sub_scope(sc_default)

    // Variables
    let g_err_code = b.valk_global("core", "error_code")
    let g_err_msg = b.valk_global("core", "error_msg")

    let decl_err = p.create_decl("E", g_err_code.get_type())
    let decl_msg = p.create_decl("EMSG", g_err_msg.get_type())
    decl_err.is_used = false
    decl_msg.is_used = false
    sub.set_idf(p, "E", Idf.for_decl(decl_err))
    sub.set_idf(p, "EMSG", Idf.for_decl(decl_msg))

    sub.ast.push(Token {
        type: tk_declare
        decl: decl_err
        value1: vgen_global(g_err_code)
    })
    sub.ast.push(Token {
        type: tk_declare
        decl: decl_msg
        value1: vgen_global(g_err_msg)
    })
    sub.ast.push(Token {
        type: tk_assign
        value1: vgen_global(g_err_code)
        value2: vgen_int(0, g_err_code.get_type())
    })

    // Alternative value
    p.set_suggest(on.rett)
    let alt = read_inline_scope_value(p, sub)
    alt = vgen_unroll_inline_scope(alt)
    p.pop_suggest()

    if expect_value {
        alt = alt.try_convert(p.get_ds(), on.rett)
        let matched_type = on.rett.match_nullable(alt.rett)
        matched_type.compat_check(alt.rett, p)
    }

    return vgen_error_handler(on, alt, expect_value)
}

fn vgen_error_handler(on: Value, alt: Value, merge_values: bool) Value {

    let b = on.rett.build

    // Err check
    let err_check = vgen_error_check(b)
    err_check.pre_value = on

    // Conditional alt value
    // alt = vgen_unroll_inline_scope(alt)
    let condv = vgen_cond_value(err_check, alt)

    if !merge_values {
        if alt.rett.is_none() {
            let left_values = on.unroll()
            let result = Array[Value].new()
            each left_values as i, left {
                result.push(vgen_this_but_that(condv, left))
            }
            return vgen_grouped_values(b, result)
        }
        let v = vgen_this_but_that(condv, on)
        v.rett = type_void(b)
        return v
    }

    //
    let left_values = on.unroll()
    let right_values = alt.unroll()
    let result = Array[Value].new()

    each left_values as i, left {
        let right = right_values.get(i) ! b.error("Missing right-side error value (bug)")

        let rett = left.rett
        // right = right.try_convert(p.get_ds(), left.rett)
        if right.rett.nullable : rett = rett.get_nullable()
        // rett.compat_check(right.rett, p)
        let phi = vgen_phi(right, left, rett)
        phi.pre_value = condv
        result.push(phi)
    }

    return vgen_grouped_values(b, result)
}
