
struct Value {
    type: int
    func: ?Func (null)
    values: ?Array[Value] (null)
    string: String ("")
    decl: ?Decl (null)
    value1: ?Value (null)
    value2: ?Value (null)
    prop: ?Prop (null)
    rett: Type

    fn get_rett_class() Class !no_class {
        let class = this.rett.class
        if !isset(class) : throw no_class
        return class
    }

    fn assignable() bool {
        let type = this.type
        return type == v_decl || type == v_prop
    }
}

fn read_value(p: Parser, scope: Scope) Value {

    let b = p.build
    let v: ?Value = null
    let t = p.tok(true, true)

    if t == tok_word {
        let id = Id.read_full(p, p.word())
        let idf = scope.find_or_err(p, id)
        v = handle_idf(p, scope, idf)
    } else if t == tok_string {
        let body = p.word()
        body = body.sub_str(1, body.bytes - 2).unescape()
        v = vgen_string(b, body)
    }

    if !isset(v) {
        p.error("Unknown value/token: '" + p.word() + "'")
    }

    // Trailing characters
    t = p.tok(false, false, false)
    while t == tok_sign && (p.word_is(".") || p.word_is("(") || p.word_is("++") || p.word_is("--")) {
        t = p.tok(false, false)

        if p.word_is(".") {
            // Class properties
            v = value_prop_access(p, scope, v)
        } else if p.word_is("(") {
            // Function call
            v = value_func_call(p, scope, v)
        } else if p.word_is("++") || p.word_is("--") {
            // ++ / --
            p.error("TODO")
        }

        t = p.tok(false, false, false)
    }

    //
    return v
}

fn handle_idf(p: Parser, scope: Scope, idf: Idf) Value {
    
    let for = idf.for

    if for == idf_func {
        let func = idf.func
        if isset(func) {
            return Value {
                type: v_func_ptr
                func: func
                rett: type_func(func)
            }
        }
    }
    if for == idf_decl {
        let decl = idf.decl
        if isset(decl) {
            return vgen_decl(decl)
        }
    }

    p.error("Unhandled identifier type (type: " + for + ") (compiler bug)")
}

fn value_func_call(p: Parser, scope: Scope, on: Value) Value {

    let on_rett = on.rett
    let func_info = on_rett.func_info
    if !isset(func_info) {
        p.error("Function call on a non-function value")
    }

    let args = func_info.args
    let values = array[Value]{}
    let t = p.tok(true, true, false)
    while !p.sign_is(")") {
        let value = read_value(p, scope)
        let index = values.length
        let arg_type = args.get(0) ! p.error("Too many arguments. Function type: " + on_rett)
        arg_type.compat_check(value.rett, p)
        values.push(value)
    }

    if values.length < args.length {
        p.error("Not enough values to call this function. Function type: " + on_rett)
    }

    p.skip_body(")")
    return Value { type: 0, rett: type_void(p.build) }
}

fn value_prop_access(p: Parser, scope: Scope, on: Value) Value {
    let on_class = on.get_rett_class() ! p.error("Cannot access properties/functions on this type: " + on.rett)
    let name = p.read_word(false, false)
    let prop = on_class.props.get(name) ? null
    if isset(prop) {
        return vgen_prop(prop, on)
    }
    p.error("TODO class func")
}
