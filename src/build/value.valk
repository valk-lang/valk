
use helper
use valk:fs

class Value {
    type: int
    rett: Type
    //
    pre_value: ?Value (null)
    before: ?Array[Token] (null)
    ir_value: String ("")
    ir_value_assign: String ("")
    ir_block: String ("")
    //
    func: ?Func (null)
    issets: ?Array[Decl] (null)
    not_issets: ?Array[Decl] (null)
    values: ?Array[Value] (null)
    values_map: ?Map[Value] (null)
    unrolls: ?Array[Value] (null)
    func_err_code: ?Value (null)
    func_err_msg: ?Value (null)
    errh: ?ErrorHandler (null)
    string: String ("")
    string2: String ("")
    str: ?Str (null)
    decl: ?Decl (null)
    decl2: ?Decl (null)
    value1: ?Value (null)
    value2: ?Value (null)
    value3: ?Value (null)
    prop: ?Prop (null)
    bind_prop: ?Prop (null)
    global: ?Global (null)
    scope1: ?Scope (null)
    type1: ?Type (null)
    int: int (0)
    float: f64 (0)
    //
    bool1: bool (false)
    bool2: bool (false)
    //
    ir_value_cached: bool (false)
    ir_value_asign_cached: bool (false)
    skip_assign: bool (false)

    fn get_rett_class() Class !no_class {
        let class = this.rett.get_class() !? null
        if !isset(class) {
            let sub = this.rett.sub_type
            if isset(sub) : class = sub.get_class() !? null
            if !isset(class) : throw no_class
        }
        return class
    }

    fn before_ast() Array[Token] {
        let ast = this.before
        if !isset(ast) {
            let ast = Array[Token].new()
            this.before = ast
            return ast
        }
        return ast
    }

    fn assignable() bool {
        let type = this.type
        return type == VAL.decl || type == VAL.prop || type == VAL.ptrv || type == VAL.global || type == VAL.buffer
    }
    fn assignable_and_mutable() bool {
        let type = this.type
        if type == VAL.decl {
            let decl = this.decl
            if !isset(decl) : panic("Missing variable decl object (bug)")
            return decl.is_mut
        }
        return this.assignable()
    }

    fn trim_errors() Value {
        if this.type != VAL.func_call : return this
        let code = this.func_err_code
        let msg = this.func_err_msg
        if !isset(code) && !isset(msg) : return this
        let values = this.unroll().copy()
        if isset(code) : values.remove_value(code)
        if isset(msg) : values.remove_value(msg)
        return vgen_grouped_values(this.rett.build, values)
    }

    fn try_convert(ctx: Context, decl_scope: Scope, type: Type) Value {

        if type.is_void() : return this
        let vrett = this.rett
        let b = vrett.build
        let p = ctx.parser

        if vrett.is_func_ref() && type.is_closure() {
            let info = this.rett.func_info
            if !isset(info) {
                ctx.error("Missing type function info")
            }
            if isset(p) && p.loop_first_parse {
                return vgen_null_fake(info.to_closure_type(b))
            }
            return func_ref_value_to_closure(ctx, this, decl_scope)
        }

        if vrett.is_inline_type() && type.is_pointer() {
            return vgen_ref(ctx, this, decl_scope)
        }
        if type.is_inline_type() && vrett.is_pointer_for(type) {
            // println("LOAD")
            return vgen_load(this)
        }

        // Class $to Class
        if !type.compat(vrett) {
            // Find $to function
            let class = vrett.get_class() !? null
            if isset(class) {
                let func = class.get_to_hook(type) !? null
                if isset(func) {
                    // println(vrett + " -> " + type +  " | Using: " + func.display_name)
                    let values = Array[Value]{ this }
                    let fptr = vgen_func_ptr(func)
                    let call = vgen_func_call(b, decl_scope, fptr, values)
                    call.rett = type
                    return call
                }
            }
        }

        // Number -> Number
        if vrett.is_number() && type.is_number() {
            // int -> float
            if vrett.is_int() && type.is_float() {
                return vgen_cast(this, type)
            }
            // f32 -> f64
            else if vrett.is_float() && type.is_float() {
                if vrett.size() < type.size() {
                    return vgen_cast(this, type)
                }
            }
            // int -> int
            else if vrett.size() < type.size() || (vrett.size() == type.size() && vrett.is_signed != type.is_signed) {
                return vgen_cast(this, type)
            }

            return this
        }

        // To ptr
        if type.type == TYPE.voidptr {
            if vrett.type == TYPE.ref {
                // Dont convert ref to ptr
            } else if vrett.is_pointer() {
                // any-pointer -> ptr
                this.rett = type
            } else if vrett.is_int() {
                // int -> ptr
                return vgen_cast(this, type)
            }
        }

        // Multi -> Multi
        if type.is_multi() && vrett.is_multi() {
            let sub_types = type.sub_types
            if isset(sub_types) {
                let values = this.unroll()
                if values.length == sub_types.length {
                    let results = Array[Value].new()
                    each values as val, i {
                        let sub_type = sub_types.get(i) ! break
                        results.append(val.try_convert(ctx, decl_scope, sub_type))
                    }
                    return vgen_grouped_values(b, results)
                }
            }
        }

        return this
    }

    fn needs_buffer() bool {
        if this.rett.is_gc() {
            if this.type == VAL.null : return false
            if this.type == VAL.decl : return false
            if this.type == VAL.buffer : return false
            if this.type == VAL.string : return false
            return true
        }
        return false
    }

    fn check_decl_mutable() {
        if this.type == VAL.decl {
            let decl = this.decl
            if isset(decl) {
                decl.is_mut = true
            }
        }
    }

    fn is_multi() bool {
        return this.rett.is_multi()
    }

    fn unroll() Array[Value] {
        let unrolls = this.unrolls
        if isset(unrolls) : return unrolls

        let res = Array[Value]{}
        if this.is_multi() {
            let subtypes = this.rett.sub_types
            if isset(subtypes) {
                each subtypes as type, i {
                    res.append(vgen_rett_value(this, i, type))
                }
                return res
            }
        }
        res.append(this)
        return res
    }

    fn replace_base(with: Value) bool {
        // return false
        if this.type == VAL.class_init {
            let base = this.value1
            if !isset(base) : panic("Missing class init base value (bug)")
            base.value1 = with
            return true
        }
        if this.type == VAL.array_init {
            let base = this.value1
            if !isset(base) : panic("Missing array init base value (bug)")
            base.value1 = with
            return true
        }
        return false
    }
    fn can_replace_base() bool {
        return this.type == VAL.class_init || this.type == VAL.array_init
    }

    fn can_error() bool {
        let errc = this.func_err_code
        return isset(errc)
    }

    fn to_str() String !complex {
        let t = this.type
        if t == VAL.int : return this.int
        if t == VAL.decl {
            let decl = this.decl
            if isset(decl) : return decl.name ?! throw complex
        }
        if t == VAL.null : return "null"
        if t == VAL.bool : return this.bool1
        if t == VAL.string : return "\"" + this.string + "\""
        throw complex
    }
}

fn read_value(p: Parser, scope: Scope, prio: int (99999), assignable: bool (false)) Value {

    let b = p.build
    let v: ?Value = null

    p.backup2()
    let t = p.tok(true, true)

    let imut_mode = p.imut_mode
    p.imut_mode = false

    let read_co = p.reading_coro
    p.reading_coro = false

    let assign_to = p.assign_to
    p.assign_to = null

    let negative = false
    if p.sign_is("-") {
        negative = true
        t = p.tok(false, false)
        if t != TOK.int && t != TOK.float && t != TOK.hex && t != TOK.octal {
            p.error("Expected a valid number after: '-', found: '" + p.word() + "'")
        }
    }

    if t == TOK.word {
        if p.word_is("size_of") {
            p.expect("(", false, false)
            let type = read_type(p, scope, true)
            p.expect(")", true, true)
            let rett = p.suggest_type ?? type_valk(b, "int")
            if !rett.is_int() : rett = type_valk(b, "int")
            v = vgen_int(type.size().@cast(int), rett)
        } else if p.word_is("true") || p.word_is("false") {
            v = vgen_bool(b, p.word_is("true"))
        } else if p.word_is("isset") {
            p.expect("(", false, false)
            let on = read_value(p, scope)
            if !on.rett.nullable && !p.loop_first_parse {
                p.error("You can only use isset on nullable types. Type found: " + on.rett)
            }
            p.expect(")", true, true)
            let cmp = vgen_compare(on, vgen_null(on.rett), OP.ne, type_valk(b, "bool"))
            add_isset(cmp, on)
            v = cmp

        } else if p.word_is("null") {
            let type : ?Type = null
            let s = p.suggest_type
            if isset(s) && s.is_pointer() : type = s.get_nullable()

            if !isset(type) {
                if p.char(0) == '.' {
                    let before = p.clone_chunk()
                    p.tok(true, true)
                    if p.next_word_is("to", false, false, false) || p.next_word_is("@cast", false, false, false) {
                        type = b.valk_type("type", "ptr").get_nullable()
                    }
                    p.set_chunk(before)
                }
            }

            if !isset(type) : type = type_null(b)
            v = vgen_null(type)

        } else if p.word_is("object") {
            v = read_object(p, scope)

        } else if p.word_is("assert") {
            v = parse_assert(p, scope)

        } else if p.word_is("co") {

            p.reading_coro = true
            let on = read_value(p, scope, 1)
            if on.type != VAL.func_call : p.error("Expected a function call statement after 'co' token");
            v = coro_generate(p, scope, on);

        } else if p.word_is("await") {

            let on = read_value(p, scope, 1)
            if on.rett.type != TYPE.promise {
                p.error("Using 'await' on a non-coroutine value type. Value type: '" + on.rett + "'. Expected type: 'co({return-types}){errors}'. e.g. 'co(void)' or 'co(i32) !error'");
            }

            v = coro_await(p, scope, on);

        } else if p.word_is("error_is") {
            p.expect("(", false, false)

            let idf = p.read_idf(scope, true, true)
            let left = idf.value
            if !isset(left) : p.error("First value in 'error_is' is not an error value")
            if left.rett.type != TYPE.error : p.error("First value in 'error_is' is not an error type")

            // Left
            // let left = vgen_decl(decl)

            p.expect(",", true, true)

            let name = p.read_word(true, true)
            let nr = helper:ctxhash_u32(name)
            let right = vgen_int(nr, type_error_item(b, name, nr))

            // let l, r = match_op_values(b, left, right)
            // l.rett.compat_check(r.rett, p)
            v = vgen_compare(left, right, OP.eq, type_valk(b, "bool"))

            t = p.tok(true, true, false);
            while p.sign_is(",") {
                t = p.tok(true, true, true);

                let name = p.read_word(true, true)
                let nr = helper:ctxhash_u32(name)
                let right = vgen_int(nr, type_error_item(b, name, nr))

                // let l, r = match_op_values(b, left, right)
                // l.rett.compat_check(r.rett, p)
                let next = vgen_compare(left, right, OP.eq, type_valk(b, "bool"))

                v = vgen_and_or(v, next, OP.or, v.rett)

                t = p.tok(true, true, false);
            }

            p.expect(")", true, true)

        } else if p.word_is("__FILE__") {
            let chunk = p.chunk
            let fc = chunk.fc
            let path = fc.path
            v = Str.new_value(path, p.ctx);

        } else if p.word_is("__DIR__") {
            let chunk = p.chunk
            let fc = chunk.fc
            let path = fc.path
            v = Str.new_value(fs:dir_of(path), p.ctx);

        } else if p.word_is("clone") {

            p.expect("(", false, false)
            let val = read_value(p, scope)

            let clone_func_base = b.valk_func("core", "clone_value")
            let gtypes = Array[Type].new()
            gtypes.append(val.rett)
            let clone_func = get_func_generic(clone_func_base, gtypes)

            let fptr = vgen_func_ptr(clone_func)
            let values = Array[Value]{ val }
            let res = vgen_func_call(b, scope, fptr, values)

            v = res

            p.expect(")", true, true)

        } else if p.word_is("fn") && p.char(0) == '(' {

            p.tok(true, true)
            v = read_inline_func(p, scope, imut_mode)

        } else if p.word_is("atomic") {

            p.expect("(", false, false)

            let val = read_value(p, scope)
            if val.type != VAL.op : p.error("Invalid atomic statement")
            let left = val.value1
            let right = val.value2
            if !isset(left) || !isset(right) : p.error("Missing operator values (bug)")

            let op = val.int
            if op != OP.add && op != OP.sub && op != OP.bit_and && op != OP.bit_or && op != OP.bit_xor {
                p.error("Atomic operations only allows: + - & | ^")
            }
            if !left.assignable() : p.error("Atomic operation: Left value must be an assignable value. e.g. a variable")
            left.check_decl_mutable()

            p.expect(")", true, true)

            v = vgen_atomic_op(left, right, op)

        } else if p.word_is("atomic_store") {
            p.expect("(", false, false)
            let left = read_value(p, scope)
            if !left.assignable() : p.error("Atomic store: Left value must be an assignable value. e.g. a variable")
            p.expect(",", true, true)
            let right = read_value(p, scope)
            right = right.try_convert(p.ctx, scope, left.rett)
            left.rett.compat_check(right.rett, p.ctx)
            p.expect(")", true, true)

            v = vgen_atomic_store(left, right)

        } else if p.word_is("atomic_load") {
            p.expect("(", false, false)
            let left = read_value(p, scope)
            if !left.assignable() : p.error("Atomic store: Left value must be an assignable value. e.g. a variable")
            p.expect(")", true, true)

            v = vgen_atomic_load(left)

        } else if p.word_is("match") {

            v = parse_match_value(p, scope)

        } else if p.word_is("r") && p.char(0) == '"' {

            p.tok(true, true)
            let body = p.word()
            body = body.part(1, body.bytes - 2).unescape()
            v = Str.new_value(body, p.ctx);

        } else {
            // Identifier
            p.col -= p.word_len
            p.i -= p.word_len
            let idf = p.read_idf(scope, true, true)
            v = handle_idf(p, scope, idf, imut_mode)
        }
    } else if t == TOK.at_word {
        if p.word_is("@memcpy") {
            p.expect("(", false, false)
            let type_ptr = type_valk(b, "ptr")
            let type_uint = type_valk(b, "uint")
            let types = Array[Type]{ type_ptr, type_ptr, type_uint }
            let values = p.read_values_type_checked(scope, types, ")")
            let from = values.get(0) ! p.error("Missing @memcpy argument 1")
            let to = values.get(1) ! p.error("Missing @memcpy argument 2")
            let len = values.get(2) ! p.error("Missing @memcpy argument 3")
            //
            v = vgen_memcpy(b, from, to, len)
        } else if p.word_is("@ptrv") {
            p.expect("(", false, false)
            let type_ptr = type_valk(b, "ptr")
            let type_int = type_valk(b, "int")
            let on = read_value(p, scope)
            on = on.try_convert(p.ctx, scope, type_ptr)
            type_ptr.compat_check(on.rett, p.ctx)
            p.expect(",", true, true)
            let type = read_type(p, scope, true)
            p.expect2(",", ")", true, true)
            let offset = vgen_int(0, type_valk(b, "int"))
            if p.word_is(",") {
                let suggest = p.suggest_type
                p.suggest_type = type_int
                offset = read_value(p, scope)
                p.suggest_type = suggest
                if !offset.rett.is_int() : p.error("Expected a number value, not: " + offset.rett)
                p.expect(")", true, true)
            }
            //
            v = vgen_ptrv(on, type, offset)

        } else if p.word_is("@ref") || p.word_is("@stableRef") {
            let stable = p.word_is("@stableRef")
            p.expect("(", false, false)
            let on = read_value(p, scope, 99999, true)
            if !on.assignable() {
                p.error("Cannot use '@ref or @stableRef' on this value. It can only be used on assignable values, like variable names or object properties.")
            }
            on.check_decl_mutable()

            if stable && on.type == VAL.decl {
                let decl = on.decl
                if isset(decl) : decl.make_stable()
            }
            v = vgen_ref(p.ctx, on, scope)
            v.rett.type = TYPE.ptr

            p.expect(")", true, true)

        } else if p.word_is("@global_default_value") {
            p.expect("(", false, false)

            let idf = p.read_idf(scope, true, true)
            if idf.for != IDF.global : p.error("Identifier is not a global variable")

            let g = idf.global
            if isset(g) {
                let chunk = g.chunk_value
                let fc = g.fc
                if isset(chunk) {
                    let sp = p.new_sub_parser(chunk)
                    sp.assign_to = assign_to
                    let sub = scope.sub_scope(SCOPE.default)
                    sub.parent_idf = fc.scope
                    v = read_value(sp, sub)
                }
            }
            if !isset(v) : v = vgen_undefined(b)
            // if !isset(v) : p.error("Global has no default value: " + type)
            p.expect(")", true, true)
        } else if p.word_is("@stack") {
            p.expect("(", false, false)
            let type = read_type(p, scope, true)
            let decl = Decl.new(type, false)
            decl.name = "stack_alloc"
            scope.add_decl(decl)
            let ref = vgen_ref(p.ctx, vgen_decl(decl), scope, true)
            v = ref
            p.expect(")", true, true)

        } else if p.word_is("@undefined") {
            v = vgen_undefined(b)

        } else if p.word_is("@setjmp") {
            p.expect("(", false, false)
            let buf = read_value(p, scope)
            if !buf.rett.is_pointer() {
                p.error("Value of @setjmp should be a pointer")
            }
            p.expect(")", true, true)
            v = vgen_setjmp(b, buf);
        } else if p.word_is("@longjmp") {
            p.expect("(", false, false)
            let buf = read_value(p, scope)
            if !buf.rett.is_pointer() {
                p.error("Value of @longjmp should be a pointer")
            }
            p.expect(")", true, true)
            v = vgen_longjmp(b, buf);
            scope.did_return = true;

            let current_func = scope.get_func() ! p.error("Missing function in scope for longjmp (bug)")
            current_func.info_calls_unknown_code = true

        } else if p.word_is("@vtable") {
            p.expect("(", false, false)
            let type = read_type(p, scope, true)
            let class = type.get_class() !? null
            if isset(class) && type.is_class_type() {
                v = vgen_export_symbol(class.vtable_export_name(), type_ptr(p.build))
            } else {
                v = vgen_null(type)
            }
            p.expect(")", true, true)
        } else if p.word_is("@property_init") || p.word_is("@property_update") {
            let is_init = p.word_is("@property_init")
            let keyword = p.word()
            p.expect("(", false, false)
            // On
            let on = read_value(p, scope)
            if on.rett.is_imut : p.error("Trying to modify a immutable property. Type: " + on.rett)
            // Ref
            p.expect(",", true, true)
            let prop_value = read_value(p, scope)
            if !prop_value.assignable() : p.error("Invalid 2nd parameter for " + keyword + ". Must be an assignable value.")
            // Value
            p.expect(",", true, true)
            let val = read_value(p, scope)
            prop_value.rett.compat_check(val.rett, p.ctx)
            //
            p.expect(")", true, true)

            if on.rett.is_gc() && prop_value.rett.is_gc() {
                let func = b.valk_func("gc", is_init ? "property_set" : "property_update")
                let current_func = p.ctx.getFunc()
                current_func.functions_used.append(func, true)

                let values = Array[Value].new()
                values.append(on)
                values.append(vgen_ref(p.ctx, prop_value, scope))
                values.append(val)
                v = vgen_func_call(b, scope, vgen_func_ptr(func), values)
            } else {
                v = vgen_assign(prop_value, val)
            }

        } else if p.word_is("@property_get") {
            p.expect("(", false, false)
            let prop_value = read_value(p, scope)
            if !prop_value.assignable() : p.error("Invalid 1st parameter for @property_get. Must be an assignable value.")
            p.expect(")", true, true)

            if prop_value.rett.is_gc() {
                let func = b.valk_func("gc", "property_get")
                let values = Array[Value].new()
                values.append(vgen_ref(p.ctx, prop_value, scope))
                let call = vgen_func_call(b, scope, vgen_func_ptr(func), values)
                v = vgen_cast(call, prop_value.rett)
            } else {
                v = prop_value
            }

        } else if p.word_is("@property_clear") {
            p.expect("(", false, false)
            // On
            let on = read_value(p, scope)
            if on.rett.is_imut : p.error("Trying to modify a immutable property. Type: " + on.rett)
            // Ref
            p.expect(",", true, true)
            let prop_value = read_value(p, scope)
            if !prop_value.assignable() : p.error("Invalid 2nd parameter for @property_clear. Must be an assignable value.")
            p.expect(")", true, true)

            if on.rett.is_gc() && prop_value.rett.is_gc() {
                let func = b.valk_func("gc", "property_remove")
                let values = Array[Value].new()
                values.append(on)
                values.append(vgen_ref(p.ctx, prop_value, scope))
                v = vgen_func_call(b, scope, vgen_func_ptr(func), values)
            } else {
                v = vgen_null(type_ptr(p.build))
            }
        } else if p.word_is("@POOL_INDEX") {
            p.expect("(", false, false)
            let type = read_type(p, scope, true, true)
            let _, pindex = b.get_pool_index(type.size())
            v = vgen_int(pindex, b.valk_type("type", "uint"))
            p.expect(")", true, true)
        }
    } else if t == TOK.string {

        let body = p.word()

        if body.contains("%") {
            // Find parts
            p.restore2()
            p.skip_whitespace(true)
            p.skip_bytes(1)

            let data = p.data
            let string_type = b.valk_type("type", "String")
            // Read parts
            let i = p.i
            let start = i
            let ch : u8 = 0
            let prev : u8 = 0
            let parts = Array[Value]{}
            while true {
                prev = ch
                ch = @ptrv(data, u8, i++)
                if ch == 0 : p.error("Unexpected end of file")
                if ch == '\\' {
                    i++
                    ch = 0
                    continue
                }

                // Part
                if ch == '%' && (@ptrv(data, u8, i).is_alpha() || @ptrv(data, u8, i) == '_') {

                    let len = i - start - 1
                    if len > 0 {
                        let body = String.make_from_ptr(data + start, len)
                        parts.append(Str.new_value(body.unescape(), p.ctx))
                    }
                    p.skip_bytes(i - start)

                    let w = p.read_word(false, false)
                    let idf = scope.find(p, w) ! p.error("Unknown identifier: '%w'")

                    let val = handle_idf(p, scope, idf, imut_mode)
                    val = val.try_convert(p.ctx, scope, string_type)
                    string_type.compat_check(val.rett, p.ctx)
                    parts.append(val)

                    i = p.i
                    start = i
                    ch = 0
                    continue

                } else if ch == '{' && prev == '%' {
                    let len = i - start - 2
                    if len > 0 {
                        let body = String.make_from_ptr(data + start, len)
                        parts.append(Str.new_value(body.unescape(), p.ctx))
                    }
                    p.skip_bytes(i - start)
                    //
                    let val = read_value(p, scope)
                    val = val.try_convert(p.ctx, scope, string_type)
                    string_type.compat_check(val.rett, p.ctx)
                    parts.append(val)
                    //
                    p.expect("}", true, true)
                    i = p.i
                    start = i
                    ch = 0
                    continue
                }
                // End
                if ch == '"' {
                    let len = i - start - 1
                    if len > 0 {
                        let body = String.make_from_ptr(data + start, len)
                        parts.append(Str.new_value(body.unescape(), p.ctx))
                    }
                    p.skip_bytes(i - start)
                    break
                }
            }

            // Generate AST concatting all parts
            let sub = scope.sub_scope(SCOPE.default)
            // Identifiers
            sub.set_idf(p.ctx, "CREATE_EMPTY", Idf.for_func(b.valk_class_func("type", "String", "make_empty")))
            sub.set_idf(p.ctx, "MEM_COPY", Idf.for_func(b.valk_func("mem", "copy")))
            each parts as part, i {
                sub.set_idf(p.ctx, "STR" + i, Idf.for_value(part))
            }

            let code = StringComposer.new(1024)
            code.append_str("<{\n")
            code.append_str("let len : uint = 0\n")
            each parts as part, i {
                code.append_str("len += STR")
                code.append_uint(i)
                code.append_str(".bytes\n")
            }
            code.append_str("let str = CREATE_EMPTY(len)\n")
            code.append_str("let data = str.data\n")
            each parts as part, i {
                code.append_str("MEM_COPY(STR")
                code.append_uint(i)
                code.append_str(".data, data, STR")
                code.append_uint(i)
                code.append_str(".bytes)\n")
                code.append_str("data += STR")
                code.append_uint(i)
                code.append_str(".bytes\n")
            }
            code.append_str("return str\n")
            code.append_str("}\n")

            let content = code.to_string()
            let chunk = Chunk.new(b, content, b.generated_fc())
            let sp = p.new_sub_parser(chunk)

            v = read_value(sp, sub, 0)

        } else {
            body = body.part(1, body.bytes - 2).unescape()
            v = Str.new_value(body, p.ctx)
        }

    } else if t == TOK.char {
        v = vgen_int(p.last_char, b.valk_type("type", "u8"))
    } else if t == TOK.int || t == TOK.hex || t == TOK.octal {
        let value = (p.integer_value() ! p.error("Failed to convert integer string to an integer value (bug)"))
        let fit_int = value <= 0x7FFFFFFFFFFFFFFF
        if negative && !fit_int : p.error("Number too large")
        let type = type_int(b)
        let suggest = p.suggest_type
        if isset(suggest) : if suggest.is_int() || suggest.is_float() : type = suggest
        if type.is_float() {
            let word : String = p.word()
            let fv = helper:str_to_float(word) ! p.error("Invalid float syntax: %word")
            v = vgen_float(fv * (negative ? -1.0 : 1.0), type)
        } else {
            v = vgen_int((value.@cast(int)) * (negative ? -1 : 1), type)
        }
    } else if t == TOK.float {

        let value = (p.float_value() ! p.bug("Failed to convert float string to a float value"))
        let type = type_float(b)
        let suggest = p.suggest_type
        if isset(suggest) : if suggest.is_float() : type = suggest
        v = vgen_float(value * (negative ? -1.0 : 1.0), type)

    } else if t == TOK.sign {
        if p.sign_is("(") {
            let st = p.suggest_type
            let types = isset(st) ? st.unroll() : Array[Type]{}
            let values = Array[Value].new()
            let i = 0
            while true {
                p.suggest_type = types.get(i++) !? null
                let val = read_value(p, scope)
                values.append(val)
                p.expect2(",", ")", true, true)
                if p.word_is(")") : break
            }
            p.suggest_type = st
            buffer_values(scope, values)
            v = vgen_grouped_values(b, values)
        } else if p.sign_is("!") {
            let val = read_value(p, scope, 1)
            if !val.rett.is_bool() : p.error("Expected a value of type 'bool' after '!', the value type we found was: " + val.rett)
            let res = vgen_not(val)
            // Flip issets if only 1, otherwise clear them
            let issets = val.issets
            let not_issets = val.not_issets
            let count = (isset(issets) ? issets.length : 0) + (isset(not_issets) ? not_issets.length : 0) 
            if count == 1 {
                res.issets = not_issets
                res.not_issets = issets
            }
            v = res
        } else if p.sign_is("&") {

            let on = read_value(p, scope, 0, true)
            if !on.assignable() : p.error("Cannot use '&' on this value. It can only be used on assignable values, like variable names or object properties.")
            on.check_decl_mutable()

            v = vgen_ref(p.ctx, on, scope)

        } else if p.sign_is("++") {
            let t = p.tok(false, false, false)
            if t == TOK.none : p.error("Missing value after '++'")
            let on = read_value(p, scope)
            if !on.assignable() || !on.rett.is_int() : p.error("Cannot use '++' on this value")
            on.check_decl_mutable()
            v = vgen_incr(on, true)
        } else if p.sign_is("--") {
            let t = p.tok(false, false, false)
            if t == TOK.none : p.error("Missing value after '--'")
            let on = read_value(p, scope)
            if !on.assignable() || !on.rett.is_int() : p.error("Cannot use '--' on this value")
            on.check_decl_mutable()
            v = vgen_decr(on, true)

        } else if p.sign_is("<{") {
            // Value scope
            let before = p.vscope_decls
            p.vscope_decls = null
            let sub = scope.sub_scope(SCOPE.vscope)
            sub.must_return = true
            read_ast(p, sub, false)
            let decls = p.vscope_decls ?? Array[Decl]{}

            if decls.length == 0 : p.error("Value scope did not return a value")

            let vscope_value = vgen_vscope(b, sub, decls)
            let return_values = Array[Value].new()
            each decls as decl {
                let v = vgen_decl(decl)
                v.pre_value = vscope_value
                return_values.append(v)
            }
            v = vgen_grouped_values(b, return_values)

            p.vscope_decls = before
        } else if p.sign_is("#") {
            t = p.tok(false, false)
            if p.word_is("string") {
                p.expect("(", false, false)
                p.tok(true, true)
                let word = p.word()
                let defs = b.cm_defs
                let body = defs.get(word) ! p.error("Unknown compile macro definition: '" + word + "'")
                v = Str.new_value(body, p.ctx)
                p.expect(")", true, true)
            } else if p.word_is("embed") {
                p.expect("(", false, false)
                p.expect_string(true, true)
                let path = p.word()
                path = path.part(1, path.bytes - 2).unescape()
                let pkc = p.chunk.fc.nsc.pkc
                let full = helper:resolve(path, pkc.dir)
                if !fs:exists(full) : p.error("Embed file not found: " + full)
                let content = fs:read(full) ! p.error("Failed to read embed file: " + full)
                v = Str.new_value(content, p.ctx)
                p.expect(")", true, true)
            } else if p.word_is("embed_dir") {
                p.expect("(", false, false)
                p.expect_string(true, true)
                let path = p.word()
                path = path.part(1, path.bytes - 2).unescape()
                let pkc = p.chunk.fc.nsc.pkc
                let dir = helper:resolve(path, pkc.dir)
                if !fs:is_dir(dir) : p.error("Embed directory not found: " + dir)
                let all = HashMap[Value, Value]{}
                each fs:files_in(dir, true, true, false, "") as file {
                    let content = fs:read(fs:add(dir, file)) ! p.error("Error reading embed file: " + file)
                    let key = Str.new_value(file.replace("\\", "/"), p.ctx)
                    let v = Str.new_value(content, p.ctx)
                    all.set(key, v)
                }
                let string_type = b.valk_type("type", "String")
                v = vgen_map(b, p.ctx, scope, .{ string_type, string_type }, all)
                p.expect(")", true, true)
            } else {
                p.error("Unknown compile macro statement '#" + p.word() + "'")
            }
        } else if p.sign_is(".") {
            let s = p.suggest_type
            if !isset(s) : p.error("Using '.' requires a typehint to be present")

            let class = s.get_class() ! p.error("The '.' token cannot be used for type: " + s)
            v = handle_class(p, class, scope, true)

        } else if p.sign_is("[") {
            let type = read_fixed_array_type(p, scope)
            let decl = Decl.new(type, false)
            decl.name = "fixed_array"
            scope.add_decl(decl)
            p.expect("{", false, false)

            let sub_type = type.sub_type
            if !isset(sub_type) : p.error("Missing array type sub-type (bug)")
            let size = type.array_size
            if size < 1 : p.error("Array size is 0 (bug)")

            let assign_to = vgen_decl(decl)

            v = value_read_array_init(p, scope, vgen_ref(p.ctx, assign_to, scope), sub_type, size)

        } else if p.sign_is("{") {

            if !isset(assign_to) : p.error("You cannot use '{' here. It can only be used for defining the starting value for inline types . E.g. let myvar: [u8 x 2] = { 6, 7 }")
            let type = assign_to.rett

            if type.type == TYPE.array {
                let sub_type = type.sub_type
                if !isset(sub_type) : p.error("Missing array type sub-type (bug)")
                let size = type.array_size
                if size < 1 : p.error("Array size is 0 (bug)")
                v = value_read_array_init(p, scope, vgen_ref(p.ctx, assign_to, scope), sub_type, size)
                v.skip_assign = true
            } else if type.type == TYPE.struct {
                let class = assign_to.rett.class
                if !isset(class) : p.error("Missing class for inline struct initialization (bug)")
                v = parse_class_init(p, scope, class, vgen_ref(p.ctx, assign_to, scope))
                v.skip_assign = true
            } else {
                p.error("The '{' token can only be used to define initialization values for inline struct or fixed arrays. Not for: " + type)
            }
        }
    }

    if !isset(v) {
        p.error("Unknown value/token: '" + p.word() + "'")
    }

    // Trailing characters
    t = p.tok(false, false, false)
    while t == TOK.sign && (p.word_is(".") || p.word_is("(") || p.word_is("++") || p.word_is("--") || p.word_is("[")) {
        t = p.tok(false, false)

        if p.word_is(".") {
            // Class properties
            v = value_prop_access(p, scope, v, assignable)
        } else if p.word_is("(") {
            // Function call
            v = value_func_call(p, scope, v, read_co)
        } else if p.word_is("++") || p.word_is("--") {
            // ++ / --
            if !v.assignable() || !v.rett.is_int() : p.error("Cannot use '" + p.word() + "' on this value")
            v.check_decl_mutable()
            if p.word_is("++") : v = vgen_incr(v, false)
            else : v = vgen_decr(v, false)
        } else if p.word_is("[") {
            v = parse_offset_value(p, scope, v)
        }

        t = p.tok(false, false, false)
    }

    t = p.tok(true, true, false)
    if prio > 10 {
        while t == TOK.sign && (p.word_is("/") || p.word_is("*") || p.word_is("%")) {
            t = p.tok(true, true)
            let op = OP.mul
            if p.word_is("/") : op = OP.div
            else if p.word_is("%") : op = OP.mod

            p.set_suggest(v.rett)
            let right = read_value(p, scope, 10)
            p.pop_suggest()
            v = value_handle_op(p, scope, op, v, right)

            t = p.tok(true, true, false)
        }
    }

    if prio > 20 {
        while t == TOK.sign && (p.word_is("+") || p.word_is("-")) {
            t = p.tok(true, true)
            let op = p.word_is("-") ? OP.sub : OP.add

            p.set_suggest(v.rett)
            let right = read_value(p, scope, 20)
            p.pop_suggest()
            v = value_handle_op(p, scope, op, v, right)

            t = p.tok(true, true, false)
        }
    }

    if prio > 30 {
        while t == TOK.sign && (p.word_is("<<") || p.word_is(">>")) {
            t = p.tok(true, true)
            let op = p.word_is("<<") ? OP.shl : OP.shr
            
            p.set_suggest(v.rett)
            let right = read_value(p, scope, 30)
            p.pop_suggest()
            v = value_handle_op(p, scope, op, v, right)

            t = p.tok(true, true, false)
        }
    }

    if prio > 35 {
        while t == TOK.sign && (p.word_is("|") || p.word_is("&") || p.word_is("^")) {
            t = p.tok(true, true)
            let op = p.word_is("|") ? OP.bit_or : (p.word_is("&") ? OP.bit_and : OP.bit_xor)
            
            p.set_suggest(v.rett)
            let right = read_value(p, scope, 35)
            p.pop_suggest()
            v = value_handle_op(p, scope, op, v, right)

            t = p.tok(true, true, false)
        }
    }

    if prio > 40 {
        while t == TOK.sign && (p.word_is("!=") || p.word_is("==") || p.word_is("<=") || p.word_is(">=") || p.word_is("<") || p.word_is(">")) {
            t = p.tok(true, true)
            //
            let op = OP.eq
            if p.word_is("!=") : op = OP.ne
            else if p.word_is("<=") : op = OP.lte
            else if p.word_is(">=") : op = OP.gte
            else if p.word_is("<") : op = OP.lt
            else if p.word_is(">") : op = OP.gt
            //
            p.set_suggest(v.rett)
            let right = read_value(p, scope, 40)
            p.pop_suggest()

            let l, r = match_op_values(b, v, right)

            // Compare hooks
            let lc = l.rett.get_class() !? null
            if isset(lc) {
                let hooks : ?Array[Func] = null
                if op == OP.eq : hooks = lc.eq_hooks
                else if op == OP.ne : hooks = lc.eq_hooks
                else if op == OP.lt : hooks = lc.lt_hooks
                else if op == OP.lte : hooks = lc.lte_hooks
                else if op == OP.gt : hooks = lc.gt_hooks
                else if op == OP.gte : hooks = lc.gte_hooks
                if isset(hooks) {
                    let lv = l
                    let rv = r
                    let ltype = l.rett
                    let rtype = r.rett
                    if (op == OP.eq || op == OP.ne) && ltype.is_pointer() && rtype.is_pointer() {
                        ltype = ltype.get_non_nullable()
                        rtype = rtype.get_non_nullable()
                    }

                    let hook = hook_select_compare(hooks, ltype, rtype)
                    if !isset(hook) {
                        // Try reverse
                        lv = r
                        rv = l
                        ltype = r.rett
                        rtype = l.rett
                        lc = ltype.get_class() !? null

                        if (op == OP.eq || op == OP.ne) && ltype.is_pointer() && rtype.is_pointer() {
                            ltype = ltype.get_non_nullable()
                            rtype = rtype.get_non_nullable()
                        }

                        if isset(lc) {
                            if op == OP.eq : hooks = lc.eq_hooks
                            else if op == OP.ne : hooks = lc.eq_hooks
                            else if op == OP.lt : hooks = lc.gte_hooks
                            else if op == OP.lte : hooks = lc.gt_hooks
                            else if op == OP.gt : hooks = lc.lte_hooks
                            else if op == OP.gte : hooks = lc.lt_hooks

                            hook = hook_select_compare(hooks, ltype, rtype)
                        }
                    }

                    if isset(hook) {
                        let values = Array[Value].new()
                        values.append(lv)
                        values.append(rv)
                        let cmp = vgen_func_call(b, scope, vgen_func_ptr(hook), values)

                        if (op == OP.eq || op == OP.ne) && ltype.is_pointer() && rtype.is_pointer() {
                            let bool_type = b.valk_type("type", "bool")
                            // if a == b || (a != null && b != null && hook(a,b))
                            if lv.rett.nullable : cmp = vgen_and_or(vgen_compare(lv, vgen_null(ltype), OP.ne, bool_type), cmp, OP.and, bool_type)
                            if rv.rett.nullable : cmp = vgen_and_or(vgen_compare(rv, vgen_null(rtype), OP.ne, bool_type), cmp, OP.and, bool_type)
                            // if a == b || hook(a,b)
                            cmp = vgen_and_or(vgen_compare(lv, rv, OP.eq, bool_type), cmp, OP.or, bool_type)
                        }

                        v = cmp
                        if op == OP.ne : v = vgen_not(v)
                        t = p.tok(true, true, false)
                        continue
                    }
                }
            }

            // No hook found, compare natively
            r = r.try_convert(p.ctx, scope, l.rett)
            l.rett.compat_check(r.rett, p.ctx)
            v = vgen_compare(l, r, op, type_valk(b, "bool"))

            t = p.tok(true, true, false)
        }
    }

    if prio > 50 {
        while t == TOK.sign && (p.word_is("&&") || p.word_is("||")) {
            t = p.tok(true, true)
            let op = p.word_is("&&") ? OP.and : OP.or

            let lrett = v.rett
            if !lrett.is_bool() : p.error("Expected a value of type 'bool', not: " + lrett)

            let sub = scope
            if op == OP.and {
                sub = scope.sub_scope(SCOPE.default)
                apply_issets(sub, v.issets)
            }

            let right = read_value(p, sub, 50)
            if !right.rett.is_bool() : p.error("Expected a value of type 'bool', not: " + lrett)

            v = vgen_and_or(v, right, op, lrett)
            t = p.tok(true, true, false)
        }
    }

    if prio > 60 {
        while p.word_is("?") {

            let cond = v
            if !cond.rett.is_bool() : p.error("You can only use '?' after values that return a bool. This value has type: " + cond.rett)
            t = p.tok(true, true)

            let sub = scope.sub_scope(SCOPE.default)
            apply_issets(sub, cond.issets)

            let v1 = read_value(p, sub)

            p.expect(":", true, true)

            if sub.did_return : apply_issets(scope, cond.not_issets)
            let sub_else = scope.sub_scope(SCOPE.default)
            apply_issets(sub_else, cond.not_issets)

            p.set_suggest(v1.rett)
            let v2 = read_value(p, sub_else)
            p.pop_suggest()

            let l, r = match_op_values(b, v1, v2)
            let rett = l.rett
            if r.rett.nullable && !rett.nullable : rett = rett.get_nullable()
            rett.compat_check(r.rett, p.ctx)
            r.rett.compat_check(l.rett, p.ctx)

            v = vgen_this_or_that(cond, l, r, rett)

            scope.not_null_remove_check(sub)
            scope.not_null_remove_check(sub_else)
            apply_issets(scope, sub.not_null.intersect(sub_else.not_null))

            t = p.tok(true, true, false)
        }
    }

    if prio > 70 {
        while p.word_is("??") || p.word_is("?!") {

            if !v.rett.nullable : p.error("You can only use '??' and '?!' on nullable values. Value type is: '" + v.rett + "'")
            let on = v

            t = p.tok(true, true)

            if p.word_is("??") {
                let alt = read_value(p, scope).try_convert(p.ctx, scope, on.rett)
                on.rett.compat_check(alt.rett, p.ctx)
                v = Value {
                    type: VAL.altv
                    value1: on
                    value2: alt
                    rett: alt.rett
                }
            } else {
                let sub = scope.sub_scope(SCOPE.default)
                t = p.tok(true, true, false)
                let single = !p.sign_is("{")
                if !single : p.tok(true, true)
                read_ast(p, sub, single)
                if !sub.did_return : p.error("Expected the code after '?!' to end with: return, exit, continue, break or throw")

                v = Value {
                    type: VAL.altv_break
                    value1: on
                    scope1: sub
                    rett: on.rett.get_non_nullable()
                }
            }

            t = p.tok(true, true, false)
        }
    }

    //
    return v
}

fn handle_idf(p: Parser, scope: Scope, idf: Idf, imut_mode: bool) Value {
    
    let for = idf.for

    if for == IDF.func {
        let func = idf.func
        if isset(func) {
            if func.is_generic_base : func = read_func_generic(p, scope, func)
            // TODO: use ctx.uses_func
            func.used_in(scope)
            //
            check_act(p, func.act, func.fc, false, "function")
            return vgen_func_ptr(func)
        }
    }
    if for == IDF.decl {
        let decl = idf.decl
        if isset(decl) {
            let res = vgen_decl(decl)
            if res.rett.nullable && scope.not_null_check(decl) {
                let type = res.rett.clone()
                type.nullable = false
                type.null_overwrite = true
                res.rett = type
            }
            // Check if moved decl
            let this_func = scope.func
            let decl_func = find_decl_func(decl, scope) ! p.error("Cannot find variable function (bug)")
            if !isset(this_func) : p.error("Missing variable function (bug)")
            if this_func != decl_func {
                // Move values
                if this_func.imut_mode && !decl.type.is_imut_or_async() {
                    p.error("Moving a variable to an immutable closure must have an immutable or async compatible variable type. Type found: " + decl.type)
                }
                decl = bind_extern_decl(decl, res.rett, scope)
                res = vgen_decl(decl)
            }
            return res
        }
    }
    if for == IDF.global {
        let g = idf.global
        if isset(g) {
            check_act(p, g.act, g.fc, false, "global")
            let func = p.func()
            func.globals_used.append(g)
            return vgen_global(g)
        }
    }
    if for == IDF.alias {
        let alias = idf.alias
        if isset(alias) {
            let chunk = alias.chunk
            if alias.type == ALIAS.value {
                check_act(p, alias.act, alias.fc, false, "alias")
                let sp = p.new_sub_parser(chunk)
                let v = read_value(sp, alias.fc.scope)
                return v
            }
            if alias.type == ALIAS.idf {
                let idf = alias.for_idf
                if isset(idf) {
                    return handle_idf(p, scope, idf, imut_mode)
                }
            }
            if alias.type == ALIAS.type {
                let type = alias.for_type
                if isset(type) {
                    let class = type.get_class() !? null
                    if isset(class) {
                        if class.is_generic_base : class = read_class_generic(p, scope, class)
                        return handle_class(p, class, scope)
                    }
                }
            }
        }
    }
    if for == IDF.class {
        let class = idf.class
        if isset(class) {
            check_act(p, class.act, class.fc, false, "class")
            if class.is_generic_base : class = read_class_generic(p, scope, class)
            if imut_mode : class = get_imut_class(class)
            return handle_class(p, class, scope)
        }
    }
    if for == IDF.enum {
        let e = idf.enum
        if isset(e) {
            check_act(p, e.act, e.fc, false, "enum")
            return handle_enum(p, e, scope)
        }
    }
    if for == IDF.value {
        let value = idf.value
        if isset(value) : return value
    }
    if for == IDF.type {
        let type = idf.type
        // if p.char(0) == '.' {
            if isset(type) {
                let class = type.get_class() !? null
                if isset(class) {
                    if class.is_generic_base : class = read_class_generic(p, scope, class)
                    return handle_class(p, class, scope)
                }
            }
        // }
        // return Str.new_value(type, p.ctx)
    }

    if for == IDF.macro {
        let m = idf.macro
        if isset(m) {
            return read_macro_value(p, scope, m)
        }
    }

    if for == IDF.idf {
        let i = idf.idf
        if !isset(i) : p.error("Missing identifier info (bug)")
        return handle_idf(p, scope, i, imut_mode)
    }

    if for == IDF.idf_group {
        let idfs = idf.idf_group
        if isset(idfs) {
            p.expect(".", false, false)
            let name = p.read_word(false, false)
            let idf = idfs.get(name) ! p.error("Unknown sub-identifier '" + name + "'")
            return handle_idf(p, scope, idf, imut_mode)
        }
    }

    if for == IDF.class_prop {
        let prop = idf.prop
        if !isset(prop) : p.error("Missing property info for property identifier")

        p.expect(".", false, false)
        if p.lsp : p.build.getlsp().check_completion_simple(Array[String]{ "name", "type" })

        p.expect2("name", "type", false, false)
        if p.word_is("name") {
            return Str.new_value(prop.name, p.ctx)
        } else if p.word_is("type") {
            return handle_idf(p, scope, Idf.for_type(prop.type), imut_mode)
        }
    }

    if for == IDF.prop {
        let prop = idf.prop
        let propv = idf.value
        if !isset(prop) : p.error("Missing property info for property identifier")
        if !isset(propv) : p.error("Missing property value for property identifier")

        p.expect(".", false, false)
        if p.lsp : p.build.getlsp().check_completion_simple(Array[String]{ "name", "type", "value" })

        p.expect3("name", "type", "value", false, false)
        if p.word_is("name") {
            return Str.new_value(prop.name, p.ctx)
        } else if p.word_is("type") {
            return handle_idf(p, scope, Idf.for_type(prop.type), imut_mode)
        } else if p.word_is("value") {
            return propv
        }
    }

    p.error("Unhandled identifier type (type: " + for + ") (compiler bug)")
}

fn value_func_call(p: Parser, scope: Scope, on: Value, read_co: bool) Value {

    let current_func = scope.get_func() ! p.error("Missing function in scope object (bug)")

    let on_rett = on.rett
    let func_info = on_rett.func_info
    if !isset(func_info) : p.error("Function call on a non-function value. Value type: " + on_rett)

    let values = Array[Value].new()
    let func : ?Func = null
    if on.type == VAL.func_ptr {
        func = on.func
        let onn = on.value1
        if isset(onn) {
            values.append(onn)
        }
    }

    read_func_call_arg_values(p, scope, on, ")", values)

    // Default values
    if isset(func) {
        // Check if generic
        if func.has_generic_args {
            func = get_generic_arg_func(p, func, values)
            on = vgen_func_ptr(func)
        }

        // Store used function
        current_func.functions_used.append(func, true)

        // Default values
        let args = func.args
        if values.length < args.length {
            let i : uint = values.length
            while true {
                let arg = func.args.get(i++) ! break
                let chunk = arg.chunk_value
                if !isset(chunk) : break
                // Read default value
                let v = func_arg_read_default_value(p, scope, func, arg, chunk)
                values.append(v)
            }
        }
    } else {
        // Calling function via reference
        current_func.info_calls_unknown_code = true
    }

    if values.length < func_info.args.length {
        p.error("Not enough values to call this function. Function type: " + on_rett)
    }

    // Exit func check
    if on.type == VAL.func_ptr {
        let func = on.func.@cast(Func)
        if func.is_exit {
            scope.did_return = true
            scope.did_exit = true
        }
    }

    let res = vgen_func_call(p.build, scope, on, values)

    if func_info.can_error && !read_co {
        res = value_error_handling(p, scope, res, func_info.errors)
    }

    return res
}

fn value_prop_access(p: Parser, scope: Scope, on: Value, assignable: bool (false)) Value {

    let is_lsp = p.lsp

    if on.rett.is_inline_type() {
        on = vgen_ref(p.ctx, on, scope, true)
    }

    let size = 0
    if on.rett.type == TYPE.array {
        size = on.rett.array_size
    }
    if on.rett.type == TYPE.ptr {
        let sub = on.rett.sub_type
        if isset(sub) && sub.type == TYPE.array {
            size = sub.array_size
        }
    }

    if is_lsp {
        let lsp = p.build.getlsp()
        if lsp.is_completion {
            // Error
            if on.rett.type == TYPE.error {
                let errors = on.rett.errors
                if isset(errors) : lsp.check_completion_simple(errors.keys())
            }
            // $length
            if size > 0 : lsp.check_completion_simple(Array[String]{ "$length" })
            // Enum
            let e = on.rett.enum
            if isset(e) : lsp.check_completion_on_enum(e)
            // Class / Group
            let on_class = on.get_rett_class() ! p.error("Cannot access properties/functions on this type: " + on.rett)
            let on_group = on.rett.group
            if isset(on_group) : lsp.check_completion_on_group(on_group, p.chunk.fc)
            else : lsp.check_completion_on_class(on_class, p.chunk.fc)
        }
    }


    let b = p.build
    let name = p.read_name_like(false, false)
    is_lsp = p.lsp

    if name == "$length" && size > 0 {
        return vgen_int(size, b.valk_type("type", "uint"))
    }

    if on.rett.is_inline_type() : on = vgen_ref(p.ctx, on, scope)

    if name == "@cast" {
        p.expect("(", false, false)
        let type = read_type(p, scope)
        if type.is_inline_type() : p.error("You cannot cast '" + on.rett + "' to '" + type + "'")
        if on.rett.is_inline_type() : on = vgen_ref(p.ctx, on, scope)
        p.expect(")", true, true)

        return vgen_cast(on, type)
    }

    if on.rett.type == TYPE.error {
        let errors = on.rett.errors
        if !isset(errors) : p.error("The compiler seems to have lost essential information about this error value, so you cannot access any properties on this error value. (bug)")

        let errv = errors.get(name) ! {
            let options = ""
            let i = 0
            each errors as v, k {
                if i > 0 : options += ", "
                i++
                options += k
            }
            p.error("This value has no error named '" + name + "'. Valid options are: " + options)
        }

        return vgen_int(errv, type_error_item(b, name, errv))
    }

    let e = on.rett.enum
    if isset(e) {
        // TODO
    }

    if on.rett.nullable {
        p.error("You cannot access properties/functions on a nullable type: " + on.rett)
    }

    let on_class = on.get_rett_class() ! p.error("Cannot access properties/functions on this type: " + on.rett)
    let on_group = on.rett.group

    // Functions
    let func : ?Func = null
    if isset(on_group) {
        func = on_group.funcs.get(name) !? null
    }
    if !isset(func) {
        func = on_class.get_func(name) !? null
    }
    if isset(func) {

        if is_lsp {
            let lsp = p.build.getlsp()
            if lsp.is_definition : lsp.check_func_definition(func)
        }

        if func.is_mut && on_class.is_imut {
            p.error("You can only access the function '" + name + "' if your object is mutable")
        }

        if func.is_generic_base : func = read_func_generic(p, scope, func)
        check_act(p, func.act, func.fc, false, "function")

        func.used_in(scope)

        if func.is_getter {
            let values = Array[Value]{ on }
            let fptr = vgen_func_ptr(func)
            let call = vgen_func_call(b, scope, fptr, values)
            return call
        }

        let fptr = vgen_func_ptr(func)
        fptr.value1 = on
        return fptr
    }

    // Properties
    let prop = on_class.get_prop(name) !? null
    if isset(prop) {

        if is_lsp {
            let lsp = p.build.getlsp()
            if lsp.is_definition : lsp.check_prop_definition(prop)
        }

        check_act(p, prop.act, prop.class.fc, false, "property")

        let v = vgen_prop(prop, on)

        if prop.is_lazy && !assignable {
            let sub = scope.sub_scope(SCOPE.default)
            // prop == null
            let if_scope = sub.sub_scope(SCOPE.if)
            let else_scope = sub.sub_scope(SCOPE.if)
            sub.ast.append(Token {
                type: AST.if
                value1: vgen_compare(v, vgen_null(v.rett), OP.eq, type_valk(b, "bool"))
                scope1: if_scope
                scope2: else_scope
            })
            // assign default value
            let defv = prop_read_default(p, scope, on, prop)
            if defv.type == VAL.undefined : p.error("The default value of lazy propertiies should not be @undefined")
            if_scope.ast.append(Token {
                type: AST.assign
                value1: v
                value2: defv
            })
            //
            let iscope = vgen_inline_scope(sub, type_void(b))
            v = vgen_this_but_that(iscope, vgen_prop(prop, on))
        }

        return v
    }

    // Groups
    let group = on_class.get_group(name) !? null
    if isset(group) {
        let rett = on.rett.clone()
        rett.group = group
        on.rett = rett
        return on
    }

    // Internal .to/.$to
    if name == "to" || name == "$to" {
        p.expect("(", false, false)
        let type = read_type(p, scope)
        p.expect(")", true, true)

        // Check if converting is needed or not
        if type.compat(on.rett) : return on

        // Find $to function
        let func = on_class.get_to_hook(type) !? null
        if isset(func) {
            let values = Array[Value]{ on }
            let fptr = vgen_func_ptr(func)
            let call = vgen_func_call(b, scope, fptr, values)
            call.rett = type
            return call
        }
        if (on.rett.is_number() || on.rett.is_bool()) && (type.is_number() || type.is_bool()) {
            return vgen_cast(on, type)
        }
        p.error("Cannot find a function to convert this value to: '" + type + "'")
    }
    if name == "$offset" || name == "@offset" {
        if name == "$offset" && on.rett.type != TYPE.voidptr : p.error("The '$offset' token can only be used on void pointer types. Not on: " + on.rett)
        if name == "@offset" && !on.rett.is_pointer() : p.error("The '@offset' token can only be used on pointer types. Not on: " + on.rett)
        p.expect("(", false, false)
        // Offset
        let offset = read_value(p, scope)
        if !offset.rett.is_int() : p.error("Expected a number value, not a value of type: " + offset.rett)
        // Type
        let type = b.valk_type("type", "u8")
        if p.next_word_is(",", true, true, true) {
            type = read_type(p, scope)
        }
        // Result
        let res = vgen_ptr_offset(on, offset, type)
        p.expect(")", true, true)
        return res
    }

    if name == "$is_shared" {
        if !on.rett.is_gc() : p.error("The '$is_shared' token can only be used on 'class' types. Not on: " + on.rett)
        if on.rett.nullable : p.error("The '$is_shared' token cannot be used on null-able types. Your type: " + on.rett)

        let type_u8 = b.valk_type("type", "u8")
        let flags = vgen_ptrv(on, type_u8, vgen_int(-4, b.valk_type("type", "int")))
        let mask = vgen_op(flags, vgen_int(4, type_u8), OP.bit_and, type_u8)
        let cmp = vgen_compare(mask, vgen_int(4, type_u8), OP.eq, b.valk_type("type", "bool"))
        return cmp
    }

    p.error("Unknown property/function: '" + name + "' on type: '" + on.rett + "'")
}

fn match_op_values(b: Build, left: Value, right: Value) (Value, Value) {

    let type_uint = type_valk(b, "uint") 
    if left.rett.is_voidptr() : left = vgen_cast(left, type_uint)
    if right.rett.is_voidptr() : right = vgen_cast(right, type_uint)

    let t1 = left.rett
    let t2 = right.rett

    if !t1.is_number() || !t2.is_number() : return (left, right)

    if left.type == VAL.int && right.type != VAL.int {
        if t2.fits_intv(left.int, t1.is_signed) {
            left.rett = t2
            return (left, right)
        }
    } else if right.type == VAL.int && left.type != VAL.int {
        if t1.fits_intv(right.int, t2.is_signed) {
            right.rett = t1
            return (left, right)
        }
    }

    let is_signed = t1.is_signed || t2.is_signed;
    let is_float = t1.is_float() || t2.is_float();
    let s1 = t1.size()
    let s2 = t2.size()

    let size = is_float ? helper:max_uint(s1, s2) : <{
        let x1 = s1 < b.ptr_size && t1.is_signed != is_signed ? s1 * 2 : s1
        let x2 = s2 < b.ptr_size && t2.is_signed != is_signed ? s2 * 2 : s2
        return helper:max_uint(x1, x2)
    }

    if size > b.ptr_size : return (left, right)

    let type = type_number(b, size, is_float, is_signed);
    
    if t1.type != type.type || t1.is_signed != type.is_signed || t1.size() != type.size() {
        left = vgen_cast(left, type)
    }
    if t2.type != type.type || t2.is_signed != type.is_signed || t2.size() != type.size() {
        right = vgen_cast(right, type)
    }

    return (left, right)
}

fn value_handle_op(p: Parser, scope: Scope, op: int, left: Value, right: Value) Value {
    let b = p.build
    let str_class = b.valk_class("type", "String")
    let lrett = left.rett
    let rrett = right.rett
    let lclass = lrett.get_class() !? null
    let rclass = rrett.get_class() !? null

    if op == OP.add {
        // _to_string
        if lclass == str_class || rclass == str_class {
            if !lrett.nullable && !rrett.nullable {
                if lclass != str_class {
                    left = left.try_convert(p.ctx, scope, rrett)
                    lrett = left.rett
                    lclass = lrett.get_class() !? null
                } else if rclass != str_class {
                    right = right.try_convert(p.ctx, scope, lrett)
                    rrett = right.rett
                    rclass = rrett.get_class() !? null
                }
            }
        }

        // _add
        if !lrett.nullable {

            if isset(lclass) {
                let func = lclass.get_add_hook(right.rett) !? null
                if !isset(func) {
                    let mode_for = lclass.mode_for_class
                    if isset(mode_for) : func = mode_for.get_add_hook(right.rett) !? null
                }

                if isset(func) {
                    if !func.is_generic_base {
                        let fptr = vgen_func_ptr(func)
                        let arg = func.args.get(0) !? null
                        if isset(arg) {
                            right = right.try_convert(p.ctx, scope, lrett)
                            arg.type.compat_check(right.rett, p.ctx)
                            let values = Array[Value]{ left, right }
                            let call = vgen_func_call(b, scope, fptr, values)
                            return call
                        }
                    }
                }
            }
        }
    }

    if lrett.type == TYPE.voidptr && (op == OP.add || (op == OP.sub && right.type == VAL.int)) {
        let r = right.try_convert(p.ctx, scope, b.valk_type("type", "int"))
        if r.rett.type == TYPE.int {
            if op == OP.sub : r.int *= -1
            return vgen_ptr_offset(left, r)
        }
    }

    if !lrett.allow_math() || !rrett.allow_math() : p.error("Cannot do math operations on types: '" + left.rett + "' <> '" + right.rett + "'")

    let l, r = match_op_values(b, left, right)

    if (op == OP.shl || op == OP.shr) {
        if !l.rett.is_int() : p.error("Left value must be an integer for this operator")
        if !r.rett.is_int() : p.error("Right value must be an integer for this operator")
    }

    // Pre-calculate
    if l.type == VAL.int && r.type == VAL.int && l.rett.compat(r.rett) {
        let signed = l.rett.is_signed
        let op_found = true
        if signed {
            let val = l.int.to(i64)
            let rval = r.int.to(i64)
            if op == OP.add : val = val + rval
            else if op == OP.sub : val = val - rval
            else if op == OP.mul : val = val * rval
            else if op == OP.div : val = val / rval
            else if op == OP.mod : val = val % rval
            else if op == OP.bit_and : val = val & rval
            else if op == OP.bit_or : val = val | rval
            else if op == OP.bit_xor : val = val ^ rval
            else if op == OP.shl : val = val << rval
            else if op == OP.shr : val = val >> rval
            else : op_found = false
            if op_found : return vgen_int(val, l.rett)
        } else {
            let val = l.int.to(u64)
            let rval = r.int.to(u64)
            if op == OP.add : val = val + rval
            else if op == OP.sub : val = val - rval
            else if op == OP.mul : val = val * rval
            else if op == OP.div : val = val / rval
            else if op == OP.mod : val = val % rval
            else if op == OP.bit_and : val = val & rval
            else if op == OP.bit_or : val = val | rval
            else if op == OP.bit_xor : val = val ^ rval
            else if op == OP.shl : val = val << rval
            else if op == OP.shr : val = val >> rval
            else : op_found = false
            if op_found : return vgen_int(val.to(int), l.rett)
        }
    }

    l.rett.compat_check(r.rett, p.ctx)

    let v = vgen_op(l, r, op, l.rett)

    return v
}


fn handle_class(p: Parser, class: Class, scope: Scope, prev_token_was_dot: bool (false)) Value {

    let b = p.build

    let macros = class.macros
    if isset(macros) {
        p.tok(true, true, false)
        if !p.word_is("{") || p.func().fc != class.fc {
            let w = p.word()
            let m = macros.get(w) !? null
            if isset(m) {
                return read_macro_value(p, scope, m)
            }
        }
    }

    p.tok(false, false, false)

    if p.word_is(".") || prev_token_was_dot {
        if p.word_is(".") : p.tok(true, true)
        if p.lsp : p.build.getlsp().check_completion_on_class(class, p.chunk.fc)

        let name = p.read_word(false, false)
        let is_lsp = p.lsp
        // Check group
        let group = class.get_group(name) !? null
        if isset(group) {
            if is_lsp : p.build.getlsp().check_group_definition(group)
            p.expect(".", false, false)
            if p.lsp : p.build.getlsp().check_completion_on_group(group, p.chunk.fc)
            name = p.read_word(false, false)
            is_lsp = p.lsp
        }
        // Static function
        let func : ?Func = null
        if isset(group) {
            func = group.funcs.get(name) !? null
        }
        if !isset(func) {
            func = class.get_func(name) !? null
        }
        if !isset(func) {
            p.error("There's no function named '" + name + "' in the class '" + class.display_name + "'")
        }
        if is_lsp : p.build.getlsp().check_func_definition(func)
        if func.is_generic_base : func = read_func_generic(p, scope, func)
        check_act(p, func.act, func.fc, false, "function")
        
        func.used_in(scope)

        if func.is_getter {
            let values = Array[Value]{}
            let fptr = vgen_func_ptr(func)
            let call = vgen_func_call(b, scope, fptr, values)
            return call
        }

        return vgen_func_ptr(func)
    }

    if !class.is_structural() : p.error_token()

    p.tok(true, true)
    if !p.word_is("{") : p.error("Expected '.' or '{' after a class name")

    // Class init
    return parse_class_init(p, scope, class, null)
}

fn handle_enum(p: Parser, e: Enum, scope: Scope) Value {
    p.expect(".", false, false)
    if p.lsp : p.build.getlsp().check_completion_on_enum(e)

    let name = p.read_word(false, false)
    let values = e.values
    let chunk = values.get(name) ! p.error("Enum " + e.display_name + " does not have a value named: '" + name + "'")
    let type = e.get_type()
    if isset(chunk) {
        let fc = e.fc
        let escope = fc.scope
        // Read value
        let sp = p.new_sub_parser(chunk)
        sp.set_suggest(type)
        let v = read_value(sp, escope)
        // itype.compat_check(v.rett, p)
        sp.pop_suggest()
        //
        v.rett = type
        return v
    }

    let b = e.build
    let int_type = b.valk_type("type", "int")
    let suggest_type = p.suggest_type
    if isset(suggest_type) {
        if suggest_type.type == TYPE.int {
            int_type = suggest_type
        }
    }
    let intv = e.values_int.get(name) ! p.error("Missing integer value for enum item (bug)")
    return vgen_int(intv, int_type)
}


fn read_inline_scope_value(p: Parser, scope: Scope) Value {
    let t = p.tok(true, false, false)
    if t == TOK.none : p.error("Missing error value / code")
    let single_line = true
    if p.word_is("{") {
        single_line = false
        p.tok(true, true)
    }
    read_ast(p, scope, single_line)

    let b = p.build
    let rett = type_void(b)
    if scope.did_return {
        rett = type_none(b)
    }

    return vgen_inline_scope(scope, rett)
}
