
struct Value {
    type: int
    func: ?Func (null)
    values: ?Array[Value] (null)
    string: String ("")
    decl: ?Decl (null)
    value1: ?Value (null)
    value2: ?Value (null)
    value3: ?Value (null)
    prop: ?Prop (null)
    global: ?Global (null)
    int: int (0)
    rett: Type
    bool1: bool (false)
    bool2: bool (false)

    fn get_rett_class() Class !no_class {
        let class = this.rett.class
        if !isset(class) : throw no_class
        return class
    }

    fn assignable() bool {
        let type = this.type
        return type == v_decl || type == v_prop || type == v_ptrv
    }

    fn try_convert(type: Type) Value {

        if type.is_void() : return this
        let vrett = this.rett
        let b = vrett.build

        // _to_string
        let str_class = b.valk_class("type", "String")
        if type.class == str_class && !vrett.nullable {
            let class = vrett.class
            if isset(class) {
                let to_str = class.funcs.get("_string") ? null
                if isset(to_str) {
                    let fptr = vgen_func_ptr(to_str)
                    return vgen_func_call(b, fptr, array[Value]{ this })
                }
            }
        }

        // Number -> Number
        if vrett.is_number() && type.is_number() {
            // int -> float
            if vrett.is_int() && type.is_float() {
                return vgen_cast(this, type)
            }
            // f32 -> f64
            else if vrett.is_float() && type.is_float() {
                if vrett.size() < type.size() {
                    return vgen_cast(this, type)
                }
            }
            // i8 -> ixx OR u8 -> ixx
            else if vrett.size() < type.size() {
                if vrett.is_signed && !type.is_signed : return this
                return vgen_cast(this, type)
            }

            return this
        }

        // To ptr
        let ptr_class = b.valk_class("type", "ptr")
        if type.class == ptr_class {
            if vrett.class != ptr_class && vrett.is_pointer {
                // any-pointer -> ptr
                this.rett = ptr_class.get_type()
            } else if vrett.is_int() {
                // int -> ptr
                return vgen_cast(this, type)
            }
        }

        return this
    }
}

fn read_value(p: Parser, scope: Scope, prio: int (99999)) Value {

    let b = p.build
    let v: ?Value = null
    let t = p.tok(true, true)

    let negative = false
    if p.sign_is("-") {
        negative = true
        t = p.tok(false, false)
        if t != tok_int || t != tok_float || t != tok_hex || t != tok_octal {
            p.error("Expected a valid number after: '-'")
        }
    }

    if t == tok_word {
        if p.word_is("sizeof") {
            p.expect("(", false, false)
            let type = read_type(p, scope, true)
            p.expect(")", true, true)
            let rett = p.suggest_type ?? type_valk(b, "int")
            if rett.is_int() : rett = type_valk(b, "int")
            v = vgen_int(type.size() @as int, rett)
        } else if p.word_is("true") || p.word_is("false") {
            v = vgen_bool(b, p.word_is("true"))
        } else {
            // Identifier
            let id = Id.read_full(p, p.word())
            let idf = scope.find_or_err(p, id)
            v = handle_idf(p, scope, idf)
        }
    } else if t == tok_at_word {
        if p.word_is("@memcpy") {
            p.expect("(", false, false)
            let type_ptr = type_valk(b, "ptr")
            let type_uint = type_valk(b, "uint")
            let types = array[Type]{ type_ptr, type_ptr, type_uint }
            let values = p.read_values_type_checked(scope, types, ")")
            let from = values.get(0) ! p.error("Missing @memcpy argument 1")
            let to = values.get(1) ! p.error("Missing @memcpy argument 2")
            let len = values.get(2) ! p.error("Missing @memcpy argument 3")
            //
            v = vgen_memcpy(b, from, to, len)
        } else if p.word_is("@ptrv") {
            p.expect("(", false, false)
            let type_ptr = type_valk(b, "ptr")
            let type_int = type_valk(b, "int")
            let on = read_value(p, scope)
            type_ptr.compat_check(on.rett, p)
            p.expect(",", true, true)
            let type = read_type(p, scope, true)
            p.expect(",", true, true)
            let offset = read_value(p, scope)
            if !offset.rett.is_int() : p.error("Expected a number value, not: " + offset.rett)
            p.expect(")", true, true)
            //
            v = vgen_ptrv(on, type, offset)
        }
    } else if t == tok_string {
        let body = p.word()
        body = body.sub_str(1, body.bytes - 2).unescape()
        v = vgen_string(b, body)
    } else if t == tok_int || t == tok_hex || t == tok_octal {
        let value = (p.integer_value() ! p.error("Failed to convert number string to value (bug)"))
        let fit_int = value <= 0x7FFFFFFFFFFFFFFF
        if negative && !fit_int : p.error("Number too large")
        let type = type_int(b)
        let suggest = p.suggest_type
        if isset(suggest) && type.type == ty_int {
            type = suggest
        }
        v = vgen_int((value @as int) * (negative ? -1 : 1), type)
    } else if t == tok_float {
        p.error("Float parsing: TODO")
    } else if t == tok_sign {
        if p.sign_is("(") {
            v = read_value(p, scope)
            p.expect(")", true, true)
        }
    }

    if !isset(v) {
        p.error("Unknown value/token: '" + p.word() + "'")
    }
    if v.rett.is_void() || v.rett.is_undefined() : return v

    // Trailing characters
    t = p.tok(false, false, false)
    while t == tok_sign && (p.word_is(".") || p.word_is("(") || p.word_is("++") || p.word_is("--")) {
        t = p.tok(false, false)

        if p.word_is(".") {
            // Class properties
            v = value_prop_access(p, scope, v)
        } else if p.word_is("(") {
            // Function call
            v = value_func_call(p, scope, v)
        } else if p.word_is("++") || p.word_is("--") {
            // ++ / --
            if p.word_is("++") : v = vgen_incr(v)
            else : v = vgen_decr(v)
        }

        t = p.tok(false, false, false)
    }

    t = p.tok(true, true, false)
    while p.word_is("@as") {
        p.tok(true, true)
        let type = read_type(p, scope, false)
        v = vgen_cast(v, type)
        t = p.tok(true, true, false)
    }

    t = p.tok(true, true, false)
    if prio > 10 {
        while t == tok_sign && (p.word_is("/") || p.word_is("*") || p.word_is("%")) {
            t = p.tok(true, true)
            let op = op_mul
            if p.word_is("/") : op = op_div
            else if p.word_is("%") : op = op_mod
            let lrett = v.rett
            p.set_suggest(lrett)
            let right = read_value(p, scope, 10)
            p.pop_suggest()
            right = right.try_convert(lrett)
            lrett.compat_check(right.rett, p)
            v = vgen_op(v, right, op, v.rett)
            t = p.tok(true, true, false)
        }
    }

    if prio > 20 {
        while t == tok_sign && (p.word_is("+") || p.word_is("-")) {
            t = p.tok(true, true)
            let op = p.word_is("-") ? op_sub : op_add
            let lrett = v.rett
            p.set_suggest(lrett)
            let right = read_value(p, scope, 20)
            p.pop_suggest()
            right = right.try_convert(lrett)
            lrett.compat_check(right.rett, p)
            v = vgen_op(v, right, op, v.rett)
            t = p.tok(true, true, false)
        }
    }

    if prio > 40 {
        while t == tok_sign && (p.word_is("!=") || p.word_is("==") || p.word_is("<=") || p.word_is(">=") || p.word_is("<") || p.word_is(">")) {
            t = p.tok(true, true)
            //
            let op = op_eq
            if p.word_is("!=") : op = op_ne
            else if p.word_is("<=") : op = op_lte
            else if p.word_is(">=") : op = op_gte
            else if p.word_is("<") : op = op_lt
            else if p.word_is(">") : op = op_gt
            //
            let lrett = v.rett
            p.set_suggest(lrett)
            let right = read_value(p, scope, 40)
            p.pop_suggest()
            right = right.try_convert(lrett)
            lrett.compat_check(right.rett, p)
            v = vgen_op(v, right, op, type_valk(b, "bool"))
            t = p.tok(true, true, false)
        }
    }

    if prio > 50 {
        while t == tok_sign && (p.word_is("&&") || p.word_is("||")) {
            t = p.tok(true, true)
            let op = p.word_is("&&") ? op_and : op_or

            let lrett = v.rett
            if !lrett.is_bool() : p.error("Expected a value of type 'bool', not: " + lrett)

            let right = read_value(p, scope, 50)
            if !right.rett.is_bool() : p.error("Expected a value of type 'bool', not: " + lrett)

            v = vgen_op(v, right, op, lrett)
            t = p.tok(true, true, false)
        }
    }

    //
    return v
}

fn handle_idf(p: Parser, scope: Scope, idf: Idf) Value {
    
    let for = idf.for

    if for == idf_func {
        let func = idf.func
        if isset(func) {
            return vgen_func_ptr(func)
        }
    }
    if for == idf_decl {
        let decl = idf.decl
        if isset(decl) {
            return vgen_decl(decl)
        }
    }

    p.error("Unhandled identifier type (type: " + for + ") (compiler bug)")
}

fn value_func_call(p: Parser, scope: Scope, on: Value) Value {

    let on_rett = on.rett
    let func_info = on_rett.func_info
    if !isset(func_info) : p.error("Function call on a non-function value")

    let args = func_info.args
    let values = array[Value]{}
    if on.type == v_func_ptr {
        let onn = on.value1
        if isset(onn) : values.push(onn)
    }

    let t = p.tok(true, true, false)
    if p.sign_is(")") : p.tok(true, true)
    let i : uint = 0
    while !p.sign_is(")") {
        let value = read_value(p, scope)
        let index = values.length
        let arg_type = args.get(i++) ! p.error("Too many arguments. Function type: " + on_rett)
        arg_type.compat_check(value.rett, p)
        values.push(value)
        p.expect2(",", ")", true, true)
    }

    // Default values
    if values.length < args.length {
    }

    if values.length < args.length {
        p.error("Not enough values to call this function. Function type: " + on_rett)
    }

    return vgen_func_call(p.build, on, values)
}

fn value_prop_access(p: Parser, scope: Scope, on: Value) Value {
    let on_class = on.get_rett_class() ! p.error("Cannot access properties/functions on this type: " + on.rett)
    let name = p.read_word(false, false)
    let prop = on_class.props.get(name) ? null
    if isset(prop) {
        return vgen_prop(prop, on)
    }
    let func = on_class.funcs.get(name) ? null
    if isset(func) {
        let fptr = vgen_func_ptr(func)
        fptr.value1 = on
        return fptr
    }
    p.error("Unknown class property/function: " + name)
}
