
use helper

struct IRValueCache {
    ir_value: String ("")
}

struct Value {
    type: int
    func: ?Func (null)
    issets: ?Array[Decl] (null)
    not_issets: ?Array[Decl] (null)
    values: ?Array[Value] (null)
    values_map: ?Map[Value] (null)
    multi_values: ?Array[Value] (null)
    ir_value_cache: ?IRValueCache (null)
    errh: ?ErrorHandler (null)
    string: String ("")
    string2: String ("")
    decl: ?Decl (null)
    value1: ?Value (null)
    value2: ?Value (null)
    value3: ?Value (null)
    prop: ?Prop (null)
    global: ?Global (null)
    scope1: ?Scope (null)
    int: int (0)
    rett: Type
    bool1: bool (false)
    bool2: bool (false)

    fn get_rett_class() Class !no_class {
        let class = this.rett.class
        if !isset(class) : throw no_class
        return class
    }

    fn assignable() bool {
        let type = this.type
        return type == v_decl || type == v_prop || type == v_ptrv || type == v_global
    }

    fn try_convert(decl_scope: Scope, type: Type) Value {

        if type.is_void() : return this
        let vrett = this.rett
        let b = vrett.build

        // _to_string
        let str_class = b.valk_class("type", "String")
        if type.class == str_class && !vrett.nullable {
            let class = vrett.class
            if isset(class) {
                let to_str = class.funcs.get("_string") ? null
                if isset(to_str) {
                    let fptr = vgen_func_ptr(to_str)
                    let values = array[Value]{ this }
                    return vgen_func_call(b, decl_scope, fptr, values)
                }
            }
        }

        // Number -> Number
        if vrett.is_number() && type.is_number() {
            // int -> float
            if vrett.is_int() && type.is_float() {
                return vgen_cast(this, type)
            }
            // f32 -> f64
            else if vrett.is_float() && type.is_float() {
                if vrett.size() < type.size() {
                    return vgen_cast(this, type)
                }
            }
            // i8 -> ixx OR u8 -> ixx
            else if vrett.size() < type.size() {
                if vrett.is_signed && !type.is_signed : return this
                return vgen_cast(this, type)
            }

            return this
        }

        // To ptr
        let ptr_class = b.valk_class("type", "ptr")
        if type.class == ptr_class {
            if vrett.class != ptr_class && vrett.is_pointer {
                // any-pointer -> ptr
                this.rett = ptr_class.get_type()
            } else if vrett.is_int() {
                // int -> ptr
                return vgen_cast(this, type)
            }
        }

        return this
    }

    fn needs_buffer() bool {
        if this.rett.is_gc() {
            if this.type == v_null : return false
            if this.type == v_decl : return false
            if this.type == v_buffer : return false
            if this.type == v_string : return false
            return true
        }
        return false
    }

    fn check_decl_mutable() {
        if this.type == v_decl {
            let decl = this.decl
            if isset(decl) {
                decl.is_mut = true
            }
        }
    }

    fn can_prealloc() bool {
        let vt = this.type
        if vt == v_int {
            return true
        } else if vt == v_static_array {
            let values = this.values
            if isset(values) {
                each values as v {
                    if !v.can_prealloc() : return false
                }
                return true
            }
        }
        return false
    }
}

fn read_value(p: Parser, scope: Scope, prio: int (99999)) Value {

    let b = p.build
    let v: ?Value = null
    let t = p.tok(true, true)

    let negative = false
    if p.sign_is("-") {
        negative = true
        t = p.tok(false, false)
        if t != tok_int && t != tok_float && t != tok_hex && t != tok_octal {
            p.error("Expected a valid number after: '-', found: '" + p.word() + "'")
        }
    }

    if t == tok_word {
        if p.word_is("sizeof") {
            p.expect("(", false, false)
            let type = read_type(p, scope, true)
            p.expect(")", true, true)
            let rett = p.suggest_type ?? type_valk(b, "int")
            if !rett.is_int() : rett = type_valk(b, "int")
            v = vgen_int(type.size() @as int, rett)
        } else if p.word_is("size_of_pool") {

            p.expect("(", false, false)
            let type = read_type(p, scope, true)
            p.expect(")", true, true)
            let tsize : uint = type.get_inline_type().size()
            let psize : uint = 0
            if tsize <= 16 * b.ptr_size {
                psize = tsize.round_up(b.ptr_size)
            } else {
                let i : uint = 16 * sizeof(ptr) * 2
                while i <= 4096 {
                    if tsize <= i {
                        psize = i
                        break
                    } 
                    i *= 2
                }
            }
            psize += 8
            
            let rett = p.suggest_type ?? type_valk(b, "int")
            if !rett.is_int() : rett = type_valk(b, "int")
            v = vgen_int(psize @as int, rett)

        } else if p.word_is("true") || p.word_is("false") {
            v = vgen_bool(b, p.word_is("true"))
        } else if p.word_is("isset") {
            p.expect("(", false, false)
            let on = read_value(p, scope)
            if !on.rett.nullable : p.error("You can only use isset on nullable types. Type found: " + on.rett)
            p.expect(")", true, true)
            let cmp = vgen_compare(on, vgen_null(on.rett), op_ne, type_valk(b, "bool"))
            add_isset(cmp, on)
            v = cmp

        } else if p.word_is("null") {
            let type = p.suggest_type
            if !isset(type) : p.error("Cannot find the type-hint for the 'null' value. See if you can add a type hint somewhere.")
            if !type.is_pointer : p.error("The type-hinted type for 'null' must be a pointer type. Type found: " + type)
            v = vgen_null(type)

        } else if p.word_is("co") {

            let before = p.reading_coro;
            p.reading_coro = true
            let on = read_value(p, scope, 1)
            p.reading_coro = before

            if on.type != v_func_call : p.error("Expected a function call statement after 'co' token");
            v = coro_generate(p, scope, on);

        } else if p.word_is("await") {

            let on = read_value(p, scope, 1)
            if on.rett.type != ty_promise {
                p.error("Using 'await' on a non-promise value. Value type: '" + on.rett + "'");
            }

            v = coro_await(p, scope, on);

        } else if p.word_is("error_is") {
            p.expect("(", false, false)

            let w = p.read_word(true, true)
            let id = Id.read_full(p, w)
            let idf = scope.find_or_err(p, id)

            let err_type = b.valk_type("type", "u32")

            if idf.for != idf_decl : p.error("First value in 'error_is' is not an error value")
            let decl = idf.decl
            if !isset(decl) : p.error("Missing error variable value (bug)")
            if decl.type.class != err_type.class : p.error("First value in 'error_is' is not an error type")

            let left = vgen_decl(decl)

            p.expect(",", true, true)

            let name = p.read_word(true, true)
            let nr = helper:ctxhash_u32(name)
            let right = vgen_int(nr, err_type)

            let l, r = match_op_values(b, left, right)
            l.rett.compat_check(r.rett, p)
            v = vgen_compare(l, r, op_eq, type_valk(b, "bool"))

            t = p.tok(true, true, false);
            while p.sign_is(",") {
                t = p.tok(true, true, true);

                let name = p.read_word(true, true)
                let nr = helper:ctxhash_u32(name)
                let right = vgen_int(nr, err_type)

                let l, r = match_op_values(b, left, right)
                l.rett.compat_check(r.rett, p)
                let next = vgen_compare(l, r, op_eq, type_valk(b, "bool"))

                if isset(v) : v = vgen_and_or(v, next, op_or, v.rett)

                t = p.tok(true, true, false);
            }

            p.expect(")", true, true)

        } else {
            // Identifier
            let id = Id.read_full(p, p.word())
            let idf = scope.find_or_err(p, id)
            v = handle_idf(p, scope, idf)
        }
    } else if t == tok_at_word {
        if p.word_is("@memcpy") {
            p.expect("(", false, false)
            let type_ptr = type_valk(b, "ptr")
            let type_uint = type_valk(b, "uint")
            let types = array[Type]{ type_ptr, type_ptr, type_uint }
            let values = p.read_values_type_checked(scope, types, ")")
            let from = values.get(0) ! p.error("Missing @memcpy argument 1")
            let to = values.get(1) ! p.error("Missing @memcpy argument 2")
            let len = values.get(2) ! p.error("Missing @memcpy argument 3")
            //
            v = vgen_memcpy(b, from, to, len)
        } else if p.word_is("@ptrv") {
            p.expect("(", false, false)
            let type_ptr = type_valk(b, "ptr")
            let type_int = type_valk(b, "int")
            let on = read_value(p, scope)
            on = on.try_convert(p.get_ds(), type_ptr)
            type_ptr.compat_check(on.rett, p)
            p.expect(",", true, true)
            let type = read_type(p, scope, true)
            p.expect2(",", ")", true, true)
            let offset = vgen_int(0, type_valk(b, "int"))
            if p.word_is(",") {
                let suggest = p.suggest_type
                p.suggest_type = type_int
                offset = read_value(p, scope)
                p.suggest_type = suggest
                if !offset.rett.is_int() : p.error("Expected a number value, not: " + offset.rett)
                p.expect(")", true, true)
            }
            //
            v = vgen_ptrv(on, type, offset)
        } else if p.word_is("@ptr_offset") {
            p.expect("(", false, false)
            let type_ptr = type_valk(b, "ptr")
            let type_int = type_valk(b, "int")
            // On
            let on = read_value(p, scope)
            on = on.try_convert(p.get_ds(), type_ptr)
            type_ptr.compat_check(on.rett, p)
            p.expect(",", true, true)
            // Offset
            let offset = read_value(p, scope)
            offset = offset.try_convert(p.get_ds(), type_int)
            if !offset.rett.is_int() : p.error("Expected a number value, not: " + offset.rett)
            p.expect(")", true, true)
            //
            v = vgen_ptr_offset(on, offset)

        } else if p.word_is("@ref") {
            p.expect("(", false, false)
            let on = read_value(p, scope)
            if !on.assignable() : p.error("Cannot use '@ref' on this value. It can only be used on assignable values, like variable names or object properties.")
            on.check_decl_mutable()
            p.expect(")", true, true)

            v = vgen_ref(on)

        } else if p.word_is("@global_default_value") {
            p.expect("(", false, false)

            let id = Id.read(p, true, true)
            let idf = scope.find_or_err(p, id)

            if idf.for != idf_global : p.error("Identifier is not a global variable")

            let g = idf.global
            if isset(g) {
                let chunk = g.chunk_value
                let fc = g.fc
                if isset(chunk) && isset(fc) {
                    let sp = p.new_sub_parser(chunk)
                    v = read_value(sp, fc.scope)
                }
            }
            if !isset(v) : v = vgen_undefined(b)
            // if !isset(v) : p.error("Global has no default value: " + type)
            p.expect(")", true, true)
        } else if p.word_is("@stack") {
            p.expect("(", false, false)
            let type = read_type(p, scope, true)
            v = vgen_stack_alloc(type)
            p.expect(")", true, true)

        } else if p.word_is("@undefined") {
            v = vgen_undefined(b)
        } else if p.word_is("@setjmp") {
            p.expect("(", false, false)
            let buf = read_value(p, scope)
            if !buf.rett.is_pointer {
                p.error("Value of @setjmp should be a pointer")
            }
            p.expect(")", true, true)
            v = vgen_setjmp(b, buf);
        } else if p.word_is("@longjmp") {
            p.expect("(", false, false)
            let buf = read_value(p, scope)
            if !buf.rett.is_pointer {
                p.error("Value of @longjmp should be a pointer")
            }
            p.expect(")", true, true)
            v = vgen_longjmp(b, buf);
            scope.did_return = true;
        }
    } else if t == tok_string {
        let body = p.word()
        body = body.sub_str(1, body.bytes - 2).unescape()
        v = vgen_string(b, body)
    } else if t == tok_char {
        let body = p.word()
        v = vgen_int(p.last_char, b.valk_type("type", "u8"))
    } else if t == tok_int || t == tok_hex || t == tok_octal {
        let value = (p.integer_value() ! p.error("Failed to convert number string to value (bug)"))
        let fit_int = value <= 0x7FFFFFFFFFFFFFFF
        if negative && !fit_int : p.error("Number too large")
        let type = type_int(b)
        let suggest = p.suggest_type
        if isset(suggest) : if suggest.is_int() : type = suggest
        v = vgen_int((value @as int) * (negative ? -1 : 1), type)
    } else if t == tok_float {
        p.error("Float parsing: TODO")
    } else if t == tok_sign {
        if p.sign_is("(") {
            v = read_value(p, scope)
            p.expect(")", true, true)
        } else if p.sign_is("!") {
            let val = read_value(p, scope, 1)
            if !val.rett.is_bool() : p.error("Expected a value of type 'bool' after '!', the value type we found was: " + val.rett)
            let res = vgen_not(val)
            // Flip issets if only 1, otherwise clear them
            let issets = val.issets
            let not_issets = val.not_issets
            let count = (isset(issets) ? issets.length : 0) + (isset(not_issets) ? not_issets.length : 0) 
            if count == 1 {
                res.issets = not_issets
                res.not_issets = issets
            }
            v = res

        } else if p.sign_is("++") {
            let t = p.tok(false, false, false)
            if t == tok_none : p.error("Missing value after '++'")
            let on = read_value(p, scope)
            if !on.assignable() || !on.rett.is_int() : p.error("Cannot use '++' on this value")
            on.check_decl_mutable()
            v = vgen_incr(on, true)
        } else if p.sign_is("--") {
            let t = p.tok(false, false, false)
            if t == tok_none : p.error("Missing value after '--'")
            let on = read_value(p, scope)
            if !on.assignable() || !on.rett.is_int() : p.error("Cannot use '--' on this value")
            on.check_decl_mutable()
            v = vgen_decr(on, true)

        } else if p.sign_is("<{") {
            // Value scope
            let before = p.vscope_decls
            p.vscope_decls = null
            let sub = scope.sub_scope(sc_vscope)
            read_ast(p, sub, false)
            let decls = p.vscope_decls ?? array[Decl]{}
            v = vgen_vscope(b, sub, decls)
            p.vscope_decls = before
        }
    }

    if !isset(v) {
        p.error("Unknown value/token: '" + p.word() + "'")
    }
    if v.rett.is_void() || v.rett.is_undefined() : return v

    // Trailing characters
    t = p.tok(false, false, false)
    while t == tok_sign && (p.word_is(".") || p.word_is("(") || p.word_is("++") || p.word_is("--")) {
        t = p.tok(false, false)

        if p.word_is(".") {
            // Class properties
            v = value_prop_access(p, scope, v)
        } else if p.word_is("(") {
            // Function call
            v = value_func_call(p, scope, v)
        } else if p.word_is("++") || p.word_is("--") {
            // ++ / --
            if !v.assignable() || !v.rett.is_int() : p.error("Cannot use '" + p.word() + "' on this value")
            v.check_decl_mutable()
            if p.word_is("++") : v = vgen_incr(v, false)
            else : v = vgen_decr(v, false)
        }

        t = p.tok(false, false, false)
    }

    t = p.tok(true, true, false)
    while p.word_is("@as") {
        p.tok(true, true)
        let type = read_type(p, scope, false)
        v = vgen_cast(v, type)
        t = p.tok(true, true, false)
    }

    t = p.tok(true, true, false)
    if prio > 10 {
        while t == tok_sign && (p.word_is("/") || p.word_is("*") || p.word_is("%")) {
            t = p.tok(true, true)
            let op = op_mul
            if p.word_is("/") : op = op_div
            else if p.word_is("%") : op = op_mod

            p.set_suggest(v.rett)
            let right = read_value(p, scope, 10)
            p.pop_suggest()
            v = value_handle_op(p, scope, op, v, right)

            t = p.tok(true, true, false)
        }
    }

    if prio > 20 {
        while t == tok_sign && (p.word_is("+") || p.word_is("-")) {
            t = p.tok(true, true)
            let op = p.word_is("-") ? op_sub : op_add

            p.set_suggest(v.rett)
            let right = read_value(p, scope, 20)
            p.pop_suggest()
            v = value_handle_op(p, scope, op, v, right)

            t = p.tok(true, true, false)
        }
    }

    if prio > 30 {
        while t == tok_sign && (p.word_is("<<") || p.word_is(">>")) {
            t = p.tok(true, true)
            let op = p.word_is("<<") ? op_shl : op_shr
            
            p.set_suggest(v.rett)
            let right = read_value(p, scope, 30)
            p.pop_suggest()
            v = value_handle_op(p, scope, op, v, right)

            t = p.tok(true, true, false)
        }
    }

    if prio > 35 {
        while t == tok_sign && (p.word_is("|") || p.word_is("&") || p.word_is("^")) {
            t = p.tok(true, true)
            let op = p.word_is("|") ? op_bit_or : (p.word_is("&") ? op_bit_and : op_bit_xor)
            
            p.set_suggest(v.rett)
            let right = read_value(p, scope, 35)
            p.pop_suggest()
            v = value_handle_op(p, scope, op, v, right)

            t = p.tok(true, true, false)
        }
    }

    if prio > 40 {
        while t == tok_sign && (p.word_is("!=") || p.word_is("==") || p.word_is("<=") || p.word_is(">=") || p.word_is("<") || p.word_is(">")) {
            t = p.tok(true, true)
            //
            let op = op_eq
            if p.word_is("!=") : op = op_ne
            else if p.word_is("<=") : op = op_lte
            else if p.word_is(">=") : op = op_gte
            else if p.word_is("<") : op = op_lt
            else if p.word_is(">") : op = op_gt
            //
            p.set_suggest(v.rett)
            let right = read_value(p, scope, 40)
            p.pop_suggest()

            let l, r = match_op_values(b, v, right)
            l.rett.compat_check(r.rett, p)
            v = vgen_compare(l, r, op, type_valk(b, "bool"))

            t = p.tok(true, true, false)
        }
    }

    if prio > 50 {
        while t == tok_sign && (p.word_is("&&") || p.word_is("||")) {
            t = p.tok(true, true)
            let op = p.word_is("&&") ? op_and : op_or

            let lrett = v.rett
            if !lrett.is_bool() : p.error("Expected a value of type 'bool', not: " + lrett)

            let sub = scope
            if op == op_and {
                sub = scope.sub_scope(sc_default)
                apply_issets(sub, v.issets)
            }

            let right = read_value(p, sub, 50)
            if !right.rett.is_bool() : p.error("Expected a value of type 'bool', not: " + lrett)

            v = vgen_and_or(v, right, op, lrett)
            t = p.tok(true, true, false)
        }
    }

    if prio > 60 {
        while p.word_is("?") {

            let cond = v
            if !cond.rett.is_bool() : p.error("You can only use '?' after values that return a bool. This value has type: " + cond.rett)
            t = p.tok(true, true)

            let v1 = read_value(p, scope)

            p.expect(":", true, true)

            p.set_suggest(v1.rett)
            let v2 = read_value(p, scope)
            p.pop_suggest()

            let l, r = match_op_values(b, v1, v2)
            let rett = l.rett
            if r.rett.nullable && !rett.nullable : rett = rett.get_nullable()
            rett.compat_check(r.rett, p)
            r.rett.compat_check(l.rett, p)

            v = vgen_this_that(cond, l, r, rett)

            t = p.tok(true, true, false)
        }
    }

    if prio > 70 {
        while p.word_is("??") || p.word_is("?!") {

            if !v.rett.nullable : p.error("You can only use '??' and '?!' on nullable values. Value type is: '" + v.rett + "'")
            let on = v

            t = p.tok(true, true)

            if p.word_is("??") {
                let alt = read_value(p, scope).try_convert(p.get_ds(), on.rett)
                on.rett.compat_check(alt.rett, p)
                v = Value {
                    type: v_altv
                    value1: on
                    value2: alt
                    rett: alt.rett
                }
            } else {
                let sub = scope.sub_scope(sc_default)
                t = p.tok(true, true, false)
                let single = !p.sign_is("{")
                if !single : p.tok(true, true)
                read_ast(p, sub, single)
                if !sub.did_return : p.error("Expected the code after '?!' to end with: return, exit, continue, break or throw")

                v = Value {
                    type: v_altv_break
                    value1: on
                    scope1: sub
                    rett: on.rett.get_non_nullable()
                }
            }

            t = p.tok(true, true, false)
        }
    }

    //
    return v
}

fn handle_idf(p: Parser, scope: Scope, idf: Idf) Value {
    
    let for = idf.for

    if for == idf_func {
        let func = idf.func
        if isset(func) {
            if func.is_generic_base : func = read_func_generic(p, scope, func)
            return vgen_func_ptr(func)
        }
    }
    if for == idf_decl {
        let decl = idf.decl
        if isset(decl) {
            let res = vgen_decl(decl)
            if res.rett.nullable && scope.not_null_check(decl) {
                res.rett = res.rett.get_non_nullable()
            }
            return res
        }
    }
    if for == idf_global {
        let g = idf.global
        if isset(g) {
            return vgen_global(g)
        }
    }
    if for == idf_alias {
        let alias = idf.alias
        if isset(alias) {
            let chunk = alias.chunk
            if alias.type == alias_value {
                let sp = p.new_sub_parser(chunk)
                let v = read_value(sp, alias.fc.scope)
                return v
            }
        }
    }
    if for == idf_class {
        let class = idf.class
        if isset(class) {
            if class.is_generic_base : class = read_class_generic(p, scope, class)
            return handle_class(p, class, scope)
        }
    }
    if for == idf_value {
        let value = idf.value
        if isset(value) : return value
    }

    p.error("Unhandled identifier type (type: " + for + ") (compiler bug)")
}

fn value_func_call(p: Parser, scope: Scope, on: Value) Value {

    let on_rett = on.rett
    let func_info = on_rett.func_info
    if !isset(func_info) : p.error("Function call on a non-function value")

    let i : uint = 0
    let args = func_info.args
    let values = array[Value]{}
    let func : ?Func = null
    let has_on = false
    if on.type == v_func_ptr {
        func = on.func
        let onn = on.value1
        if isset(onn) {
            has_on = true
            values.push(onn)
            i++
        }
    }

    let t = p.tok(true, true, false)
    if p.sign_is(")") : p.tok(true, true)
    while !p.sign_is(")") {

        let arg_type = args.get(i++) ? <{
            if func_info.infinite_args {
                let type = args.get(args.length - 1) ? null
                if isset(type) : return type
            }
            p.error("Too many arguments. Function type: " + on_rett)
        }

        p.set_suggest(arg_type)
        let value = read_value(p, scope)
        p.pop_suggest()

        value = value.try_convert(p.get_ds(), arg_type)
        arg_type.compat_check(value.rett, p)
        values.push(value)
        p.expect2(",", ")", true, true)
    }

    // Default values
    if values.length < args.length {
        if isset(func) {
            while true {
                let arg = func.args.get(i++) ! break
                let chunk = arg.chunk_value
                if !isset(chunk) : break
                let sp = p.new_sub_parser(chunk)
                sp.set_suggest(arg.type)
                let v = read_value(sp, func.scope)
                arg.type.compat_check(v.rett, p)
                values.push(v)
            }
        }
    }

    if values.length < args.length {
        p.error("Not enough values to call this function. Function type: " + on_rett)
    }

    // Exit func check
    if on.type == v_func_ptr {
        let func = on.func @as Func
        if func.is_exit {
            scope.did_return = true
            scope.did_exit = true
        }
    }

    let res = vgen_func_call(p.build, p.get_ds(), on, values)

    if func_info.can_error {
        res = value_error_handling(p, scope, res, func_info)
    }

    return res
}

fn value_prop_access(p: Parser, scope: Scope, on: Value) Value {
    let on_class = on.get_rett_class() ! p.error("Cannot access properties/functions on this type: " + on.rett)
    let name = p.read_word(false, false)
    let prop = on_class.props.get(name) ? null
    if isset(prop) {
        return vgen_prop(prop, on)
    }
    let func = on_class.funcs.get(name) ? null
    if isset(func) {
        if func.is_generic_base : func = read_func_generic(p, scope, func)
        let fptr = vgen_func_ptr(func)
        fptr.value1 = on
        return fptr
    }
    p.error("Unknown property/function: '" + name + "' on type: '" + on.rett + "'")
}

fn match_op_values(b: Build, left: Value, right: Value) (Value, Value) {

    let type_uint = type_valk(b, "uint") 
    if left.rett.is_ptr() : left = vgen_cast(left, type_uint)
    if right.rett.is_ptr() : right = vgen_cast(right, type_uint)

    let t1 = left.rett
    let t2 = right.rett

    if !t1.is_number() || !t2.is_number() : return left, right

    if left.type == v_int && right.type != v_int {
        if t2.fits_intv(left.int, t1.is_signed) {
            left.rett = t2
            return left, right
        }
    } else if right.type == v_int && left.type != v_int {
        if t1.fits_intv(right.int, t2.is_signed) {
            right.rett = t1
            return left, right
        }
    }

    let is_signed = t1.is_signed || t2.is_signed;
    let is_float = t1.is_float() || t2.is_float();
    let s1 = t1.size()
    let s2 = t2.size()

    let size = is_float ? helper:max_uint(s1, s2) : <{
        let x1 = t1.is_signed != is_signed ? s1 * 2 : s1
        let x2 = t2.is_signed != is_signed ? s2 * 2 : s2
        return helper:max_uint(x1, x2)
    }

    if size > 8 : return left, right

    let type = type_number(b, size, is_float, is_signed);
    
    if t1.type != type.type || t1.is_signed != type.is_signed || t1.size() != type.size() {
        left = vgen_cast(left, type)
    }
    if t2.type != type.type || t2.is_signed != type.is_signed || t2.size() != type.size() {
        right = vgen_cast(right, type)
    }

    return left, right
}

fn value_handle_op(p: Parser, scope: Scope, op: int, left: Value, right: Value) Value {
    let b = p.build
    let str_class = b.valk_class("type", "String")
    let lrett = left.rett
    let rrett = right.rett

    if op == op_add {
        // _to_string
        if lrett.class == str_class || rrett.class == str_class {
            if !lrett.nullable && !rrett.nullable {
                if lrett.class != str_class {
                    left = left.try_convert(p.get_ds(), rrett)
                    lrett = left.rett
                } else if rrett.class != str_class {
                    right = right.try_convert(p.get_ds(), lrett)
                    rrett = right.rett
                }
            }
        }

        // _add
        if !lrett.nullable {
            let lclass = lrett.class
            if isset(lclass) {
                let func = lclass.funcs.get("_add") ? null
                if isset(func) {
                    if !func.is_generic_base {
                        let fptr = vgen_func_ptr(func)
                        let arg = func.args.get(0) ? null
                        if isset(arg) {
                            right = right.try_convert(p.get_ds(), lrett)
                            arg.type.compat_check(right.rett, p)
                            let values = array[Value]{ left, right }
                            let call = vgen_func_call(b, p.get_ds(), fptr, values)
                            return call
                        }
                    }
                }
            }
        }
    }

    if !lrett.allow_math() || !rrett.allow_math() : p.error("Cannot do math operations on types: '" + left.rett + "' <> '" + right.rett + "'")

    let l, r = match_op_values(b, left, right)

    l.rett.compat_check(r.rett, p)

    let v = vgen_op(l, r, op, l.rett)

    return v
}


fn handle_class(p: Parser, class: Class, scope: Scope) Value {
    p.tok(false, false, false)
    if p.word_is(".") {
        p.tok(true, true)
        // Static function
        let name = p.read_word(false, false)
        let func = class.funcs.get(name) ! p.error("There's no static function named: '" + name + "'")
        if func.is_generic_base : func = read_func_generic(p, scope, func)
        return vgen_func_ptr(func)
    }

    if !class.is_structural() : p.error_token()

    p.tok(true, true)
    if !p.word_is("{") : p.error("Expected '.' or '{' after a class name")

    let props = class.props
    let values = Map[Value]{}
    let vt = class.vtable

    p.tok(true, true)
    while !p.word_is("}") {
        let name = p.word()
        let prop = props.get(name) ! p.error("There's no property named: '" + name + "'")
        if values.has(name) : p.error("Duplicate property name: " + name)
        p.expect(":", true, false)
        // Value
        let type = prop.type
        p.set_suggest(type)
        let v = read_value(p, scope)
        p.pop_suggest()
        v = v.try_convert(p.get_ds(), type)
        type.compat_check(v.rett, p)
        values.set(name, v)
        // Next
        p.tok(true, true)
        if p.word_is(",") {
            p.tok(true, true)
        }
    }

    each props as name, prop {
        let v = values.get(name) ? <{
            // Default value
            let chunk = prop.chunk
            if !isset(chunk) : p.error("Missing value for property: " + name)
            let sp = p.new_sub_parser(chunk)
            sp.set_suggest(prop.type)
            let v = read_value(sp, prop.class.scope)
            prop.type.compat_check(v.rett, p)
            sp.pop_suggest()
            values.set(name, v)
            return v
        }
    }

    return vgen_class_init(class, p.get_ds(), values)
}
