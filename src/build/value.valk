
struct Value {
    type: int
    func: ?Func (null)
    values: ?Array[Value] (null)
    string: String ("")
    decl: ?Decl (null)
    value1: ?Value (null)
    value2: ?Value (null)
    value3: ?Value (null)
    prop: ?Prop (null)
    int: int (0)
    rett: Type

    fn get_rett_class() Class !no_class {
        let class = this.rett.class
        if !isset(class) : throw no_class
        return class
    }

    fn assignable() bool {
        let type = this.type
        return type == v_decl || type == v_prop
    }

    fn try_convert(type: Type) Value {
        return this
    }
}

fn read_value(p: Parser, scope: Scope, prio: int (99999)) Value {

    let b = p.build
    let v: ?Value = null
    let t = p.tok(true, true)

    let negative = false
    if p.sign_is("-") {
        negative = true
        t = p.tok(false, false)
        if t != tok_int || t != tok_float || t != tok_hex || t != tok_octal {
            p.error("Expected a valid number after: '-'")
        }
    }

    if t == tok_word {
        if p.word_is("sizeof") {
            p.expect("(", false, false)
            let type = read_type(p, scope, true)
            p.expect(")", true, true)
            let rett = p.suggest_type ?? type_valk(b, "int")
            if rett.is_int() : rett = type_valk(b, "int")
            v = vgen_int(type.size() @as int, rett)
        } else {
            // Identifier
            let id = Id.read_full(p, p.word())
            let idf = scope.find_or_err(p, id)
            v = handle_idf(p, scope, idf)
        }
    } else if t == tok_at_word {
        if p.word_is("@memcpy") {
            p.expect("(", false, false)
            let type_ptr = type_valk(b, "ptr")
            let type_uint = type_valk(b, "uint")
            let types = array[Type]{ type_ptr, type_ptr, type_uint }
            let values = p.read_values_type_checked(scope, types, ")")
            let from = values.get(0) ! p.error("Missing @memcpy argument 1")
            let to = values.get(1) ! p.error("Missing @memcpy argument 2")
            let len = values.get(2) ! p.error("Missing @memcpy argument 3")
            //
            v = vgen_memcpy(b, from, to, len)
        }
    } else if t == tok_string {
        let body = p.word()
        body = body.sub_str(1, body.bytes - 2).unescape()
        v = vgen_string(b, body)
    } else if t == tok_int || t == tok_hex || t == tok_octal {
        let value = (p.integer_value() ! p.error("Failed to convert number string to value (bug)"))
        let fit_int = value <= 0x7FFFFFFFFFFFFFFF
        if negative && !fit_int : p.error("Number too large")
        let type = type_int(b)
        let suggest = p.suggest_type
        if isset(suggest) && type.type == ty_int {
            type = suggest
        }
        v = vgen_int((value @as int) * (negative ? -1 : 1), type)
    } else if t == tok_float {
        p.error("Float parsing: TODO")
    }

    if !isset(v) {
        p.error("Unknown value/token: '" + p.word() + "'")
    }

    // Trailing characters
    t = p.tok(false, false, false)
    while t == tok_sign && (p.word_is(".") || p.word_is("(") || p.word_is("++") || p.word_is("--")) {
        t = p.tok(false, false)

        if p.word_is(".") {
            // Class properties
            v = value_prop_access(p, scope, v)
        } else if p.word_is("(") {
            // Function call
            v = value_func_call(p, scope, v)
        } else if p.word_is("++") || p.word_is("--") {
            // ++ / --
            p.error("TODO")
        }

        t = p.tok(false, false, false)
    }

    t = p.tok(true, true, false)
    while p.word_is("@as") {
        p.error("@as TODO")
        p.tok(true, true)
    }

    t = p.tok(true, true, false)
    if prio > 10 {
        while t == tok_sign && (p.word_is("/") || p.word_is("*")) {
            t = p.tok(true, true)
            let op = p.word_is("/") ? op_div : op_mul
            let lrett = v.rett
            p.set_suggest(lrett)
            let right = read_value(p, scope, 10)
            p.pop_suggest()
            right = right.try_convert(lrett)
            lrett.compat_check(right.rett, p)
            v = vgen_op(v, right, op, v.rett)
            t = p.tok(true, true, false)
        }
    }

    t = p.tok(true, true, false)
    if prio > 20 {
        while t == tok_sign && (p.word_is("+") || p.word_is("-")) {
            t = p.tok(true, true)
            let op = p.word_is("-") ? op_sub : op_add
            let lrett = v.rett
            p.set_suggest(lrett)
            let right = read_value(p, scope, 20)
            p.pop_suggest()
            right = right.try_convert(lrett)
            lrett.compat_check(right.rett, p)
            v = vgen_op(v, right, op, v.rett)
            t = p.tok(true, true, false)
        }
    }

    //
    return v
}

fn handle_idf(p: Parser, scope: Scope, idf: Idf) Value {
    
    let for = idf.for

    if for == idf_func {
        let func = idf.func
        if isset(func) {
            return vgen_func_ptr(func)
        }
    }
    if for == idf_decl {
        let decl = idf.decl
        if isset(decl) {
            return vgen_decl(decl)
        }
    }

    p.error("Unhandled identifier type (type: " + for + ") (compiler bug)")
}

fn value_func_call(p: Parser, scope: Scope, on: Value) Value {

    let on_rett = on.rett
    let func_info = on_rett.func_info
    if !isset(func_info) : p.error("Function call on a non-function value")

    let args = func_info.args
    let values = array[Value]{}
    if on.type == v_func_ptr {
        let onn = on.value1
        if isset(onn) : values.push(onn)
    }

    let t = p.tok(true, true, false)
    if p.sign_is(")") : p.tok(true, true)
    let i : uint = 0
    while !p.sign_is(")") {
        let value = read_value(p, scope)
        let index = values.length
        let arg_type = args.get(i++) ! p.error("Too many arguments. Function type: " + on_rett)
        arg_type.compat_check(value.rett, p)
        values.push(value)
        p.expect2(",", ")", true, true)
    }

    // Default values
    if values.length < args.length {
    }

    if values.length < args.length {
        p.error("Not enough values to call this function. Function type: " + on_rett)
    }

    return vgen_func_call(p.build, on, values)
}

fn value_prop_access(p: Parser, scope: Scope, on: Value) Value {
    let on_class = on.get_rett_class() ! p.error("Cannot access properties/functions on this type: " + on.rett)
    let name = p.read_word(false, false)
    let prop = on_class.props.get(name) ? null
    if isset(prop) {
        return vgen_prop(prop, on)
    }
    let func = on_class.funcs.get(name) ? null
    if isset(func) {
        let fptr = vgen_func_ptr(func)
        fptr.value1 = on
        return fptr
    }
    p.error("Unknown class property/function: " + name)
}
