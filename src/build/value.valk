
struct Value {
    type: int
    func: ?Func (null)
    values: ?Array[Value] (null)
    string: String ("")
    decl: ?Decl (null)
    value1: ?Value (null)
    value2: ?Value (null)
    prop: ?Prop (null)
    int: int (0)
    rett: Type

    fn get_rett_class() Class !no_class {
        let class = this.rett.class
        if !isset(class) : throw no_class
        return class
    }

    fn assignable() bool {
        let type = this.type
        return type == v_decl || type == v_prop
    }
}

fn read_value(p: Parser, scope: Scope) Value {

    let b = p.build
    let v: ?Value = null
    let t = p.tok(true, true)

    let negative = false
    if p.sign_is("-") {
        negative = true
        t = p.tok(false, false)
        if t != tok_int || t != tok_float || t != tok_hex || t != tok_octal {
            p.error("Expected a valid number after: '-'")
        }
    }

    if t == tok_word {
        let id = Id.read_full(p, p.word())
        let idf = scope.find_or_err(p, id)
        v = handle_idf(p, scope, idf)
    } else if t == tok_string {
        let body = p.word()
        body = body.sub_str(1, body.bytes - 2).unescape()
        v = vgen_string(b, body)
    } else if t == tok_int || t == tok_hex || t == tok_octal {
        let value = (p.integer_value() ! p.error("Failed to convert number string to value (bug)"))
        let fit_int = value <= 0x7FFFFFFFFFFFFFFF
        if negative && !fit_int : p.error("Number too large")
        v = vgen_int((value @as int) * (negative ? -1 : 1), type_int(b))
    } else if t == tok_float {
        p.error("Float parsing: TODO")
    }

    if !isset(v) {
        p.error("Unknown value/token: '" + p.word() + "'")
    }

    // Trailing characters
    t = p.tok(false, false, false)
    while t == tok_sign && (p.word_is(".") || p.word_is("(") || p.word_is("++") || p.word_is("--")) {
        t = p.tok(false, false)

        if p.word_is(".") {
            // Class properties
            v = value_prop_access(p, scope, v)
        } else if p.word_is("(") {
            // Function call
            v = value_func_call(p, scope, v)
        } else if p.word_is("++") || p.word_is("--") {
            // ++ / --
            p.error("TODO")
        }

        t = p.tok(false, false, false)
    }

    //
    return v
}

fn handle_idf(p: Parser, scope: Scope, idf: Idf) Value {
    
    let for = idf.for

    if for == idf_func {
        let func = idf.func
        if isset(func) {
            return vgen_func_ptr(func)
        }
    }
    if for == idf_decl {
        let decl = idf.decl
        if isset(decl) {
            return vgen_decl(decl)
        }
    }

    p.error("Unhandled identifier type (type: " + for + ") (compiler bug)")
}

fn value_func_call(p: Parser, scope: Scope, on: Value) Value {

    let on_rett = on.rett
    let func_info = on_rett.func_info
    if !isset(func_info) {
        p.error("Function call on a non-function value")
    }

    let args = func_info.args
    let values = array[Value]{}
    let t = p.tok(true, true, false)
    while !p.sign_is(")") {
        let value = read_value(p, scope)
        let index = values.length
        let arg_type = args.get(0) ! p.error("Too many arguments. Function type: " + on_rett)
        arg_type.compat_check(value.rett, p)
        values.push(value)
    }

    if values.length < args.length {
        p.error("Not enough values to call this function. Function type: " + on_rett)
    }

    p.skip_body(")")
    return Value { type: 0, rett: type_void(p.build) }
}

fn value_prop_access(p: Parser, scope: Scope, on: Value) Value {
    let on_class = on.get_rett_class() ! p.error("Cannot access properties/functions on this type: " + on.rett)
    let name = p.read_word(false, false)
    let prop = on_class.props.get(name) ? null
    if isset(prop) {
        return vgen_prop(prop, on)
    }
    let func = on_class.funcs.get(name) ? null
    if isset(func) {
        return vgen_func_ptr(func)
    }
    p.error("Unknown class property/function: " + name)
}
