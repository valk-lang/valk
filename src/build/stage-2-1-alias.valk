
fn stage_alias(b: Build) {

    if b.verbose > 2 : b.log("> Stage 2.1: Read aliasses")

    each b.fc_by_path as fc {
        each fc.ns_uses as u {
            let chunk = u.extract_chunk
            if isset(chunk) {
                let p = Parser.new(chunk, null)
                if !p.next_word_is("}", true, true, true) {
                    while true {
                        let name = p.read_word(true, true)
                        let idf = u.nsc.scope.identifiers.get(name) ! p.error("Namespace '%{u.id}' has no identifier named '%{name}'")

                        if p.lsp && fc.is_lsp_file : b.getlsp().check_definition(idf, name)

                        fc.scope.set_idf(p, name, idf)
                        p.expect2(",", "}", true, true)
                        if p.word_is("}") : break
                    }
                }
            }
        }
    }

    each b.aliasses as alias {
        if alias.type == alias_idf {
            await (co fn(b: Build){
                let p = Parser.new(alias.chunk, null)
                let fc = alias.fc
                let scope = fc.scope

                let idf = p.read_idf(scope, true, true)
                fc.nsc.scope.identifiers.set(alias.name, idf)
                alias.for_idf = idf
            }(b)) ! continue
        }
    }

    each b.aliasses as alias {
        if alias.type == alias_type {
            await (co fn(b: Build){
                let p = Parser.new(alias.chunk, null)
                let type = read_type(p, alias.fc.scope)
                alias.fc.nsc.scope.identifiers.set(alias.name, Idf.for_type(type))
                alias.for_type = type
            }(b)) ! continue
        }
    }

    each b.extends as chunk {
        await (co fn(b: Build){
            let p = Parser.new(chunk, null)
            let fc = chunk.fc

            let scope = fc.scope
            let idf = p.read_idf(scope, true, false)

            let class = idf.class
            if !isset(class) || idf.for != idf_class : p.error("Identifier does not represent a class")

            let g_names : ?Map[GenericName] = null
            let base_names = class.generic_names
            if isset(base_names) {
                let names = Array[String]{}
                p.expect("[", false, false)
                g_names = read_generic_names(p)
            }

            p.expect("{", true, true)

            let e = Extend {
                class: class
                generic_names: g_names
                body: p.clone_chunk()
                scope: scope.sub_scope(sc_default)
            }

            class.extends.push(e)

            if b.verbose > 2 : b.log("Register extend for: " + class.display_name)
        }(b)) ! continue
    }

    stage_props(b)
}