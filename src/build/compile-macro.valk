

fn parse_compile_macro(p: Parser, scope: Scope) {
    let t = p.tok(false, false)

    if t == tok_word {
        if p.word_is("if") {
            let result = parse_compile_macro_condition(p, scope)
            let block = CmBlock.new(p, cm_block_if)
            block.if_result = result
            if result == 0 : parse_skip_compile_macro_block(p)
            return
        }
        if p.word_is("elif") {
            let block = CmBlock.get(p, cm_block_if) ! p.error("Unexpected '#elif' token. There's no previous #if to match with")
            if block.if_result == 0 {
                let result = parse_compile_macro_condition(p, scope)
                block.if_result = result
                if result == 0 : parse_skip_compile_macro_block(p)
            } else {
                parse_skip_compile_macro_block(p)
            }
            return
        }
        if p.word_is("else") {
            let block = CmBlock.get(p, cm_block_if) ! p.error("Unexpected '#else' token. There's no previous #if to match with")
            if block.if_result == 1 {
                parse_skip_compile_macro_block(p)
            }
            return
        }
        if p.word_is("end") {
            let block = CmBlock.pop(p, cm_block_any) ! p.error("Unexpected '#end' token. There's no previous #if to match with")
            if block.type == cm_block_loop_class {
                let start = block.start
                let classes = block.classes
                if isset(classes) {
                    let index = ++block.loop_index
                    let class = classes.get(index) ? null
                    let idf1 = block.idf1
                    if isset(start) && isset(class) && isset(idf1) {
                        p.set_chunk(start)
                        idf1.class = class
                        CmBlock.push(p, block)
                    }
                }
            } else if block.type == cm_block_loop_global {
                let start = block.start
                let list = block.globals
                if isset(list) {
                    let index = ++block.loop_index
                    let g = list.get(index) ? null
                    let idf1 = block.idf1
                    let idf2 = block.idf2
                    if isset(start) && isset(g) && isset(idf1) && isset(idf2) {
                        let type = g.type
                        if isset(type) {
                            p.set_chunk(start)
                            idf1.global = g
                            idf2.type = type
                            CmBlock.push(p, block)
                        }
                    }
                }
            } else if block.type == cm_block_loop_props {
                let start = block.start
                let list = block.props
                if isset(list) {
                    let index = ++block.loop_index
                    let val = list.get(index) ? null
                    let idf1 = block.idf1
                    let idf2 = block.idf2
                    if isset(start) && isset(val) && isset(idf1) && isset(idf2) {
                        p.set_chunk(start)
                        idf1.value = val
                        idf2.type = val.rett
                        CmBlock.push(p, block)
                    }
                }
            }
            return
        }
        if p.word_is("loop") {
            p.tok(true, false)
            if p.word_is("classes") {
                let name = p.read_word(true, false)
                p.expect_newline()
                //
                let classes = p.build.classes
                let class = classes.get(0) ! return
                // Loop
                let loop = CmBlock.new(p, cm_block_loop_class)
                loop.start = p.clone_chunk()
                loop.classes = classes

                // Idf
                let idf = Idf.for_class(class)
                loop.set_idf(p, name, idf)

                loop.idf1 = idf
            } else if p.word_is("globals") {

                let name_g = p.read_word(true, false)
                let name_type = p.read_word(true, false)
                p.expect_newline()
                //
                let globals = p.build.globals
                let g = globals.get(0) ! return
                // Loop
                let loop = CmBlock.new(p, cm_block_loop_global)
                loop.start = p.clone_chunk()
                loop.globals = globals

                // Idf
                let idf = Idf.for_global(g)
                loop.set_idf(p, name_g, idf)
                let type = g.type
                if !isset(type) : p.error("Missing global type in loop globals (bug)")
                let idf_type = Idf.for_type(type)
                loop.set_idf(p, name_type, idf_type)

                loop.idf1 = idf
                loop.idf2 = idf_type

            } else if p.word_is("properties") {

                let id = Id.read(p, true, true)
                let idf = scope.find_or_err(p, id)
                if idf.for != idf_decl : p.error("Expected a variable as the first argument")
                let decl = idf.decl
                if !isset(decl) : p.error("Missing decl value in loop properties (bug)")
                let class = decl.type.class
                if !isset(class) : p.error("Loop properties value has no class type")

                p.expect("as", true, false)
                let name_prop = p.read_word(true, false)
                p.expect(",", true, false)
                let name_type = p.read_word(true, false)
                p.expect_newline()
                //
                let props = class.props
                let items = array[Value]{}
                each props as prop {
                    items.push(vgen_prop(prop, vgen_decl(decl)))
                }
                let item = items.get(0) ! return
                // Loop
                let loop = CmBlock.new(p, cm_block_loop_props)
                loop.start = p.clone_chunk()
                loop.props = items

                // Idf
                let idf_prop = Idf.for_value(item)
                loop.set_idf(p, name_prop, idf_prop)
                let idf_type = Idf.for_type(item.rett)
                loop.set_idf(p, name_type, idf_type)

                loop.idf1 = idf_prop
                loop.idf2 = idf_type
            } else {
                p.error("Unexpected token: '" + p.word() + "'. Expected tokens after '#loop' are: classes")
            }
            return
        }
    }

    p.error_token()
}

fn parse_skip_compile_macro_block(p: Parser) {
    let depth = 1
    while true {
        p.backup()
        let t = p.tok(true, true)
        if t == tok_end : p.error("Missing compile macro '#end' token")
        if p.on_newline && p.sign_is("#") {

            t = p.tok(false, false)

            if p.word_is("if") : depth++
            else if p.word_is("end") : depth--
            else if depth == 1 && (p.word_is("else") || p.word_is("elif")) : depth--

            if depth == 0 {
                p.restore()
                break
            }
        }
    }
}

fn parse_skip_compile_macro(p: Parser) {
    let t = p.tok(false, false)

    if t == tok_word {
        if p.word_is("if") {
            let block = CmBlock.new(p, cm_block_if)
            block.if_result = 0
            parse_skip_compile_macro_block(p)
            return
        }
        if p.word_is("loop") {
            let block = CmBlock.new(p, cm_block_if)
            block.if_result = 0
            parse_skip_compile_macro_block(p)
            return
        }
        if p.word_is("elif") {
            let block = CmBlock.get(p, cm_block_if) ! p.error("Unexpected '#elif' token. There's no previous #if to match with")
            parse_skip_compile_macro_block(p)
            return
        }
        if p.word_is("else") {
            let block = CmBlock.get(p, cm_block_if) ! p.error("Unexpected '#else' token. There's no previous #if to match with")
            return
        }
        if p.word_is("end") {
            let block = CmBlock.pop(p, cm_block_any) ! p.error("Unexpected '#end' token. There's no previous #if to match with")
            return
        }
    }
}

fn parse_compile_macro_condition(p: Parser, scope: Scope) u8 {
    let t = p.tok(true, false)
    let defs = p.build.cm_defs
    let result: u8 = 2

    if t == tok_word {
        let word = p.word()
        let def_value = defs.get(word) ! p.error("Unknown compile macro definition: '" + word + "'")
        result = def_value == "0" ? 0 : 1

        t = p.tok(true, false, false)
        if t == tok_sign && (p.word_is("==") || p.word_is("!=")) {
            t = p.tok(true, false)
            let not_eq = p.word_is("!=")
            t = p.tok(true, false)
            if t == tok_word {
                let value = p.word()
                result = def_value == value ? 1 : 0
            } else if t == tok_int {
                let value = p.word()
                result = def_value == value ? 1 : 0
            } else {
                p.error("Invalid right side value: '" + p.word() + "'")
            }

            if not_eq {
                result = result == 1 ? 0 : 1
            }
        }
    } else if t == tok_at_word {
        if p.word_is("@is_gc_type") {
            p.expect("(", false, false)
            let type = read_type(p, scope, false)
            result = type.is_gc() ? 1 : 0
            p.expect(")", true, false)
        } else if p.word_is("@is_nullable_type") {
            p.expect("(", false, false)
            let type = read_type(p, scope, false)
            result = type.nullable ? 1 : 0
            p.expect(")", true, false)
        }
    } else if t == tok_sign {
        if p.word_is("!") {
            result = parse_compile_macro_condition(p, scope)
            result == 1 ? 0 : 1
        }
    }

    if result == 2 {
        p.error_token()
    }

    return result
}

fn parse_compile_macro_scope_end_check(p: Parser) {
    let block = p.cm_block
    if isset(block) {
        p.error("Missing compile macro '#end' token")
    }
}
