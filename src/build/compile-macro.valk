

fn parse_compile_macro(p: Parser) {
    let t = p.tok(false, false)

    if t == tok_word {
        if p.word_is("if") {
            let result = parse_compile_macro_condition(p)
            let block = CmBlock.new(p, cm_block_if)
            block.if_result = result
            if result == 0 : parse_skip_compile_macro_block(p)
            return
        }
        if p.word_is("elif") {
            let block = CmBlock.get(p, cm_block_if) ! p.error("Unexpected '#elif' token. There's no previous #if to match with")
            if block.if_result == 0 {
                let result = parse_compile_macro_condition(p)
                block.if_result = result
                if result == 0 : parse_skip_compile_macro_block(p)
            } else {
                parse_skip_compile_macro_block(p)
            }
            return
        }
        if p.word_is("else") {
            let block = CmBlock.get(p, cm_block_if) ! p.error("Unexpected '#else' token. There's no previous #if to match with")
            if block.if_result == 1 {
                parse_skip_compile_macro_block(p)
            }
            return
        }
        if p.word_is("end") {
            let block = CmBlock.pop(p, cm_block_any) ! p.error("Unexpected '#end' token. There's no previous #if to match with")
            if block.type == cm_block_loop_class {
                let start = block.start
                let classes = block.classes
                if isset(classes) {
                    let index = ++block.loop_index
                    let class = classes.get(index) ? null
                    let idf1 = block.idf1
                    if isset(start) && isset(class) && isset(idf1) {
                        p.set_chunk(start)
                        idf1.class = class
                        CmBlock.push(p, block)
                    }
                }
            }
            return
        }
        if p.word_is("loop") {
            p.tok(true, false)
            if p.word_is("classes") {
                let name = p.read_word(true, false)
                p.expect_newline()
                //
                let classes = p.build.classes
                let class = classes.get(0) ! p.error("Missing first class for #loop")
                // Loop
                let loop = CmBlock.new(p, cm_block_loop_class)
                loop.start = p.clone_chunk()
                loop.classes = classes

                // Idf
                let idf = Idf.for_class(class)
                loop.set_idf(p, name, idf)

                loop.idf1 = idf
            } else {
                p.error("Unexpected token: '" + p.word() + "'. Expected tokens after '#loop' are: classes")
            }
            return
        }
    }

    p.error_token()
}

fn parse_skip_compile_macro_block(p: Parser) {
    let depth = 1
    while true {
        p.backup()
        let t = p.tok(true, true)
        if t == tok_end : p.error("Missing compile macro '#end' token")
        if p.on_newline && p.sign_is("#") {

            t = p.tok(false, false)

            if p.word_is("if") : depth++
            else if p.word_is("end") : depth--
            else if depth == 1 && (p.word_is("else") || p.word_is("elif")) : depth--

            if depth == 0 {
                p.restore()
                break
            }
        }
    }
}

fn parse_skip_compile_macro(p: Parser) {
    let t = p.tok(false, false)

    if t == tok_word {
        if p.word_is("if") {
            let block = CmBlock.new(p, cm_block_if)
            block.if_result = 0
            parse_skip_compile_macro_block(p)
            return
        }
        if p.word_is("loop") {
            let block = CmBlock.new(p, cm_block_if)
            block.if_result = 0
            parse_skip_compile_macro_block(p)
            return
        }
        if p.word_is("elif") {
            let block = CmBlock.get(p, cm_block_if) ! p.error("Unexpected '#elif' token. There's no previous #if to match with")
            parse_skip_compile_macro_block(p)
            return
        }
        if p.word_is("else") {
            let block = CmBlock.get(p, cm_block_if) ! p.error("Unexpected '#else' token. There's no previous #if to match with")
            return
        }
        if p.word_is("end") {
            let block = CmBlock.pop(p, cm_block_any) ! p.error("Unexpected '#end' token. There's no previous #if to match with")
            return
        }
    }
}

fn parse_compile_macro_condition(p: Parser) u8 {
    let t = p.tok(true, false)
    let defs = p.build.cm_defs
    let result: u8 = 2

    if t == tok_word {
        let word = p.word()
        let def_value = defs.get(word) ! p.error("Unknown compile macro definition: '" + word + "'")
        result = def_value == "0" ? 0 : 1

        t = p.tok(true, false, false)
        if t == tok_sign && (p.word_is("==") || p.word_is("!=")) {
            t = p.tok(true, false)
            let not_eq = p.word_is("!=")
            t = p.tok(true, false)
            if t == tok_word {
                let value = p.word()
                result = def_value == value ? 1 : 0
            } else if t == tok_int {
                let value = p.word()
                result = def_value == value ? 1 : 0
            } else {
                p.error("Invalid right side value: '" + p.word() + "'")
            }

            if not_eq {
                result = result == 1 ? 0 : 1
            }
        }
    } else if t == tok_sign {
        if p.word_is("!") {
            result = parse_compile_macro_condition(p)
            result == 1 ? 0 : 1
        }
    }

    if result == 2 {
        p.error_token()
    }

    return result
}

fn parse_compile_macro_scope_end_check(p: Parser) {
    let block = p.cm_block
    if isset(block) {
        p.error("Missing compile macro '#end' token")
    }
}
