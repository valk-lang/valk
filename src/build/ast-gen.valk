
fn ast_gen_return(func: Func, scope: Scope, values: Array[Value]) {
    let b = func.build
    let rett_decls = func.rett_decls

    let value: ?Value = null
    let rdecl_i : uint = 0

    each values as retv, i {
        if retv.rett.is_multi() {
            b.error("Returning a multi-value, should not be possible, compiler is missing a type check (bug)")
        }
        if i == 0 && retv.rett.fits_eax() {
            value = retv
            continue
        }

        let rdecl = rett_decls.get(rdecl_i++) ! b.error("Missing generated return variable (" + (rdecl_i - 1) + ") (bug)")
        let type_of = rdecl.type.get_inline()

        scope.ast.push(Token {
            type: tk_assign
            value1: vgen_ptrv(vgen_decl(rdecl), type_of, vgen_int(0, type_uint(b)))
            value2: retv
        })
    }

    if isset(value) {
        scope.ast.push(tgen_statement(value))
    }

    ast_return_value(func, scope, value)
}

fn ast_return_value(func: Func, scope: Scope, value: ?Value) {

    if func.is_test {
        test_defer(func, scope)
    }

    let fast = func.fast()
    scope.ast.push(Token { type: tk_inline_scope, scope1: fast.scope_defer })

    scope.ast.push(Token {
        type: tk_return
        value1: value
    })

    scope.did_return = true
}

fn ast_gen_throw(b: Build, scope: Scope, code: Value, msg: Value) {

    let func = scope.func
    if !isset(func) : b.error("Missing 'func' for throw scope (bug)")

    let g = b.valk_global("core", "error_code")
    scope.ast.push(Token {
        type: tk_assign
        value1: vgen_global(g)
        value2: code
    })

    let gmsg = b.valk_global("core", "error_msg")
    scope.ast.push(Token {
        type: tk_assign
        value1: vgen_global(gmsg)
        value2: msg
    })

    let fast = func.fast()
    scope.ast.push(Token { type: tk_inline_scope, scope1: fast.scope_defer })

    scope.ast.push(Token {
        type: tk_return
        value1: func.empty_return_value()
    })

    scope.did_return = true
}

fn ast_gen_assign(p: ?Parser, scope: Scope, left: Value, right: Value, is_declare: bool) {
    let b = left.rett.build

    if right.type == v_undefined : return

    if left.type == v_ptr_of {
        let of = left.value1
        if !isset(of) : b.error("Missing ref value (bug)")
        left = of
    }

    let left_type = left.rett 

    let replaced_base = false
    if left_type.is_inline_type() {
        if right.replace_base(vgen_ref(left)) {
            let left_decl = left.decl
            if isset(left_decl) {
                left_decl.is_mut = true
            }
            replaced_base = true
        }
    }

    right = right.try_convert(p, scope, left_type)
    left_type.compat_check(right.rett, p)

    if replaced_base {
        scope.ast.push(tgen_statement(right))
    } else if is_declare {
        let decl = left.decl
        if !isset(decl) {
        println(left.rett)
            if isset(p) : p.bug("Missing declaration variable")
            b.error("Missing declaration variable (bug)")
        }
        scope.ast.push(tgen_declare(decl, right))
    } else {
        scope.ast.push(tgen_assign(left, right))
    }
}
