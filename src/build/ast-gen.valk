
fn ast_gen_return(ctx: Context, func: Func, scope: Scope, values: Array[Value]) {
    let b = func.build
    let rett_decls = func.rett_decls
    let rett_types = func.rett_types

    let value: ?Value = null
    let rdecl_i : uint = 0

    each values as retv, i {
        if retv.rett.is_multi() {
            ctx.error("Returning a multi-value, should not be possible, compiler is missing a type check (bug)")
        }

        let rett = rett_types.get(i) ! ctx.error("Too many values in return statement")
        if i == 0 && rett.fits_eax() {
            value = retv
            continue
        }

        let rdecl = rett_decls.get(rdecl_i++) ! ctx.error("Missing generated return variable (" + (rdecl_i - 1) + ") (bug)")
        let type_of = rdecl.type.get_inline()

        let left = vgen_ptrv(vgen_decl(rdecl), type_of, vgen_int(0, type_uint(b)))
        ast_gen_assign(ctx, scope, left, retv, false)
    }

    if isset(value) {
        scope.ast.append(tgen_statement(value))
    }

    ast_return_value(func, scope, value)
}

fn ast_return_value(func: Func, scope: Scope, value: ?Value) {

    if func.is_test {
        test_defer(func, scope)
    }

    let fast = func.fast()
    scope.ast.append(Token { type: AST.inline_scope, scope1: fast.scope_defer })

    scope.ast.append(Token {
        type: AST.return
        value1: value
    })

    scope.did_return = true
}

fn ast_gen_throw(ctx: Context, scope: Scope, code: Value, msg: Value, location: String) {

    let b = ctx.build
    let func = ctx.getFunc()

    let gmsg = b.valk_global("core", "error_msg")
    scope.ast.append(Token {
        type: AST.assign
        value1: vgen_global(gmsg)
        value2: msg
    })

    let g = b.valk_global("core", "error_code")
    scope.ast.append(Token {
        type: AST.assign
        value1: vgen_global(g)
        value2: code
    })

    let gi = b.valk_global("core", "error_trace_index")
    scope.ast.append(Token {
        type: AST.assign
        value1: vgen_global(gi)
        value2: vgen_int(0, gi.get_type())
    })

    let gtrace = b.valk_global("core", "error_trace")
    scope.ast.append(Token {
        type: AST.assign
        value1: vgen_ptrv(vgen_global(gtrace), b.valk_type("type", "String"), vgen_int(0, gi.get_type()))
        value2: Str.new_value(location, ctx)
    })

    let fast = func.fast()
    scope.ast.append(Token { type: AST.inline_scope, scope1: fast.scope_defer })

    scope.ast.append(Token {
        type: AST.return
        value1: func.empty_return_value()
    })

    scope.did_return = true
}

fn ast_gen_assign(ctx: Context, scope: Scope, left: Value, right: Value, is_declare: bool, assign_chunk: ?Chunk (null)) {
    let b = left.rett.build

    if right.type == VAL.undefined : return

    if right.rett.unsafe {
        ctx.error("You are not allowed to store this reference, you can only access it directly.")
    }

    if !is_declare && left.type == VAL.decl {
        let decl = left.decl
        if isset(decl) : decl.is_mut = true
    }

    let replaced_base = false
    if left.rett.is_inline_type() {
        if right.skip_assign {
            scope.ast.append(tgen_statement(right))
            return
        }
        if right.rett.is_pointer_for(left.rett) || right.rett.is_ref_for(left.rett) {
            // [T x L] = ptr[T x L] or &[T x L]
            // Copy value
            let cpy = vgen_memcpy(b, right, vgen_ref(left), vgen_int(left.rett.size().to(int), type_uint(b)))
            scope.ast.append(tgen_statement(cpy))
            return
        }
        if right.rett.is_inline_type() {
            // [T x L] = [T x L]
            left.rett.compat_check(right.rett, ctx.parser, assign_chunk)
            // Copy value
            let cpy = vgen_memcpy(b, vgen_ref(right), vgen_ref(left), vgen_int(left.rett.size().to(int), type_uint(b)))
            scope.ast.append(tgen_statement(cpy))
            return
        }
    }

    if left.type == VAL.decl && !is_declare {
        let decl = left.decl
        if isset(decl) {
            if decl.type.nullable {
                if right.rett.nullable {
                    if !left.rett.nullable {
                        scope.not_null_remove(decl)
                        left.rett = decl.type
                    }
                } else {
                    scope.not_null_add(decl)
                }
            }
        }
    }

    right = right.try_convert(ctx, scope, left.rett)
    left.rett.compat_check(right.rett, ctx.parser, assign_chunk)

    if replaced_base {
        scope.ast.append(tgen_statement(right))
    } else if is_declare {
        let decl = left.decl
        if !isset(decl) {
            ctx.error("Missing declaration variable")
        }
        scope.ast.append(tgen_declare(decl, right))
    } else {

        // Must run before assign
        if left.type == VAL.global && left.rett.is_gc() {
            let g = left.global
            if isset(g) {
                if g.shared {
                    // let share_func = b.valk_func("gc", right.rett.nullable ? "share_null_check" : "share")
                    let share_func = b.valk_func("gc", "share_null_check")
                    let on = vgen_func_ptr(share_func)
                    let current_func = ctx.getFunc()
                    current_func.functions_used.append(share_func, true)

                    scope.ast.append(Token {
                        type: AST.statement
                        value1: vgen_func_call(b, scope, on, Array[Value]{ right })
                    })
                }
            }
        }

        if left.type == VAL.prop && left.rett.is_gc() {
            let func = b.valk_func("gc", is_declare ? "property_set" : "property_update")
            let current_func = ctx.getFunc()
            current_func.functions_used.append(func, true)
        }

        // Assign
        scope.ast.append(tgen_assign(left, right))
    }
}
