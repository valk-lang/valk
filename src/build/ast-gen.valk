
fn ast_gen_return(ctx: Context, func: Func, scope: Scope, retv: Value) {
    let b = func.build

    func.rett.compat_check(retv.rett, ctx.parser)

    if func.can_error {
        let values = retv.unroll().copy()
        values.append(vgen_int(0, b.error_code_type()))
        values.append(vgen_null(b.error_msg_type()))
        retv = vgen_grouped_values(b, values)
    }

    ast_return_value(func, scope, retv)
}

fn ast_return_value(func: Func, scope: Scope, value: Value) {

    // Execute values before return and buffer them for the GC
    let values = value.unroll()
    buffer_values(scope, values)
    each values as value {
        scope.ast.append(tgen_statement(value))
    }

    if func.is_test {
        test_defer(func, scope)
    }

    let fast = func.fast()
    scope.ast.append(Token { type: AST.inline_scope, scope1: fast.scope_defer })

    scope.ast.append(Token {
        type: AST.return
        value1: value
    })

    scope.did_return = true
}

fn ast_gen_throw(ctx: Context, scope: Scope, code: Value, msg: Value, location: String) {

    let b = ctx.build
    let func = ctx.getFunc()

    let retts = func.rett.unroll()
    let values = Array[Value]{}
    each retts as rett {
        // TODO: use undefined
        // values.append(vgen_undefined(b))
        values.append(vgen_empty_value(rett))
    }
    values.append(code)
    values.append(msg)

    ast_return_value(func, scope, vgen_grouped_values(b, values))
}

fn ast_gen_assign(ctx: Context, scope: Scope, left: Value, right: Value, is_declare: bool, assign_chunk: ?Chunk (null)) {
    let b = left.rett.build

    if !left.assignable() : ctx.error("Cannot assign to left side value")

    // if right.type == VAL.array_init : return

    if right.type == VAL.undefined : return

    if right.rett.unsafe {
        ctx.error("You are not allowed to store this reference, you can only access it directly.")
    }

    if !is_declare && left.type == VAL.decl {
        let decl = left.decl
        if isset(decl) : decl.is_mut = true
    }

    let replaced_base = false
    // if left.rett.is_inline_type() {
    //     if right.skip_assign {
    //         scope.ast.append(tgen_statement(right))
    //         return
    //     }
    //     if right.rett.is_pointer_for(left.rett) || right.rett.is_ref_for(left.rett) {
    //         // [T x L] = ptr[T x L] or &[T x L]
    //         // Copy value
    //         let cpy = vgen_memcpy(b, right, vgen_ref(left, scope), vgen_int(left.rett.size().to(int), type_uint(b)))
    //         scope.ast.append(tgen_statement(cpy))
    //         return
    //     }
    //     if right.rett.is_inline_type() {
    //         // [T x L] = [T x L]
    //         left.rett.compat_check(right.rett, ctx.parser, assign_chunk)
    //         // Copy value
    //         let cpy = vgen_memcpy(b, vgen_ref(right, scope), vgen_ref(left, scope), vgen_int(left.rett.size().to(int), type_uint(b)))
    //         scope.ast.append(tgen_statement(cpy))
    //         return
    //     }
    // }

    if left.type == VAL.decl && !is_declare {
        let decl = left.decl
        if isset(decl) {
            if decl.type.nullable {
                if right.rett.nullable {
                    if !left.rett.nullable {
                        scope.not_null_remove(decl)
                        left.rett = decl.type
                    }
                } else {
                    scope.not_null_add(decl)
                }
            }
        }
    }

    right = right.try_convert(ctx, scope, left.rett)
    left.rett.compat_check(right.rett, ctx.parser, assign_chunk)

    if replaced_base {
        scope.ast.append(tgen_statement(right))
    } else if is_declare {
        let decl = left.decl
        if !isset(decl) {
            ctx.error("Missing declaration variable")
        }
        scope.ast.append(tgen_declare(decl, right))
    } else {

        // Must run before assign
        if left.type == VAL.global && left.rett.is_gc() {
            let g = left.global
            if isset(g) {
                if g.shared {
                    // let share_func = b.valk_func("gc", right.rett.nullable ? "share_null_check" : "share")
                    let share_func = b.valk_func("gc", "share_null_check")
                    let on = vgen_func_ptr(share_func)
                    let current_func = ctx.getFunc()
                    current_func.functions_used.append(share_func, true)

                    scope.ast.append(Token {
                        type: AST.statement
                        value1: vgen_func_call(b, scope, on, Array[Value]{ right })
                    })
                }
            }
        }

        if left.type == VAL.prop && left.rett.is_gc() {
            let func = b.valk_func("gc", is_declare ? "property_set" : "property_update")
            let current_func = ctx.getFunc()
            current_func.functions_used.append(func, true)
        }

        // Assign
        scope.ast.append(tgen_assign(left, right))
    }
}
