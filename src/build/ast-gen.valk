
fn ast_gen_return(func: Func, scope: Scope, values: Array[Value]) {
    let b = func.build
    let rett_decls = func.rett_decls
    let rett_types = func.rett_types

    let value: ?Value = null
    let rdecl_i : uint = 0

    each values as retv, i {
        if retv.rett.is_multi() {
            b.error("Returning a multi-value, should not be possible, compiler is missing a type check (bug)")
        }

        let rett = rett_types.get(i) ! b.error("Too many values in return statement")
        if i == 0 && rett.fits_eax() {
            value = retv
            continue
        }

        let rdecl = rett_decls.get(rdecl_i++) ! b.error("Missing generated return variable (" + (rdecl_i - 1) + ") (bug)")
        let type_of = rdecl.type.get_inline()

        let left = vgen_ptrv(vgen_decl(rdecl), type_of, vgen_int(0, type_uint(b)))
        ast_gen_assign(null, scope, left, retv, false)
    }

    if isset(value) {
        scope.ast.push(tgen_statement(value))
    }

    ast_return_value(func, scope, value)
}

fn ast_return_value(func: Func, scope: Scope, value: ?Value) {

    if func.is_test {
        test_defer(func, scope)
    }

    let fast = func.fast()
    scope.ast.push(Token { type: tk_inline_scope, scope1: fast.scope_defer })

    scope.ast.push(Token {
        type: tk_return
        value1: value
    })

    scope.did_return = true
}

fn ast_gen_throw(b: Build, scope: Scope, code: Value, msg: Value, location: String) {

    let func = scope.func
    if !isset(func) : b.error("Missing 'func' for throw scope (bug)")

    let gmsg = b.valk_global("core", "error_msg")
    scope.ast.push(Token {
        type: tk_assign
        value1: vgen_global(gmsg)
        value2: msg
    })

    let g = b.valk_global("core", "error_code")
    scope.ast.push(Token {
        type: tk_assign
        value1: vgen_global(g)
        value2: code
    })

    let gi = b.valk_global("core", "error_trace_index")
    scope.ast.push(Token {
        type: tk_assign
        value1: vgen_global(gi)
        value2: vgen_int(0, gi.get_type())
    })

    let gtrace = b.valk_global("core", "error_trace")
    scope.ast.push(Token {
        type: tk_assign
        value1: vgen_ptrv(vgen_global(gtrace), b.valk_type("type", "String"), vgen_int(0, gi.get_type()))
        value2: vgen_string(b, location)
    })

    let fast = func.fast()
    scope.ast.push(Token { type: tk_inline_scope, scope1: fast.scope_defer })

    scope.ast.push(Token {
        type: tk_return
        value1: func.empty_return_value()
    })

    scope.did_return = true
}

fn ast_gen_assign(p: ?Parser, scope: Scope, left: Value, right: Value, is_declare: bool, assign_chunk: ?Chunk (null)) {
    let b = left.rett.build

    if right.type == v_undefined : return

    let left_original = left
    if left.type == v_ptr_of {
        let of = left.value1
        if !isset(of) : b.error("Missing ref value (bug)")
        left = of
    }

    let replaced_base = false
    let copy_value = false
    if left.rett.is_inline_type() {
        if right.replace_base(vgen_ref(left)) {
            right.rett.compat_check(left.rett, p, assign_chunk)

            let left_decl = left.decl
            if isset(left_decl) {
                left_decl.is_mut = true
            }
            replaced_base = true
        } else if right.rett.is_pointer_for(left.rett) {
            // [T x L] = ptr[T x L]
            // Copy value
            copy_value = true
            let cpy = vgen_memcpy(b, right, left_original, vgen_int(left.rett.size().to(int), type_uint(b)))
            scope.ast.push(tgen_statement(cpy))
            return
        }
    }

    if left.type == v_decl && !is_declare {
        let decl = left.decl
        if isset(decl) {
            if decl.type.nullable {
                if right.rett.nullable {
                    if !left.rett.nullable {
                        scope.not_null_remove(decl)
                        left.rett = decl.type
                    }
                } else {
                    scope.not_null_add(decl)
                }
            }
        }
    }

    right = right.try_convert(p, scope, left.rett)
    left.rett.compat_check(right.rett, p, assign_chunk)

    if replaced_base {
        scope.ast.push(tgen_statement(right))
    } else if is_declare {
        let decl = left.decl
        if !isset(decl) {
            if isset(p) : p.bug("Missing declaration variable")
            b.error("Missing declaration variable (bug)")
        }
        scope.ast.push(tgen_declare(decl, right))
    } else {

        // Must run before assign
        if left.type == v_global && left.rett.is_gc() {
            let g = left.global
            if isset(g) {
                if g.shared {
                    // let share_func = b.valk_func("gc", right.rett.nullable ? "share_null_check" : "share")
                    let share_func = b.valk_func("gc", "share_null_check")
                    let on = vgen_func_ptr(share_func)

                    scope.ast.push(Token {
                        type: tk_statement
                        value1: vgen_func_call(b, scope, on, Array[Value]{ right })
                    })
                }
            }
        }

        // Assign
        scope.ast.push(tgen_assign(left, right))
    }
}
