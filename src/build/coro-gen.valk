
use valk:utils

fn coro_generate(p: Parser, scope: Scope, on: Value) Value {

    let b = p.build

    let args = on.values
    if !isset(args) : p.error("Missing function call arguments (coro-bug)")
    let call_on = on.value1
    if !isset(call_on) : p.error("Missing function call on value (coro-bug)")
    let fi = call_on.rett.func_info
    if !isset(fi) : p.error("Missing function info (coro-bug)")

    let arg_types = fi.args
    let rett_types = fi.rett_types

    let first = rett_types.get(0) ? type_void(b)
    let has_rett = !first.is_void()

    let has_args = false
    let has_gc_args = false
    each arg_types as type {
        if type.is_gc() : has_gc_args = true
        else : has_args = true
    }


    let func = scope.get_func() ! p.error("Coroutine initalization outside a function")

    let coro_class = b.valk_class("core", "Coro")
    let idf = Idf.for_class(coro_class)
    scope.set_idf(p, "CORO_CLASS", idf)

    let stack_class = b.valk_class("gc", "Stack")
    idf = Idf.for_class(stack_class)
    scope.set_idf(p, "STACK_CLASS", idf)

    // Func args
    let code = utils:ByteBuffer.new(256)
    code.append_str("coro: CORO_CLASS) {\n")
    if has_args : code.append_str("let stack = coro.stack")
    if has_gc_args : code.append_str("let stack_gc = (coro.stack @as STACK_CLASS).base")

    // Get args
    each arg_types as i, type {
        idf = Idf.for_type(type)
        scope.set_idf(p, "T" + i, idf)

        code.append_str("let arg")
        code.append_uint(i)
        code.append_str(" = @ptrv(")
        code.append_str(type.is_gc() ? "stack_gc" : "stack")
        code.append_str(", T")
        code.append_uint(i)
        code.append_str(")\n")

        code.append_str(type.is_gc() ? "stack_gc" : "stack")
        code.append_str(" += sizeof (T")
        code.append_uint(i)
        code.append_str(")\n")
    }
    // Call handler
    if has_rett {
        code.append_str("let ")
        each rett_types as i, type {
            if i > 0 : code.append_str(", ")
            code.append_str("retv")
            code.append_uint(i)
        }
        code.append_str(" = ")
    }
    code.append_str("(coro.handler @as HANDLER_TYPE)(")
    each arg_types as i, type {
        code.append_str("arg")
        code.append_uint(i)
    }
    code.append_str(")")
    if fi.can_error {
        // TODO
    }
    code.append_str("\n")

    // Save return values
    if has_rett {
        let offset : uint = 0
        let offset_gc : uint = 0
        each rett_types as i, type {
            if type.is_gc() {
                code.append_str("@ptrv(coro.stack_gc.base, ptr, ")
                code.append_uint(offset_gc)
                code.append_str(") = retv")
                code.append_uint(i)
                code.append_str("\n")
                offset_gc++
            } else {
                code.append_str("@ptrv(coro.stack + ")
                code.append_uint(offset)
                code.append_str(", T")
                code.append_uint(i)
                code.append_str(") = retv")
                code.append_uint(i)
                code.append_str("\n")
                offset += type.size()
            }
        }
        code.append_str("coro.stack_gc.adr = coro.stack_gc.base + ")
        code.append_uint(offset_gc * b.ptr_size)
        code.append_str("\n")
    }
    code.append_str("coro.complete()\n")
    code.append_str("}\n")

    let content = code.to_string()
    let chunk = Chunk.new(b, content, null)
    let sp = Parser.new(chunk, p)

    let fc = p.get_fc() ! p.error("Cannot find file for access (bug)")
    let init_func = b.gen_unit().new_func(fc, act_private_nsc, func.name + "__coro_" + func.coro_count++, null, chunk)
    init_func.parse_args(sp)

    return on
}
