
use valk:utils

fn coro_generate(p: Parser, scope: Scope, on: Value) Value {

    let b = p.build

    let args = on.values
    if !isset(args) : p.error("Missing function call arguments (coro-bug)")
    let call_on = on.value1
    if !isset(call_on) : p.error("Missing function call on value (coro-bug)")
    let fi = call_on.rett.func_info
    if !isset(fi) : p.error("Missing function info (coro-bug)")

    let arg_types = fi.args
    let rett_types = fi.rett_types

    while args.length > arg_types.length {
        args.remove_index(args.length - 1)
    }

    let first = rett_types.get(0) ? type_void(b)
    let has_rett = !first.is_void()

    let has_args = false
    let has_gc_args = false
    each arg_types as type {
        if type.is_gc() : has_gc_args = true
        else : has_args = true
    }

    let func = scope.get_func() ! p.error("Coroutine initalization outside a function")

    // Func args
    let code = utils:ByteBuffer.new(256)
    code.append_str("coro: CORO_CLASS) {\n")
    if has_args : code.append_str("let args = coro.args @as ptr\n")
    if has_gc_args : code.append_str("let stack = (coro.stack @as STACK_CLASS).base\n")

    // Get args
    each arg_types as i, type {
        code.append_str("let arg")
        code.append_uint(i)
        code.append_str(" = @ptrv(")
        code.append_str(type.is_gc() ? "stack" : "args")
        code.append_str(", T")
        code.append_uint(i)
        code.append_str(")\n")

        code.append_str(type.is_gc() ? "stack" : "args")
        code.append_str(" += sizeof(T")
        code.append_uint(i)
        code.append_str(")\n")
    }
    // Call handler
    if has_rett {
        code.append_str("let (")
        each rett_types as i, type {
            if i > 0 : code.append_str(", ")
            code.append_str("retv")
            code.append_uint(i)
        }
        code.append_str(") = ")
    }
    code.append_str("(coro.handler @as HANDLER_TYPE)(")
    each arg_types as i, type {
        if i > 0 : code.append_str(", ")
        code.append_str("arg")
        code.append_uint(i)
    }
    code.append_str(")")
    if fi.can_error {
        // TODO
    }
    code.append_str("\n")

    // Save return values
    if has_rett {
        let offset : uint = 0
        let offset_gc : uint = 0
        each rett_types as i, type {
            if type.is_gc() {
                code.append_str("@ptrv(coro.stack.base, ptr, ")
                code.append_uint(offset_gc)
                code.append_str(") = retv")
                code.append_uint(i)
                code.append_str("\n")
                offset_gc++
            } else {
                code.append_str("@ptrv(coro.args + ")
                code.append_uint(offset)
                code.append_str(", RT")
                code.append_uint(i)
                code.append_str(") = retv")
                code.append_uint(i)
                code.append_str("\n")
                offset += type.size()
            }
        }
        code.append_str("coro.stack.adr = coro.stack.base + ")
        code.append_uint(offset_gc * b.ptr_size)
        code.append_str("\n")
    }
    code.append_str("coro.complete()\n")
    code.append_str("}\n")

    let content = code.to_string()
    let chunk = Chunk.new(b, content, null)
    let sp = Parser.new(chunk, p)

    let fc = p.get_fc() ! p.error("Cannot find file for access (bug)")
    let init_func = b.gen_unit().new_func(fc, act_private_nsc, func.name + "__coro_" + func.coro_count++, null, chunk)

    // Set identifiers
    let coro_class = b.valk_class("coro", "Coro")
    let idf = Idf.for_class(coro_class)
    init_func.scope.set_idf(p, "CORO_CLASS", idf)

    let stack_class = b.valk_class("gc", "Stack")
    idf = Idf.for_class(stack_class)
    init_func.scope.set_idf(p, "STACK_CLASS", idf)

    idf = Idf.for_type(call_on.rett)
    init_func.scope.set_idf(p, "HANDLER_TYPE", idf)

    each arg_types as i, type {
        let idf = Idf.for_type(type)
        init_func.scope.set_idf(p, "T" + i, idf)
    }
    each rett_types as i, type {
        let idf = Idf.for_type(type)
        init_func.scope.set_idf(p, "RT" + i, idf)
    }

    // Parse
    init_func.parse_args(sp)
    parse_func_args(init_func)

    ///////////////////////
    // Generate init coro
    ///////////////////////

    let sub = scope.sub_scope(sc_default)

    idf = Idf.for_class(coro_class)
    sub.set_idf(p, "CORO_CLASS", idf)
    idf = Idf.for_value(call_on)
    sub.set_idf(p, "HANDLER", idf)
    idf = Idf.for_func(init_func)
    sub.set_idf(p, "START_FUNC", idf)

    code.clear()

    code.append_str("<{\n")
    code.append_str("let coro = CORO_CLASS.new(HANDLER, START_FUNC)\n")
    if has_args {
        code.append_str("let args = coro.args @as ptr\n")
    }
    if has_gc_args {
        code.append_str("let gc_args = coro.stack.adr\n")
    }
    each args as i, val {
        let is_gc = val.rett.is_gc()

        let idf = Idf.for_type(val.rett)
        sub.set_idf(p, "ARG_T_" + i, idf)
        idf = Idf.for_value(val)
        sub.set_idf(p, "ARG_V_" + i, idf)

        code.append_str("@ptrv(")
        code.append_str(is_gc ? "gc_args" : "args")
        code.append_str(", ARG_T_")
        code.append_uint(i)
        code.append_str(") = ARG_V_")
        code.append_uint(i)
        code.append_str("\n")

        code.append_str(is_gc ? "gc_args" : "args")
        code.append_str(" += sizeof(ARG_T_")
        code.append_uint(i)
        code.append_str(")\n")
    }

    if has_gc_args {
        code.append_str("coro.stack.adr = gc_args\n")
    }
    code.append_str("CORO_CLASS.yield_current()\n")
    code.append_str("return coro\n")

    code.append_str("}\n")

    content = code.to_string()
    chunk = Chunk.new(b, content, null)
    sp = Parser.new(chunk, p)
    sp.func = p.func

    let res = read_value(sp, sub, 0)
    res.rett = type_promise(b, fi)

    return res
}


fn coro_await(p: Parser, scope: Scope, on: Value) Value {

    let b = p.build
    let fi = on.rett.func_info
    if !isset(fi) || on.rett.type != ty_promise : p.error("Cannot use await on this type: " + on.rett)

    let sub = scope.sub_scope(sc_default)
    let retts = fi.rett_types

    let coro_class = b.valk_class("coro", "Coro")
    let idf = Idf.for_class(coro_class)
    sub.set_idf(p, "CORO_CLASS", idf)
    idf = Idf.for_value(on)
    sub.set_idf(p, "AWAIT_ON_VALUE", idf)

    let cur_coro = b.valk_global("coro", "current_coro")
    idf = Idf.for_global(cur_coro)
    sub.set_idf(p, "CURRENT_CORO", idf)

    let code = utils:ByteBuffer.new(256)
    code.append_str("<{\n")
    code.append_str("let coro = AWAIT_ON_VALUE @as CORO_CLASS\n")
    code.append_str("while(!coro.done) { CURRENT_CORO.await_coro(coro) }\n")

    if(retts.length == 0) {
        code.append_str("return 0\n")
    } else {
        // Return values
        let args_offset : uint = 0;
        let gc_offset : uint = 0;
        each retts as i, rett {

            idf = Idf.for_type(rett)
            sub.set_idf(p, "RETT" + i, idf)

            code.append_str("let retv")
            code.append_uint(i)
            code.append_str(" = ")
            if rett.is_gc() {
                code.append_str("@ptrv(coro.stack.base, RETT")
                code.append_uint(i)
                code.append_str(", ")
                code.append_uint(gc_offset)
                code.append_str(")\n")
                gc_offset++
            } else {
                code.append_str("@ptrv(coro.args + ")
                code.append_uint(args_offset)
                code.append_str(", RETT")
                code.append_uint(i)
                code.append_str(")\n")
                args_offset += rett.size()
            }
        }

        // Return statement
        // str_flat(code, "return retv{nr}, retv{nr}, ...\n");
        code.append_str("return ")
        each retts as i, rett {
            if i > 0 : code.append_str(", ")
            code.append_str("retv")
            code.append_uint(i)
        }
        code.append_str("\n")
    }

    code.append_str("}\n")


    let content = code.to_string()
    let chunk = Chunk.new(b, content, null)
    let sp = Parser.new(chunk, p)
    sp.func = p.func

    let res = read_value(sp, sub, 0)

    return res;
}
