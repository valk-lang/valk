
use helper
use valk:time
use valk:thread

@ignore_access

fn stage_ast(b: Build) {

    let lsp = b.lsp
    if b.verbose > 2 : b.log("> Stage 3: Parse function ASTs")

    // Parse
    let start = time:microtime()
    parse_asts(b)

    // Check namespace uses
    if !b.cli.values.has("--filter") {
        let nsc_main = b.nsc_main()
        each b.fc_by_path as fc {
            each fc.ns_uses as u {
                if fc.nsc.pkc != nsc_main.pkc : continue
                let idfs = u.idfs
                each idfs as idf {
                    let loc = idf.location
                    if !idf.used && isset(loc) {
                        if isset(lsp) {
                            if lsp.file_content.has(fc.path) {
                            // if lsp.file == fc.path {
                                let idstr = u.id.to(String)
                                let start = loc.copy()
                                start.goback(idstr.length)
                                b.parse_errors.append(ParseError {
                                    chunk: start
                                    chunk_end: loc
                                    msg: "Namespace '" + u.id + "' imported but not used"
                                    type: err_type_warn
                                })
                            }
                            continue
                        } 
                        b.warn("Namespace '" + u.id + "' imported but not used @ " + fc.path + ":" + loc.line)
                    }
                }
            }
        }
    }

    if isset(lsp) : return

    // Optimize AST
    stage_ast_reduce(b)

    // Time
    let duration : float = time:microtime() - start
    if b.verbose > 0 : helper:msg("⌚️", "Valk: Parse AST & Generate IR: " + duration / 1000000 + "s")
    
    // Objects
    let threads = Array[thread:Thread]{}
    start = time:microtime()
    each b.units as unit {
        if !unit.is_used : continue
        let t = stage_object(unit)
        if isset(t) : threads.append(t)
    }
    each threads as t, i {
        if b.verbose > 2 : b.log("> Waiting for Thread: %i/%{threads.length}")
        t.wait()
    }

    // Time
    duration = time:microtime() - start
    if b.verbose > 0 : helper:msg("⌚️", "LLVM: Convert IR -> object files: " + duration / 1000000 + "s")

    start = time:microtime()
    stage_link(b)

    // Time
    duration = time:microtime() - start
    if b.verbose > 0 : helper:msg("️⌚", "Linker: " + duration / 1000000 + "s")
}

fn parse_asts(b: Build) {

    let nsc_main = b.nsc_main()
    let lsp = b.lsp
    let is_lsp = isset(lsp)

    while true {
        b.globals_used.clear()
        each b.globals as g {
            if g.is_used {
                b.globals_used.append(g)
                g.is_used = false
            }
        }
        each b.units as u {
            u.is_used = false 
            each u.classes as class {
                class.is_used = false
            }
            each u.strings as str {
                str.is_used = false
            }
        }

        each b.ast_pipeline as func, i {
            func.info_used = false

            if func.is_extern : continue
            if func.skip_ast : continue
            if func.parsed_ast : continue

            await (co parse_func_ast(func)) ! continue

            // IR
            if !is_lsp : func_ir(func)
            func.wipe_ast()
        }

        // Mark used
        b.new_globals_used = false
        mark_exported_functions_used(b)
        
        // Check if new used globals
        if b.new_globals_used {
            let count = 0
            each b.functions_tracking_globals as func {
                if !func.info_used : continue
                func.parsed_ast = false
                count++
            }
            if count > 0 : continue
        }

        // Ast done
        break
    }

    // Warn about unused variables
    each b.functions as func {
        if !func.parsed_ast : continue
        if func.declared_variables.length == 0 : continue
        let fname = func.display_name
        each func.declared_variables as decl {
            let n = decl.name
            let ch = decl.chunk
            if isset(n) && !decl.is_used && isset(ch) {
                let fc = ch.fc
                if isset(lsp) {
                    if lsp.file_content.has(fc.path) {
                        let end = ch.copy().offset(n.length)
                        b.warnLsp("Variable '" + n + "' was declared but not used", ch, end)
                    }
                } else {
                    if fc.nsc.pkc == nsc_main.pkc : b.warn("Variable '" + n + "' was declared but not used in function '%fname' @ " + fc.path + ":" + ch.line)
                }
            }
        }
        func.declared_variables.clear()
    }
}

fn mark_exported_functions_used(b: Build) {
    // Mark used or not
    let main = b.generated_main_func
    if isset(main) : main.mark_used()
}

fn parse_func_ast(func: Func) {

    let b = func.build
    if b.verbose > 2 : b.log("> Stage 3.1: Parse function AST: " + func.display_name)

    let body = func.chunk_body
    if !isset(body) {
        b.warn("Missing function body")
        return
    }

    let p = Parser.new(body, null)
    p.ctx.func = func
    p.ctx.unit = func.fc.unit

    // Full AST reset
    func.init_ast_scope()

    // Parse
    let fast = func.fast()
    read_ast(p, fast.scope, false)

    //
    func.finish_ast_scope()
}

fn func_calculate_alloca_size(func: Func) {
    let b = func.build
    let fast = func.fast()
    let scope = fast.scope

    let count: uint = 0
    let alloca_size: uint = 0
    let stable_alloca_size: uint = 0
    let decls = scope.decls
    each decls as decl {
        if !decl.is_gc || func.disable_gc_stack {
            if decl.must_be_stable {
                decl.offset = stable_alloca_size
                stable_alloca_size += decl.type.size().round_up(b.ptr_size)
            }
            if decl.is_mut : fast.define_decls.append(decl)
            continue
        }
        if decl.is_mut || !decl.is_arg {
            decl.offset = alloca_size
            alloca_size += b.ptr_size
            count++
            fast.define_decls.append(decl)
        }
    }
    if stable_alloca_size > 0 {
        let type = b.valk_type("gc", "GcPtr")
        let decl = Decl.new(type, false, "valk_stable_stack")
        decl.ir_name = "\%valk_stable_stack"
        decl.offset = alloca_size
        alloca_size += b.ptr_size
        fast.define_decls.append(decl)
        fast.stable_stack_decl = decl
        count++
    }
    //
    fast.gc_decl_count = count
    fast.alloca_size = alloca_size
    fast.stable_alloca_size = stable_alloca_size
    func.ast_has_gc_decls = count > 0
}

fn func_generate_alloca_scope(func: Func) {
    let b = func.build
    let fast = func.fast()
    let func_scope = fast.scope
    let alloca_scope = fast.scope_alloca
    let defer_scope = fast.scope_defer

    let use_gc_stack = fast.gc_decl_count > 0

    if !func.is_entrance {
        func_scope.ast.prepend(Token { type: AST.inline_scope, scope1: alloca_scope })
    }

    ///////////////////////////
    // Function start
    ///////////////////////////

    let ast = alloca_scope.ast
    let ctx = Context.forFunc(func)

    let nowg = b.valk_global("coro", "gc_stack_sp")
    func.globals_used.append(nowg)

    let now = vgen_global(nowg)
    let uint_type = b.valk_type("type", "uint")

    if fast.stable_alloca_size > 0 {
        ast.append(Token {
            type: AST.ir_comment
            string1: "STABLE STACK"
        })

        let size = fast.stable_alloca_size
        let func = b.valk_class_func("gc", "Pool", "get")
        let pooli = vgen_int(b.get_pool_index(size).@cast(int), b.valk_type("type", "uint"))
        ctx.uses_func(func)

        let poolg = b.valk_global("gc", "pools")
        let pool = vgen_ptrv(vgen_global(poolg), type_ptr(b), pooli)
        ctx.uses_global(poolg)

        let values = Array[Value]{ pool }
        let call = vgen_func_call(b, alloca_scope, vgen_func_ptr(func), values)

        ast.append(Token {
            type: AST.statement
            value1: call
        })

        let propc = vgen_ptrv(call, b.valk_type("type", "u8"), vgen_int(-3, b.valk_type("type", "int")))
        ast_gen_assign(ctx, alloca_scope, propc, vgen_int(0, b.valk_type("type", "u8")), false, null)

        fast.cache_stable_adr = call
    }

    if use_gc_stack {
        ast.append(Token {
            type: AST.ir_comment
            string1: "INCREASE GC STACK"
        })

        fast.cache_stack_adr = now

        ast.append(Token {
            type: AST.statement
            value1: now
        })

        let amount = vgen_int((fast.alloca_size).@cast(int), uint_type)
        let offset = vgen_ptr_offset(now, amount)
        ast.append(Token {
            type: AST.assign
            value1: now
            value2: offset
        })
    }

    if fast.define_decls.length > 0 {
        ast.append(Token {
            type: AST.ir_comment
            string1: "INIT LOCAL VARIABLES"
        })

        each fast.define_decls as decl {
            ast.append(Token {
                type: AST.decl_offset
                decl: decl
            })
        }

        ast.append(Token {
            type: AST.ir_comment
            string1: "END LOCAL VARIABLES"
        })
    }

    let stable_stack_decl = fast.stable_stack_decl
    let cache_stable_adr = fast.cache_stable_adr
    if isset(stable_stack_decl) && isset(cache_stable_adr) {
        ast.append(Token {
            type: AST.assign
            value1: vgen_decl(stable_stack_decl)
            value2: cache_stable_adr
        })
    }

    ///////////////////////////
    // Function defer
    ///////////////////////////

    ast = defer_scope.ast

    if !func.is_entrance && use_gc_stack {
        ast.append(Token {
            type: AST.ir_comment
            string1: "REDUCE GC STACK"
        })

        ast.append(Token {
            type: AST.assign
            value1: now
            value2: now
        })
    }
}
