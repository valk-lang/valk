
fn stage_ast(b: Build) {

    if b.verbose > 2 : b.log("> Stage 3: Parse function ASTs")

    // Parse
    parse_asts(b, false)
    parse_asts(b, true)
    parse_asts(b, false)
    
    // Objects
    each b.units as unit {
        stage_object(unit)
    }

    stage_link(b)
}

fn parse_asts(b: Build, parse_last: bool) {
    each b.ast_pipeline as func {
        if func.from_header : continue
        if func.parse_last != parse_last : continue

        if func.parsed_ast : continue
        func.parsed_ast = true

        parse_func_ast(func)

        func_ir(func)
        func.wipe_ast()
    }
}

fn parse_func_ast(func: Func) {
    let body = func.chunk_body
    if !isset(body) : panic("Missing function body")

    let b = func.build
    if b.verbose > 2 : b.log("> Stage 3.1: Parse function AST: " + func.display_name)

    let p = Parser.new(body, null)
    p.func = func
    p.decl_scope = func.scope

    // Reset everything AST related
    func.scope.reset()
    func.scope_alloca.reset()
    func.coro_count = 0
    func.cache_stack_adr = null

    each func.rett_decls as decl {
        func.scope.decls.push(decl)
    }
    each func.args as arg {
        func.scope.set_idf(p, arg.name, Idf.for_decl(arg.decl))
        func.scope.add_decl(arg.decl)
    }

    read_ast(p, func.scope, false)

    p.func = null
    p.decl_scope = null

    func_calculate_alloca_size(func)
    func_generate_alloca_scope(func)

}

fn func_calculate_alloca_size(func: Func) {
    let b = func.build
    let scope = func.scope

    let gc_count: uint = 0
    let alloca_size: uint = 0
    let decls = scope.decls
    each decls as decl {
        if !decl.is_gc {
            if decl.is_mut {
                decl.offset = alloca_size
                alloca_size += decl.type.size()
                alloca_size = alloca_size.round_up(b.ptr_size)
            }
            continue
        }
        if decl.is_mut || !decl.is_arg {
            decl.offset = gc_count++
        }
    }

    func.gc_decl_count = gc_count
    func.alloca_size = alloca_size
}

fn func_generate_alloca_scope(func: Func) {
    let b = func.build
    let func_scope = func.scope
    let alloca_scope = func.scope_alloca

    if !func.is_entrance {
        func_scope.ast.prepend(Token { type: tk_inline_scope, scope1: alloca_scope })
    }

    if func.gc_decl_count > 0 {

        let ast = alloca_scope.ast

        ast.push(Token {
            type: tk_ir_comment
            string1: "INCREASE GC STACK"
        })

        let stackg = b.valk_global("gc", "stack_active")
        let stack = vgen_cached(vgen_global(stackg))
        let class = stack.rett.class
        if !isset(class) : b.error("Missing stack_active type class (bug)")
        let adr_prop = class.props.get("adr") ! b.error("Missing stack_active.adr property (bug)")
        let adr = vgen_prop(adr_prop, stack)
        let adr_cached = vgen_cached(adr)

        func.cache_stack_adr = adr_cached

        ast.push(Token {
            type: tk_statement
            value1: adr_cached
        })

        let amount = vgen_int((func.gc_decl_count * b.ptr_size) @as int, b.valk_type("type", "uint"))
        let offset = vgen_ptr_offset(adr_cached, amount)
        ast.push(Token {
            type: tk_assign
            value1: adr_cached
            value2: offset
        })

        ast.push(Token {
            type: tk_gc_offsets
        })
    }
}

fn func_last_defer(func: Func, scope: Scope) {

    let ast = scope.ast

    // Reduce stack
    let stack_adr = func.cache_stack_adr
    if isset(stack_adr) {
        ast.push(Token {
            type: tk_ir_comment
            string1: "REDUCE GC STACK"
        })

        ast.push(Token {
            type: tk_assign
            value1: stack_adr
            value2: stack_adr
        })
    }
}

