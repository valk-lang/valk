
use helper
use valk:time
use valk:thread

@ignore_access

fn stage_ast(b: Build) {

    let lsp = b.lsp
    if b.verbose > 2 : b.log("> Stage 3: Parse function ASTs")

    // Parse
    let start = time:microtime()
    parse_asts(b)

    // Check namespace uses
    if !b.cli.values.has("--filter") {
        let nsc_main = b.nsc_main()
        each b.fc_by_path as fc {
            each fc.ns_uses as u {
                if fc.nsc.pkc != nsc_main.pkc : continue
                let idfs = u.idfs
                each idfs as idf {
                    let loc = idf.location
                    if !idf.used && isset(loc) {
                        if isset(lsp) {
                            if lsp.file_content.has(fc.path) {
                            // if lsp.file == fc.path {
                                let idstr = u.id.to(String)
                                let start = loc.copy()
                                start.goback(idstr.length)
                                b.parse_errors.append(ParseError {
                                    chunk: start
                                    chunk_end: loc
                                    msg: "Namespace '" + u.id + "' imported but not used"
                                    type: err_type_warn
                                })
                            }
                            continue
                        } 
                        b.warn("Namespace '" + u.id + "' imported but not used @ " + fc.path + ":" + loc.line)
                    }
                }
            }
        }
    }

    if isset(lsp) : return

    // Optimize AST
    stage_ast_reduce(b)

    // Time
    let duration : float = time:microtime() - start
    if b.verbose > 0 : helper:msg("⌚️", "Valk: Parse AST & Generate IR: " + duration / 1000000 + "s")
    
    // Objects
    let threads = Array[thread:Thread]{}
    start = time:microtime()
    each b.units as unit {
        let t = stage_object(unit)
        if isset(t) : threads.append(t)
    }
    each threads as t, i {
        if b.verbose > 2 : b.log("> Waiting for Thread: %i/%{threads.length}")
        t.wait()
    }

    // Time
    duration = time:microtime() - start
    if b.verbose > 0 : helper:msg("⌚️", "LLVM: Convert IR -> object files: " + duration / 1000000 + "s")

    start = time:microtime()
    stage_link(b)

    // Time
    duration = time:microtime() - start
    if b.verbose > 0 : helper:msg("️⌚", "Linker: " + duration / 1000000 + "s")
}

fn parse_asts(b: Build) {

    let nsc_main = b.nsc_main()
    let lsp = b.lsp
    let is_lsp = isset(lsp)

    while true {
        b.globals_used.clear()
        each b.globals as g {
            if g.is_used {
                b.globals_used.append(g)
                g.is_used = false
            }
        }
        each b.units as u {
            each u.strings as str {
                str.is_used = false
            }
        }

        each b.ast_pipeline as func, i {
            func.info_used = false

            if func.from_header : continue
            if func.skip_ast : continue
            if func.parsed_ast : continue

            await (co parse_func_ast(func)) ! continue

            // Warn about unused variables
            each func.fast().scope.decls as decl {
                let n = decl.name
                let ch = decl.chunk
                if isset(n) && !decl.is_used && isset(ch) {
                    let fc = ch.fc
                    if fc.nsc.pkc == nsc_main.pkc : b.warn("Variable '" + n + "' was declared but not used @ " + fc.path + ":" + ch.line)
                }
            }

            // IR
            if !is_lsp : func_ir(func)
            func.wipe_ast()
        }

        // Mark used
        b.new_globals_used = false
        mark_exported_functions_used(b)
        
        // Check if new used globals
        if b.new_globals_used {
            let count = 0
            each b.functions_tracking_globals as func {
                if !func.info_used : continue
                func.parsed_ast = false
                count++
            }
            if count > 0 : continue
        }

        // Ast done
        break
    }
}

fn mark_exported_functions_used(b: Build) {
    // Mark used or not
    let main = b.generated_main_func
    if isset(main) : main.mark_used()
    b.valk_func("gc", "property_get").mark_used()
    b.valk_func("gc", "property_update").mark_used()
    b.valk_func("gc", "property_remove").mark_used()
    b.valk_func("gc", "collect").mark_used()

    // Mark vtable as used
    each b.classes as class {
        let f1 = class.funcs.get("gc_action") !? null
        let f2 = class.funcs.get("gc_free") !? null
        if isset(f1) : f1.mark_used()
        if isset(f2) : f2.mark_used()
    }
}

fn parse_func_ast(func: Func) {

    let b = func.build
    if b.verbose > 2 : b.log("> Stage 3.1: Parse function AST: " + func.display_name)

    func.parsed_ast = true

    let body = func.chunk_body
    if !isset(body) {
        b.warn("Missing function body")
        return
    }

    let p = Parser.new(body, null)
    p.ctx.func = func
    p.ctx.unit = func.fc.unit

    // Full AST reset
    func.init_ast_scope()

    // Parse
    let fast = func.fast()
    read_ast(p, fast.scope, false)

    //
    func.finish_ast_scope()
}

fn func_calculate_alloca_size(func: Func) {
    let b = func.build
    let fast = func.fast()
    let scope = fast.scope

    let count: uint = 0
    let alloca_size: uint = 0
    let decls = scope.decls
    each decls as decl {
        if !decl.is_gc || func.disable_gc_stack {
            if decl.is_mut : fast.define_decls.append(decl)
            continue
        }
        if decl.is_mut || !decl.is_arg {
            decl.offset = alloca_size
            alloca_size += b.ptr_size
            count++
            fast.define_decls.append(decl)
        }
    }
    //
    fast.gc_decl_count = count
    fast.alloca_size = alloca_size
    func.ast_has_gc_decls = count > 0
}

fn func_generate_alloca_scope(func: Func) {
    let b = func.build
    let fast = func.fast()
    let func_scope = fast.scope
    let alloca_scope = fast.scope_alloca
    let defer_scope = fast.scope_defer

    let use_gc_stack = fast.gc_decl_count > 0

    if !func.is_entrance {
        func_scope.ast.prepend(Token { type: AST.inline_scope, scope1: alloca_scope })
    }

    ///////////////////////////
    // Function start
    ///////////////////////////

    let ast = alloca_scope.ast

    let nowg = b.valk_global("core", "stack_now")
    func.globals_used.append(nowg)

    let now = vgen_global(nowg)
    let uint_type = b.valk_type("type", "uint")
    let ptr_type = b.valk_type("type", "ptr")

    if use_gc_stack {
        ast.append(Token {
            type: AST.ir_comment
            string1: "INCREASE GC STACK"
        })

        fast.cache_stack_adr = now

        ast.append(Token {
            type: AST.statement
            value1: now
        })

        let amount = vgen_int((fast.alloca_size).@cast(int), uint_type)
        let offset = vgen_ptr_offset(now, amount)
        ast.append(Token {
            type: AST.assign
            value1: now
            value2: offset
        })
    }

    if fast.define_decls.length > 0 {
        ast.append(Token {
            type: AST.ir_comment
            string1: "INIT LOCAL VARIABLES"
        })

        each fast.define_decls as decl {
            ast.append(Token {
                type: AST.decl_offset
                decl: decl
            })
        }

        ast.append(Token {
            type: AST.ir_comment
            string1: "END LOCAL VARIABLES"
        })
    }

    ///////////////////////////
    // Function defer
    ///////////////////////////

    ast = defer_scope.ast

    if !func.is_entrance && use_gc_stack {
        ast.append(Token {
            type: AST.ir_comment
            string1: "REDUCE GC STACK"
        })

        ast.append(Token {
            type: AST.assign
            value1: now
            value2: now
        })
    }
}
