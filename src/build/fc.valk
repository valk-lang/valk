
use valk:fs
use helper

class NsUse {
    id: Id
    idfs: Array[Idf]
    extract_chunk: ?Chunk
    nsc: Nsc
}

class Fc {
    nsc: Nsc
    header_nsc: Nsc
    build: Build
    unit: Unit
    path: String
    start: Chunk
    scope: Scope
    ns_uses: Array[NsUse] (Array[NsUse]{})
    is_header: bool
    ignore_imut: bool (false)
    ignore_act: bool (false)
    is_lsp_file: bool (false)

    static fn init(nsc: Nsc, header_nsc: Nsc, path: String, u: Unit) Fc {

        path = helper:resolve(path)
        let content = fs:read(path) ! nsc.build.error("Unable to read file: " + path)

        // Check LSP content
        let is_lsp = false
        let lsp = nsc.build.lsp
        if isset(lsp) && lsp.file == path {
            let c = lsp.file_content.get(path) !? null
            if isset(c) : content = c
            is_lsp = true
        }

        // Chunk
        let chunk = Chunk.new(nsc.build, content, null)

        if nsc.build.verbose > 0 : nsc.build.LOC += LOC_count(content)

        let is_header = path.ends_with(".valk.h")

        let fc = Fc{
            nsc: nsc
            header_nsc: header_nsc
            build: nsc.build
            unit: u
            path: path
            start: chunk
            scope: nsc.scope.sub_scope(sc_fc)
            is_header: is_header
            is_lsp_file: is_lsp
        }

        chunk.fc = fc

        fc.build.fc_pipeline.push(fc)

        return fc;
    }
}

fn LOC_count(str: String) uint {
    let count : uint = 0
    let data = str.data
    let bytes = str.bytes
    let i : uint = 0
    while i < bytes {
        let ch = @ptrv(data, u8, i++)
        if ch == '\n' : count++
    }
    return count
}
