
use valk:fs
use helper

class NsUse {
    id: Id
    idfs: Array[Idf]
    extract_chunk: ?Chunk
    nsc: Nsc
}

class Fc {
    nsc: Nsc
    header_nsc: Nsc
    build: Build
    unit: Unit
    path: String
    start: ?Chunk
    scope: Scope
    ns_uses: Array[NsUse] (Array[NsUse]{})
    is_header: bool
    is_generated: bool (false)
    ignore_imut: bool (false)
    ignore_act: bool (false)
    is_lsp_file: bool (false)

    static fn init(nsc: Nsc, header_nsc: Nsc, path: String, u: Unit) Fc {

        path = helper:resolve(path)
        let content = fs:read(path) ! nsc.build.error("Unable to read file: " + path)

        // Check LSP content
        let is_lsp = false
        let lsp = nsc.build.lsp
        if isset(lsp) && lsp.file == path {
            let c = lsp.file_content.get(path) !? null
            if isset(c) : content = c
            is_lsp = true
        }

        if nsc.build.verbose > 0 : nsc.build.LOC += LOC_count(content)

        let b = nsc.build
        let is_header = path.ends_with(".valk.h")

// let tmp = is_header ? b.header_scope() : nsc.scope.sub_scope(sc_fc)
        let fc = Fc{
            nsc: nsc
            header_nsc: header_nsc
            build: nsc.build
            unit: u
            path: path
            scope: is_header ? b.header_scope() : nsc.scope.sub_scope(sc_fc)
            // scope: tmp // Incorrect buffering in v0.0.7, store in temp variable until 0.0.8 is release
            is_header: is_header
            is_lsp_file: is_lsp
        }

        let chunk = Chunk.new(nsc.build, content, fc)
        fc.start = chunk

        fc.build.fc_pipeline.push(fc)

        return fc;
    }

    fn set_idf(p: Parser, name: String, idf: Idf) {
        if this.is_header : this.scope.set_idf(p, name, idf)
        else : this.nsc.scope.set_idf(p, name, idf)
    }
}

fn LOC_count(str: String) uint {
    let count : uint = 0
    let data = str.data
    let bytes = str.bytes
    let i : uint = 0
    while i < bytes {
        let ch = @ptrv(data, u8, i++)
        if ch == '\n' : count++
    }
    return count
}
