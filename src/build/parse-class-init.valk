
fn parse_class_init(p: Parser, scope: Scope, class: Class, base: ?Value) Value {

    let original_class = class
    let mode_for = class.mode_for_class
    if isset(mode_for) : class = mode_for

    let props = class.get_props()
    let values = Map[Value]{}

    base = base ?? vgen_class_init_base(p.ctx, scope, class)

    p.tok(true, true)
    while !p.word_is("}") {

        if p.word_is("#") && p.on_newline {
            parse_compile_macro(p, scope)
            p.tok(true, true)
            continue
        }

        let name = p.word()

        let idf = scope.find(p, name) !? null
        if isset(idf) {
            let prop = idf.prop
            let value = idf.value
            if isset(prop) {
                name = prop.name
            } else if isset(value) {
                let prop = value.prop
                if isset(prop) {
                    name = prop.name
                }
            }
        }

        let prop = props.get(name) ! p.error("There's no property named: '" + name + "'")
        check_act(p, prop.act, prop.class.fc, true, "property")

        if values.has(name) : p.error("Duplicate property name: " + name)
        p.expect(":", true, false)
        // Value
        let type = prop.type
        p.set_suggest(type)
        p.assign_to = vgen_prop(prop, base)
        let v = read_value(p, scope)
        p.pop_suggest()
        if v.type != VAL.undefined {
            v = v.try_convert(p.ctx, scope, type)
            type.compat_check(v.rett, p)
        }
        values.set(name, v)
        // Next
        p.tok(true, true)
        if p.word_is(",") {
            p.tok(true, true)
        }
    }

    each props as prop, name {
        if class.uses_vtable && name == "_VTABLE" : continue

        let v = values.get(name) !? <{
            if prop.is_lazy {
                let v = vgen_null(prop.type)
                v.rett = v.rett.get_non_nullable()
                values.set(name, v)
                return v
            }

            // Default value
            let v = prop_read_default(p, scope, base, prop)
            if v.type != VAL.undefined {
                values.set(name, v)
            }
            return v
        }
    }

    let result = vgen_class_init(p.ctx, class, scope, base, values)
    result.rett = original_class.get_type()
    return result
}
