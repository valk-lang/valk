
fn stage_props(b: Build) {

    if b.verbose > 2 : b.log("> Stage 2.2: Read class properties")

    each b.units as unit {
        each unit.classes as class {
            class_parse_props(class)
        }
    }

    stage_class_sizes(b)
}

fn class_generate_vtable_global(class: Class) {
    let name = class.name + "_vtable_nr"
    let g = class.fc.unit.new_global(class.fc, act_public, name, null, null) ! class.build.error("Name already used: " + name)
    g.type = class.get_type()
    class.vtable_nr_global = g
}

fn class_parse_props(class: Class) {

    class_generate_vtable_global(class)

    let p = Parser.new(class.chunk, null)

    let words = array[String]{}
    while true {
        let t = p.tok(true, true)

        if t == tok_end {
            p.error_eof()
        }
        if p.sign_is("}") {
            break
        }

        words.clear()

        let act = act_private_nsc

        while t == tok_word {
            let word = p.word()
            if words.length == 0 && p.char(0) == '.' {
                t = p.tok(false, false)
                t = p.tok(false, false)
                word = word + "." + p.word()
            }
            words.push(word)
            if words.length == 6 : p.error("Invalid class property/function definition syntax")
            t = p.tok(true, false)
        }
        if words.length == 0 : p.error_token()

        let name = words.pop_last() ! p.error("Missing name (bug)")

        // Property
        if p.sign_is(":") {
            if words.length > 1 : p.error("Invalid class property definition syntax")
            if words.length == 1 {
                let word = words.get(0) ! p.error("Missing access type (bug)")
                act = string_to_act(word) ! p.error("Invalid access type: '" + word + "'")
            }
            class_parse_prop(p, class, act, name)
            continue
        }

        // Function
        let w = words.pop_last() ! p.error("Invalid property/function definition")
        if w != "fn" : p.error("Invalid property/function definition")

        let is_static = false
        let is_exit = false

        let next = words.pop_last() ? null
        if isset(next) {
            if next == "exit" {
                is_exit = true
                next = words.pop_last() ? null
            }
        }
        if isset(next) {
            if next == "static" {
                is_static = true
                next = words.pop_last() ? null
            }
        }
        if isset(next) {
            act = string_to_act(next) ! p.error("Unexpected token: '" + next + "'")
            next = words.pop_last() ? null
        }
        if isset(next) {
            p.error("Unexpected token: '" + next + "'")
        }

        class_parse_func(p, class, act, is_static, is_exit, name)
    }
}

fn class_parse_prop(p: Parser, class: Class, act: int, name: String) {
    let type = read_type(p, class.scope)
    let prop = Prop {
        name: name
        type: type
        class: class
        act: act
        index: class.props.length()
    }
    if class.funcs.has(name) : p.error("Property name is already used for a function: " + name)
    class.props.set_unique(name, prop) ! p.error("Duplicate property name: " + name)
    // Default value
    p.tok(true, true, false)
    if p.word_is("(") {
        p.tok(true, true)
        prop.chunk = p.clone_chunk()
        p.skip_body(")")
    }
}

fn class_parse_func(p: Parser, class: Class, act: int, is_static: bool, is_exit: bool, name: String) {
    let chunk_args = p.clone_chunk()
    let fc = class.fc
    let f = fc.unit.new_func(fc, act, class.name + "__" + name, chunk_args) ! p.error("Name already used: " + name)
    f.parse_args(p)
    f.is_exit = is_exit
    f.is_static = is_static
    if class.props.has(name) : p.error("Function name is already used for a property: " + name)
    class.funcs.set_unique(name, f) ! p.error("Duplicate function name: " + name)
    // This
    let arg = Arg{
        name: "this"
        type: class.get_type()
        decl: Decl.new(class.get_type(), true)
    }
    f.arg_self = arg
    f.scope.set_idf(p, "this", Idf.for_decl(arg.decl))
}

fn string_to_act(word: String) int !invalid {
    if word == "pub" : return act_public
    if word == "private" : return act_private_fc
    if word == "readonly" : return act_readonly_fc
    throw invalid
}
