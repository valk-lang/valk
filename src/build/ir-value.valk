

fn ir_value(ir: IR, v: Value) String {

    let vt = v.type

    if vt == v_decl {
        let decl = v.decl
        if !isset(decl) : ir.error("Missing decl (bug)")
        if !decl.is_mut {
            return decl.is_arg ? decl.ir_name : decl.ir_imut_value
        }
        return ir_load(ir, decl.ir_name, ir_type(decl.type))
    }
    if vt == v_global {
        let g = v.global
        if !isset(g) : ir.error("Missing global in ir_value() (bug)")
        ir_check_global_definition(ir, g)
        let type = g.type
        if !isset(type) : ir.error("Missing global type in ir_value() (bug)")
        return ir_load(ir, g.ir_name, ir_type(type))
    }
    if vt == v_int {
        return "" + v.int
    }
    if vt == v_string {
        let body = v.string @as String
        return ir_string(ir, body)
    }
    if vt == v_prop {
        let on = v.value1 @as Value
        let prop = v.prop @as Prop
        let ir_on = ir_value(ir, on)
        let gep = ir_gep(ir, ir_on, prop.offset)
        return ir_load(ir, gep, ir_type(v.rett))
    }
    if vt == v_func_ptr {
        let func = v.func @as Func
        return ir_func_ptr(ir, func)
    }
    if vt == v_func_call {
        let on = v.value1 @as Value
        let info = on.rett.func_info @as FuncInfo
        let values = v.values @as Array[Value]
        let ir_on = ir_value(ir, on)
        let ir_values = array[String]{}
        each values as val {
            ir_values.push(ir_value(ir, val))
        }
        return ir_call(ir, ir_on, info, ir_values)
    }
    if vt == v_ptrv {
        let on = v.value1 @as Value
        let offset = v.value2 @as Value
        let type = v.rett
        let ir_on = ir_value(ir, on)
        let ir_rett_type = ir_type(type)
        let ir_offset = ir_value(ir, offset)
        let ir_offset_type = ir_type(offset.rett)
        let gep = ir_gep_typed(ir, ir_on, ir_rett_type, ir_offset, ir_offset_type)
        return ir_load(ir, gep, ir_rett_type)
    }
    if vt == v_ptr_offset {
        let on = v.value1 @as Value
        let offset = v.value2 @as Value
        let ir_on = ir_value(ir, on)
        let ir_offset = ir_value(ir, offset)
        return ir_gep_typed(ir, ir_on, "i8", ir_offset, "i64")
    }
    if vt == v_memcpy {
        let from = v.value1 @as Value
        let to = v.value2 @as Value
        let len = v.value3 @as Value
        ir_memcpy(ir, ir_value(ir, from), ir_value(ir, to), ir_value(ir, len))
        return ""
    }
    if vt == v_op {
        let l = ir_value(ir, v.value1 @as Value)
        let r = ir_value(ir, v.value2 @as Value)
        let op = v.int
        return ir_op(ir, l, r, op, v.rett)
    }
    if vt == v_compare {
        let left = v.value1 @as Value
        let right = v.value2 @as Value
        let l = ir_value(ir, left)
        let r = ir_value(ir, right)
        let op = v.int
        return ir_compare(ir, op, l, r, left.rett)
    }
    if vt == v_and_or {
        // Left
        let left = v.value1 @as Value
        let l = ir_value(ir, left)
        let b_current = ir.block()
        // Right
        let b_right = ir.func().new_block("and_or_next")
        ir.set_block(b_right)
        let right = v.value2 @as Value
        let r = ir_value(ir, right)
        //
        let b_last = ir.block()
        let op = v.int
        ir.set_block(b_current)
        return ir_and_or(ir, op, b_current, l, b_right, r, b_last)
    }
    if vt == v_incr || vt == v_decr {
        let before = v.bool1
        let val = v.value1 @as Value
        let aval = ir_value_assign(ir, val)
        let ir_val = ir_load(ir, aval, ir_type(val.rett))
        let sum = ir_op(ir, ir_val, "1", vt == v_incr ? op_add : op_sub, val.rett)
        ir_store(ir, aval, sum, ir_type(val.rett))
        return before ? sum : ir_val
    }
    if vt == v_bool {
        let val = v.bool1
        return val ? "1" : "0"
    }
    if vt == v_cast {
        let val = v.value1 @as Value
        return ir_cast(ir, ir_value(ir, val), val.rett, v.rett)
    }
    if vt == v_null {
        return "null"
    }
    if vt == v_class_init {
        let class = v.rett.class
        if !isset(class) : ir.error("Missing IR class in v_class_init (bug)")
        let values = v.values_map
        if !isset(values) : ir.error("Missing IR values in v_class_init (bug)")
        let init = v.value1 @as Value
        return ir_class_init(ir, class, init, values)
    }
    if vt == v_not {
        let ir_val = ir_value(ir, v.value1 @as Value)
        let code = ir.code()
        let var = ir.var()
        code.append_str("  ");
        code.append_str(var);
        code.append_str(" = xor i1 ");
        code.append_str(ir_val);
        code.append_str(", true\n");
        return var
    }
    if vt == v_buffer {
        ir_comment(ir, "v_buffer")
        let ir_val = ir_value(ir, v.value1 @as Value)
        let decl = v.decl @as Decl
        ir_store(ir, decl.ir_name, ir_val, ir_type(decl.type))
        return ir_val
    }
    if vt == v_cached {
        let prev = v.string
        if prev.bytes > 0 : return prev
        let val = v.value1
        if !isset(val) : ir.error("Missing ir cached value (bug)")
        let irv = ir_value(ir, val)
        v.string = irv
        return irv
    }
    if vt == v_stack_alloc {
        let func = ir.func()
        return func.alloca(v.int @as uint)
    }
    if vt == v_this_that {
        let cond = v.value1 @as Value
        let v1 = v.value2 @as Value
        let v2 = v.value3 @as Value
        let type = v.rett
        let ir_cond = ir_value(ir, cond)
        let b1 = ir.func().new_block("this_that_v1")
        let b2 = ir.func().new_block("this_that_v2")
        let ba = ir.func().new_block("this_that_after")
        ir_cond_jump(ir, ir_cond, b1, b2)

        ir.set_block(b1)
        let ir_v1 = ir_value(ir, v1)
        ir_jump(ir, ba)

        ir.set_block(b2)
        let ir_v2 = ir_value(ir, v2)
        ir_jump(ir, ba)

        ir.set_block(ba)
        let res = ir_phi(ir, ir_v1, b1, ir_v2, b2, ir_type(type))
        return res
    }
    if vt == v_errh {
        let errh = v.errh
        if !isset(errh) : ir.error("Missing IR error handler (bug)")
        let decl_err = errh.decl_err
        let decl_msg = errh.decl_msg
        let sub = errh.scope

        let on = errh.on @as Value
        let ir_on = ir_value(ir, on)

        let g_code = ir.build.valk_global("core", "error_code")
        let code_type = g_code.get_type()
        let ir_code = ir_value(ir, vgen_global(g_code))
        let ir_cmp = ir_compare(ir, op_ne, ir_code, "0", code_type)

        let current = ir.block()
        let b1 = ir.func().new_block("if_err")
        let b2 = ir.func().new_block("if_err_after")

        ir_cond_jump(ir, ir_cmp, b1, b2)

        ir.set_block(b1)
        if isset(decl_err) {
            ir_store(ir, ir_value_assign(ir, vgen_decl(decl_err)), ir_code, ir_type(decl_err.type))
        }
        if isset(decl_msg) {
            ir_store(ir, ir_value_assign(ir, vgen_decl(decl_msg)), ir_value(ir, vgen_global(ir.build.valk_global("core", "error_msg"))), ir_type(decl_msg.type))
        }
        // Clear code
        ir_store(ir, ir_value_assign(ir, vgen_global(g_code)), "0", ir_type(code_type))

        if errh.type == errh_break {
            ir_ast(ir, sub)
            ir.set_block(b2)
            return ir_on;
        } else if errh.type == errh_value {
            let alt = errh.alt
            if !isset(alt) : ir.error("Missing IR error handler alternative value (bug)")
            let subv = ir_value(ir, alt)
            ir_jump(ir, b2)
            ir.set_block(b2)
            return ir_phi(ir, ir_on, current, subv, b1, ir_type(v.rett))
        }
    }
    if vt == v_altv || vt == v_altv_break {
        let is_break = vt == v_altv_break
        let on = v.value1
        if !isset(on) : ir.error("Missing IR alternative on-value (bug)")

        let ir_on = ir_value(ir, on)
        let ir_cmp = ir_compare(ir, op_eq, ir_on, "null", on.rett)

        let current = ir.block()
        let b1 = ir.func().new_block(is_break ? "altv_break" : "altv")
        let b2 = ir.func().new_block("altv_after")

        ir_cond_jump(ir, ir_cmp, b1, b2)
        ir.set_block(b1)

        if is_break {
            let sub = v.scope1
            if !isset(sub) : ir.error("Missing IR alternative scope (bug)")
            ir_ast(ir, sub)
            ir.set_block(b2)
            return ir_on;
        } else {
            let alt = v.value2
            if !isset(alt) : ir.error("Missing IR alternative value (bug)")
            let ir_alt = ir_value(ir, alt)
            ir_jump(ir, b2)
            ir.set_block(b2)
            return ir_phi(ir, ir_on, current, ir_alt, b1, ir_type(v.rett))
        }
    }
    if vt == v_gc_link {
        let v1 = v.value2 @as Value
        let v2 = v.value2 @as Value
        return ir_gc_link(ir, ir_value(ir, v1), ir_value(ir, v2), v2.rett.nullable)
    }

    return "-value-"
}


fn ir_value_assign(ir: IR, v: Value) String {
    let vt = v.type

    if vt == v_decl {
        let decl = v.decl
        if !isset(decl) : ir.error("Missing decl (bug)")
        return decl.ir_name
    }
    if vt == v_prop {
        let on = v.value1 @as Value
        let prop = v.prop @as Prop
        let ir_on = ir_value(ir, on)
        return ir_gep(ir, ir_on, prop.offset)
    }
    if vt == v_ptrv {
        let on = v.value1 @as Value
        let offset = v.value2 @as Value
        let type = v.rett
        let ir_on = ir_value(ir, on)
        let ir_rett_type = ir_type(type)
        let ir_offset = ir_value(ir, offset)
        let ir_offset_type = ir_type(offset.rett)
        return ir_gep_typed(ir, ir_on, ir_rett_type, ir_offset, ir_offset_type)
    }
    if vt == v_global {
        let g = v.global
        if !isset(g) : ir.error("Missing global (bug)")
        ir_check_global_definition(ir, g)
        return g.ir_name
    }

    ir.error("IR: Unknown assignable value: " + vt)
}
