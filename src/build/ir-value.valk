

fn ir_value(ir: IR, v: Value) String {

    let vt = v.type

    if vt == v_decl {
        let decl = v.decl
        if !isset(decl) : ir.error("Missing decl (bug)")
        return ir_load(ir, decl.ir_name, ir_type(decl.type))
    }
    if vt == v_global {
        let g = v.global
        if !isset(g) : ir.error("Missing global in ir_value() (bug)")
        let type = g.type
        if !isset(type) : ir.error("Missing global type in ir_value() (bug)")
        return ir_load(ir, g.ir_name, ir_type(type))
    }
    if vt == v_int {
        return "" + v.int
    }
    if vt == v_string {
        let body = v.string @as String
        return ir_string(ir, body)
    }
    if vt == v_prop {
        let on = v.value1 @as Value
        let prop = v.prop @as Prop
        let ir_on = ir_value(ir, on)
        let gep = ir_gep(ir, ir_on, prop.offset)
        return ir_load(ir, gep, ir_type(v.rett))
    }
    if vt == v_func_ptr {
        let func = v.func @as Func
        return ir_func_ptr(ir, func)
    }
    if vt == v_func_call {
        let on = v.value1 @as Value
        let info = on.rett.func_info @as FuncInfo
        let values = v.values @as Array[Value]
        let ir_on = ir_value(ir, on)
        return ir_call(ir, ir_on, info, values)
    }
    if vt == v_ptrv {
        let on = v.value1 @as Value
        let offset = v.value2 @as Value
        let type = v.rett
        let ir_on = ir_value(ir, on)
        let ir_type = ir_type(type)
        let ir_offset = ir_value(ir, offset)
        let gep = ir_gep_typed(ir, ir_on, type, ir_offset)
        return ir_load(ir, gep, type)
    }
    if vt == v_memcpy {
        let from = v.value1 @as Value
        let to = v.value2 @as Value
        let len = v.value3 @as Value
        ir_memcpy(ir, ir_value(ir, from), ir_value(ir, to), ir_value(ir, len))
        return ""
    }
    if vt == v_op {
        let l = ir_value(ir, v.value1 @as Value)
        let r = ir_value(ir, v.value2 @as Value)
        let op = v.int
        return ir_op(ir, l, r, op, v.rett)
    }
    if vt == v_compare {
        let left = v.value1 @as Value
        let right = v.value2 @as Value
        let l = ir_value(ir, left)
        let r = ir_value(ir, right)
        let op = v.int
        return ir_compare(ir, op, l, r, left.rett)
    }
    if vt == v_ptrv {
    }
    if vt == v_incr {
    }
    if vt == v_decr {
    }
    if vt == v_bool {
    }
    if vt == v_cast {
    }
    if vt == v_null {
    }

    return "-value-"
}


fn ir_value_assign(ir: IR, v: Value) String {
    let vt = v.type

    if vt == v_decl {
        let decl = v.decl
        if !isset(decl) : ir.error("Missing decl (bug)")
        return decl.ir_name
    }
    if vt == v_prop {
        let on = v.value1 @as Value
        let prop = v.prop @as Prop
        let ir_on = ir_value(ir, on)
        return ir_gep(ir, ir_on, prop.offset)
    }
    if vt == v_ptrv {
        let on = v.value1 @as Value
        let offset = v.value2 @as Value
        let type = v.rett
        let ir_on = ir_value(ir, on)
        let ir_type = ir_type(type)
        let ir_offset = ir_value(ir, offset)
        return ir_gep_typed(ir, ir_on, type, ir_offset)
    }
    if vt == v_global {
        let g = v.global
        if !isset(g) : ir.error("Missing global (bug)")
        return g.ir_name
    }

    ir.error("IR: Unknown assignable value: " + vt)
}
