

fn ir_value(ir: IR, v: Value) String {

    let vt = v.type

    if vt == v_decl {
        let decl = v.decl
        if !isset(decl) : ir.error("Missing decl (bug)")
        return ir_load(ir, decl.ir_name, ir_type(decl.type))
    }
    if vt == v_global {
        let g = v.global
        if !isset(g) : ir.error("Missing global in ir_value() (bug)")
        ir_check_global_definition(ir, g)
        let type = g.type
        if !isset(type) : ir.error("Missing global type in ir_value() (bug)")
        return ir_load(ir, g.ir_name, ir_type(type))
    }
    if vt == v_int {
        return "" + v.int
    }
    if vt == v_string {
        let body = v.string @as String
        return ir_string(ir, body)
    }
    if vt == v_prop {
        let on = v.value1 @as Value
        let prop = v.prop @as Prop
        let ir_on = ir_value(ir, on)
        let gep = ir_gep(ir, ir_on, prop.offset)
        return ir_load(ir, gep, ir_type(v.rett))
    }
    if vt == v_func_ptr {
        let func = v.func @as Func
        return ir_func_ptr(ir, func)
    }
    if vt == v_func_call {
        let on = v.value1 @as Value
        let info = on.rett.func_info @as FuncInfo
        let values = v.values @as Array[Value]
        let ir_on = ir_value(ir, on)
        return ir_call(ir, ir_on, info, values)
    }
    if vt == v_ptrv {
        let on = v.value1 @as Value
        let offset = v.value2 @as Value
        let type = v.rett
        let ir_on = ir_value(ir, on)
        let ir_rett_type = ir_type(type)
        let ir_offset = ir_value(ir, offset)
        let ir_offset_type = ir_type(offset.rett)
        let gep = ir_gep_typed(ir, ir_on, ir_rett_type, ir_offset, ir_offset_type)
        return ir_load(ir, gep, ir_rett_type)
    }
    if vt == v_memcpy {
        let from = v.value1 @as Value
        let to = v.value2 @as Value
        let len = v.value3 @as Value
        ir_memcpy(ir, ir_value(ir, from), ir_value(ir, to), ir_value(ir, len))
        return ""
    }
    if vt == v_op {
        let l = ir_value(ir, v.value1 @as Value)
        let r = ir_value(ir, v.value2 @as Value)
        let op = v.int
        return ir_op(ir, l, r, op, v.rett)
    }
    if vt == v_compare {
        let left = v.value1 @as Value
        let right = v.value2 @as Value
        let l = ir_value(ir, left)
        let r = ir_value(ir, right)
        let op = v.int
        return ir_compare(ir, op, l, r, left.rett)
    }
    if vt == v_and_or {
        // Left
        let left = v.value1 @as Value
        let l = ir_value(ir, left)
        let b_current = ir.block()
        // Right
        let b_right = ir.func().new_block("and_or_next")
        ir.set_block(b_right)
        let right = v.value2 @as Value
        let r = ir_value(ir, right)
        //
        let b_last = ir.block()
        let op = v.int
        ir.set_block(b_current)
        return ir_and_or(ir, op, b_current, l, b_right, r, b_last)
    }
    if vt == v_incr || vt == v_decr {
        let val = v.value1 @as Value
        let aval = ir_value_assign(ir, val)
        let ir_val = ir_load(ir, aval, ir_type(val.rett))
        let sum = ir_op(ir, ir_val, "1", vt == v_incr ? op_add : op_sub, val.rett)
        ir_store(ir, aval, sum, ir_type(val.rett))
        return ir_val
    }
    if vt == v_bool {
        let val = v.bool1
        return val ? "1" : "0"
    }
    if vt == v_cast {
        let val = v.value1 @as Value
        return ir_cast(ir, ir_value(ir, val), val.rett, v.rett)
    }
    if vt == v_null {
        return "null"
    }
    if vt == v_class_init {
        let class = v.rett.class
        if !isset(class) : ir.error("Missing IR class in v_class_init (bug)")
        let values = v.values_map
        if !isset(values) : ir.error("Missing IR values in v_class_init (bug)")
        return ir_class_init(class, values)
    }

    return "-value-"
}


fn ir_value_assign(ir: IR, v: Value) String {
    let vt = v.type

    if vt == v_decl {
        let decl = v.decl
        if !isset(decl) : ir.error("Missing decl (bug)")
        return decl.ir_name
    }
    if vt == v_prop {
        let on = v.value1 @as Value
        let prop = v.prop @as Prop
        let ir_on = ir_value(ir, on)
        return ir_gep(ir, ir_on, prop.offset)
    }
    if vt == v_ptrv {
        let on = v.value1 @as Value
        let offset = v.value2 @as Value
        let type = v.rett
        let ir_on = ir_value(ir, on)
        let ir_rett_type = ir_type(type)
        let ir_offset = ir_value(ir, offset)
        let ir_offset_type = ir_type(offset.rett)
        return ir_gep_typed(ir, ir_on, ir_rett_type, ir_offset, ir_offset_type)
    }
    if vt == v_global {
        let g = v.global
        if !isset(g) : ir.error("Missing global (bug)")
        ir_check_global_definition(ir, g)
        return g.ir_name
    }

    ir.error("IR: Unknown assignable value: " + vt)
}
