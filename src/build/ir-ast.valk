
fn ir_ast(ir: IR, scope: Scope) {

    unroll_scope(scope)

    let tokens = scope.ast

    each tokens as token {
        let tt = token.type

        if tt == tk_statement {
            let irv = ir_value(ir, token.get_value1())
            continue
        }
        if tt == tk_declare {
            let decl = token.get_decl()
            let val = token.get_value1()
            let irv = ir_value(ir, val)
            ir_store(ir, decl.ir_name, irv, ir_type(decl.type))
            continue
        }
        if tt == tk_return {
            let val = token.value1
            if !isset(val) {
                ir_ret_void(ir)
                continue
            }
            ir_ret(ir, ir_value(ir, val), ir_type(val.rett))
            continue
        }
        if tt == tk_while {
            let cond = token.value1 @as Value
            let scope = token.scope1 @as Scope
            ir_ast_while(ir, cond, scope)
            continue
        }
        if tt == tk_if {
            let cond = token.value1 @as Value
            let scope = token.scope1 @as Scope
            let scope_else = token.scope2 @as Scope
            ir_ast_if(ir, cond, scope, scope_else)
            continue
        }
        if tt == tk_assign {
            let left = token.value1 @as Value
            let right = token.value2 @as Value
            let ir_left = ir_value_assign(ir, left)
            let ir_right = ir_value(ir, right)
            ir_store(ir, ir_left, ir_right, ir_type(left.rett))
            continue
        }
        if tt == tk_break {
            let b = ir.block_loop_after
            if !isset(b) : ir.error("Missing ir block for 'break' (bug)")
            ir_jump(ir, b)
            continue
        }
        if tt == tk_continue {
            let b = ir.block_loop_cond
            if !isset(b) : ir.error("Missing ir block for 'break' (bug)")
            ir_jump(ir, b)
            continue
        }

        ir.error("Unknown IR token: " + tt)
    }
}

fn ir_ast_while(ir: IR, cond: Value, scope: Scope) {

    let func = ir.func()
    let b_cond = func.new_block("while_cond")
    let b_code = func.new_block("while_code")
    let b_after = func.new_block("while_after")

    ir_jump(ir, b_cond)

    ir.set_block(b_cond)
    let ir_cond = ir_value(ir, cond)
    ir_cond_jump(ir, ir_cond, b_code, b_after)

    // Code
    ir.set_block(b_code)

    // Ast
    let backup_cond = ir.block_loop_cond
    let backup_after = ir.block_loop_after
    ir.block_loop_cond = b_cond
    ir.block_loop_after = b_after
    ir_ast(ir, scope)
    ir.block_loop_cond = backup_cond
    ir.block_loop_after = backup_after

    if !scope.did_return : ir_jump(ir, b_cond)
    //
    ir.set_block(b_after)
}

fn ir_ast_if(ir: IR, cond: Value, scope: Scope, scope_else: Scope) {

    let func = ir.func()
    let b_code = func.new_block("if_code")
    let b_else = func.new_block("if_else")
    let b_after = func.new_block("if_after")

    let ir_cond = ir_value(ir, cond)
    ir_cond_jump(ir, ir_cond, b_code, b_else)

    // Code
    ir.set_block(b_code)
    ir_ast(ir, scope)
    if !scope.did_return : ir_jump(ir, b_after)

    // Else
    ir.set_block(b_else)
    ir_ast(ir, scope_else)
    if !scope_else.did_return : ir_jump(ir, b_after)

    ir.set_block(b_after)
}
