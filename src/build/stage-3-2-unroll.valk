
fn unroll_scope(scope: Scope) {
    let func = scope.func
    if !isset(func) : return

    let ast = array[Token]{}

    if scope.type == sc_func && !func.is_entrance {
        unroll_func_start(func, ast)
    }

    each scope.ast as t {
        if t.type == tk_allocas {
            unroll_func_start(func, ast)
            continue
        }
        if t.type == tk_return {
            unroll_func_defer(func, ast)
        }
        ast.push(t)
    }

    scope.ast = ast
}

fn unroll_func_start(func: Func, ast: Array[Token]) {

    let scope = func.scope
    let b = func.build

    if func.gc_decl_count > 0 {
        ast.push(Token {
            type: tk_ir_comment
            string1: "INCREASE GC STACK"
        })

        let stackg = b.valk_global("gc", "stack_active")
        let stack = vgen_cached(vgen_global(stackg))
        let class = stack.rett.class
        if !isset(class) : b.error("Missing stack_active type class (bug)")
        let adr_prop = class.props.get("adr") ! b.error("Missing stack_active.adr property (bug)")
        let adr = vgen_prop(adr_prop, stack)
        let adr_cached = vgen_cached(adr)

        func.cache_stack_adr = adr_cached

        ast.push(Token {
            type: tk_statement
            value1: adr_cached
        })

        let amount = vgen_int((func.gc_decl_count * b.ptr_size) @as int, b.valk_type("type", "uint"))
        let offset = vgen_ptr_offset(adr_cached, amount)
        ast.push(Token {
            type: tk_assign
            value1: adr_cached
            value2: offset
        })

        ast.push(Token {
            type: tk_gc_offsets
        })
    }

    // Decls
    // let decls = scope.decls
    // each decls as decl {
    //     if decl.is_mut || (decl.is_gc && !decl.is_arg) {
    //         if decl.is_gc() {
    //             let stack_adr = func.cache_stack_adr
    //             if isset(stack_adr) {
    //                 let offset = vgen_ptr_offset(stack_adr, decl.offset * b.ptr_size)
    //                 array_push(unroll, tgen_decl_set_store(alc, decl, offset));
    //             }
    //         }
    //     }
    // }

    // Array* decls = func->scope->decls;
    // loop(decls, i) {
    //     Decl *decl = array_get_index(decls, i);
    //     // Set stack offset for variables
    //     if (decl->offset > -1) {
    //         if (decl->is_gc) {
    //             Value* offset = vgen_ptr_offset(alc, b, func->v_cache_stack_pos, vgen_int(alc, decl->offset, type_cache_u32(b)), b->ptr_size);
    //             array_push(unroll, tgen_decl_set_store(alc, decl, offset));
    //         } else {
    //             Value* offset = vgen_ptr_offset(alc, b, func->v_cache_alloca, vgen_int(alc, decl->offset, type_cache_u32(b)), 1);
    //             array_push(unroll, tgen_decl_set_store(alc, decl, offset));
    //         }
    //     }
    //     // Store args
    //     if (decl->is_arg) {
    //         array_push(unroll, tgen_decl_set_arg(alc, decl));
    //     } else {
    //         // Set null
    //         // if (decl->offset > -1 && decl->is_gc) {
    //         //     Value* vdecl = vgen_decl(alc, decl);
    //         //     array_push(unroll, tgen_assign(alc, vdecl, vgen_null(alc, b)));
    //         // }
    //     }
    // }
}

fn unroll_func_defer(func: Func, ast: Array[Token]) {

    let b = func.build

    let stack_adr = func.cache_stack_adr
    if isset(stack_adr) {
        ast.push(Token {
            type: tk_ir_comment
            string1: "REDUCE GC STACK"
        })

        ast.push(Token {
            type: tk_assign
            value1: stack_adr
            value2: stack_adr
        })
    }
}
