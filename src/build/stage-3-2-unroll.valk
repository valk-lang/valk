
fn unroll_scope(scope: Scope) {
    let func = scope.func
    if !isset(func) : return

    let ast = array[Token]{}

    if scope.type == sc_func && !func.is_entrance {
        unroll_func_start(func, ast)
    }

    each scope.ast as t {
        if t.type == tk_allocas {
            unroll_func_start(func, ast)
            continue
        }
        if t.type == tk_return {
            unroll_func_defer(func, ast)
        }
        ast.push(t)
    }

    scope.ast = ast
}

fn unroll_func_start(func: Func, ast: Array[Token]) {

    let scope = func.scope
    let b = func.build

    if func.gc_decl_count > 0 {
        ast.push(Token {
            type: tk_ir_comment
            string1: "INCREASE GC STACK"
        })

        let stackg = b.valk_global("gc", "stack_active")
        let stack = vgen_cached(vgen_global(stackg))
        let class = stack.rett.class
        if !isset(class) : b.error("Missing stack_active type class (bug)")
        let adr_prop = class.props.get("adr") ! b.error("Missing stack_active.adr property (bug)")
        let adr = vgen_prop(adr_prop, stack)
        let adr_cached = vgen_cached(adr)

        func.cache_stack_adr = adr_cached

        ast.push(Token {
            type: tk_statement
            value1: adr_cached
        })

        let amount = vgen_int((func.gc_decl_count * b.ptr_size) @as int, b.valk_type("type", "uint"))
        let offset = vgen_ptr_offset(adr_cached, amount)
        ast.push(Token {
            type: tk_assign
            value1: adr_cached
            value2: offset
        })

        ast.push(Token {
            type: tk_gc_offsets
        })
    }
}

fn unroll_func_defer(func: Func, ast: Array[Token]) {

    let b = func.build

    let stack_adr = func.cache_stack_adr
    if isset(stack_adr) {
        ast.push(Token {
            type: tk_ir_comment
            string1: "REDUCE GC STACK"
        })

        ast.push(Token {
            type: tk_assign
            value1: stack_adr
            value2: stack_adr
        })
    }
}
