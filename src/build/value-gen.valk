
fn vgen_string(b: Build, body: String) Value {
    return Value {
        type: v_string
        string: body
        rett: type_string(b)
    }
}

fn vgen_decl(decl: Decl) Value {
    return Value {
        type: v_decl
        decl: decl
        rett: decl.type
    }
}

fn vgen_global(g: Global) Value {
    return Value {
        type: v_global
        global: g
        rett: g.get_type()
    }
}

fn vgen_prop(prop: Prop, on: Value) Value {
    return Value {
        type: v_prop
        value1: on
        prop: prop
        rett: prop.type
    }
}
fn vgen_ptrv(on: Value, type: Type, offset: Value) Value {
    return Value {
        type: v_ptrv
        value1: on
        value2: offset
        rett: type
    }
}

fn vgen_int(value: int, type: Type) Value {
    return Value {
        type: v_int
        int: value
        rett: type
    }
}

fn vgen_func_ptr(func: Func) Value {
    return Value {
        type: v_func_ptr
        func: func
        rett: type_func(func)
    }
}

fn vgen_func_call(b: Build, on: Value, values: Array[Value]) Value {

    let func_info = on.rett.func_info
    if !isset(func_info) : build_error("Function call on a non-function value")

    return Value {
        type: v_func_call
        value1: on
        values: values
        rett: func_info.rett_eax() ? type_void(b)
    }
}

fn vgen_memcpy(b: Build, from: Value, to: Value, len: Value) Value {
    return Value {
        type: v_memcpy
        value1: from
        value2: to
        value3: len
        rett: type_void(b)
    }
}

fn vgen_op(left: Value, right: Value, op: int, rett: Type) Value {
    return Value {
        type: v_op
        value1: left
        value2: right
        int: op
        rett: rett
    }
}
fn vgen_compare(left: Value, right: Value, op: int, rett: Type) Value {
    return Value {
        type: v_compare
        value1: left
        value2: right
        int: op
        rett: rett
    }
}
fn vgen_and_or(left: Value, right: Value, op: int, rett: Type) Value {
    return Value {
        type: v_and_or
        value1: left
        value2: right
        int: op
        rett: rett
    }
}

fn vgen_incr(on: Value) Value {
    return Value {
        type: v_incr
        value1: on
        rett: on.rett
    }
}
fn vgen_decr(on: Value) Value {
    return Value {
        type: v_decr
        value1: on
        rett: on.rett
    }
}

fn vgen_bool(b: Build, value: bool) Value {
    return Value {
        type: v_bool
        bool1: value
        rett: type_valk(b, "bool")
    }
}

fn vgen_cast(value: Value, type: Type) Value {
    return Value {
        type: v_cast
        value1: value
        rett: type
    }
}

fn vgen_null(rett: Type) Value {
    return Value {
        type: v_null
        rett: rett.get_nullable()
    }
}

fn vgen_class_init(class: Class, values: Map[Value]) Value {
    return Value {
        type: v_class_init
        values_map: values
        rett: class.get_type()
    }
}
