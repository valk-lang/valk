
fn vgen_undefined(b: Build) Value {
    return Value {
        type: VAL.undefined
        rett: type_void(b)
    }
}
fn vgen_string(b: Build, str: Str) Value {
    return Value {
        type: VAL.string
        str: str
        rett: type_string(b)
    }
}

fn vgen_decl(decl: Decl) Value {
    decl.is_used = true
    let v = Value {
        type: VAL.decl
        decl: decl
        rett: decl.type
    }
    return v
}

fn vgen_global(g: Global) Value {
    let v = Value {
        type: VAL.global
        global: g
        rett: g.get_type()
    }
    return v
}

fn vgen_prop(prop: Prop, on: Value) Value {
    let rett = prop.type
    if on.rett.is_imut {
        rett = rett.get_imut(true)
    }
    let v = Value {
        type: VAL.prop
        value1: on
        prop: prop
        rett: rett
    }
    return v
}
fn vgen_ptrv(on: Value, type: Type, offset: Value) Value {
    let v = Value {
        type: VAL.ptrv
        value1: on
        value2: offset
        type1: type
        rett: type
    }
    return v
}
fn vgen_ptr_offset(on: Value, offset: Value, type: ?Type (null)) Value {
    return Value {
        type: VAL.ptr_offset
        value1: on
        value2: offset
        type1: type ?? on.rett.build.valk_type("type", "u8")
        rett: on.rett.build.valk_type("type", "ptr")
    }
}
fn vgen_ref(on: Value, scope: Scope, force_pointer: bool (false)) Value {
    if on.type == VAL.func_call {
        let retvs = on.func_retvs
        if isset(retvs) {
            retvs.get(0) -> val {
                on = vgen_buffer(scope, val)
            }
        }
    }
    if !on.assignable() : on.rett.build.error("Trying to get reference from non-assignable value: " + on.type)

    let rett = (on.type == VAL.global || force_pointer) ? on.rett.get_pointer() : <{
        let t = on.rett.get_ref()
        if on.rett.is_inline_type() && on.type == VAL.prop {
            let pon = on.value1
            if isset(pon) && pon.rett.is_gc() {
                t.unsafe = true
            }
        }
        return t
    }
    return Value {
        type: VAL.ptr_of
        value1: on
        rett: rett
    }
}

fn vgen_int(value: int, type: Type) Value {
    return Value {
        type: VAL.int
        int: value
        rett: type
    }
}
fn vgen_float(value: f64, type: Type) Value {
    return Value {
        type: VAL.float
        float: value
        rett: type
    }
}

fn vgen_func_ptr(func: Func) Value {
    return Value {
        type: VAL.func_ptr
        func: func
        rett: type_func(func)
    }
}

fn vgen_func_call(b: Build, decl_scope: Scope, on: Value, values: Array[Value]) Value {

    let func_info = on.rett.func_info
    if !isset(func_info) : b.error("Function call on a non-function value")

    // Add to used functions list 
    if on.type == VAL.func_ptr {
        let func = on.func
        if isset(func) {
            func.used_in(decl_scope)
        }
    }

    if on.rett.is_closure() {
        let closure_ob = on
        values.prepend(closure_ob)

        let closure_class = b.valk_class("core", "Closure")
        let prop_outer = closure_class.props.get("outer_func") ! b.error("Missing closure 'func' property (bug)")
        on = vgen_prop(prop_outer, closure_ob)

        let arg_types = Array[Type].new()
        each values as val {
            arg_types.append(val.rett)
        }

        func_info = func_info.clone()
        func_info.args = arg_types
        on.rett = type_func_info(b, func_info)
    }

    buffer_values(decl_scope, values)

    let retts = func_info.rett_types
    let rett = type_multi(b, retts)
    let retvs = Array[Value]{}

    let fcall = Value {
        type: VAL.func_call
        value1: on
        values: values
        func_retvs: retvs
        type1: rett
        rett: rett
    }

    if rett.count_types() <= 1 && !func_info.can_error {
        retvs.append(fcall)
        return fcall
    }

    each retts as type, i {
        retvs.append(vgen_rett_value(fcall, i, type))
    }

    if func_info.can_error {
        let real_retts = retts.copy()
        let index = retvs.length
        // retvs.append(vgen_rett_value(fcall, index, b.error_code_type()))
        // retvs.append(vgen_rett_value(fcall, index + 1, b.error_msg_type()))
        let code_type = b.error_code_type()
        let msg_type = b.error_msg_type()
        fcall.func_err_code = vgen_rett_value(fcall, index, code_type)
        fcall.func_err_msg = vgen_rett_value(fcall, index + 1, msg_type)
        real_retts.append(code_type)
        real_retts.append(msg_type)
        fcall.type1 = type_multi(b, real_retts)
    }

    return fcall
}

fn vgen_rett_value(on: Value, index: uint, rett: Type) Value {
    return Value {
        type: VAL.retv
        value1: on
        int: index.to(int)
        rett: rett
    }
}

fn vgen_memcpy(b: Build, from: Value, to: Value, len: Value) Value {
    return Value {
        type: VAL.memcpy
        value1: from
        value2: to
        value3: len
        rett: type_void(b)
    }
}

fn vgen_op(left: Value, right: Value, op: int, rett: Type) Value {
    return Value {
        type: VAL.op
        value1: left
        value2: right
        int: op
        rett: rett
    }
}
fn vgen_atomic_op(left: Value, right: Value, op: int) Value {
    return Value {
        type: VAL.atomic_op
        value1: left
        value2: right
        int: op
        rett: left.rett
    }
}
fn vgen_atomic_store(left: Value, right: Value) Value {
    return Value {
        type: VAL.atomic_store
        value1: left
        value2: right
        rett: left.rett
    }
}
fn vgen_atomic_load(left: Value) Value {
    return Value {
        type: VAL.atomic_load
        value1: left
        rett: left.rett
    }
}

fn vgen_compare(left: Value, right: Value, op: int, rett: Type) Value {
    return Value {
        type: VAL.compare
        value1: left
        value2: right
        int: op
        rett: rett
    }
}
fn vgen_and_or(left: Value, right: Value, op: int, rett: Type) Value {
    let res = Value {
        type: VAL.and_or
        value1: left
        value2: right
        int: op
        rett: rett
    }

    if op == OP.and {
        // merge issets when using '&&'
        let is1 = left.issets
        let is2 = right.issets
        if isset(is1) {
            res.issets = is1
            if isset(is2) : is1.append_many(is2)
        } else{
            res.issets = is2
        }
        left.not_issets = null
        right.not_issets = null
    } else if op == OP.or {
        // merge not_issets when using '||'
        let is1 = left.not_issets
        let is2 = right.not_issets
        if isset(is1) {
            res.not_issets = is1
            if isset(is2) : is1.append_many(is2)
        } else{
            res.not_issets = is2
        }
        left.issets = null
        right.issets = null
    }

    return res
}

fn vgen_incr(on: Value, before: bool) Value {
    return Value {
        type: VAL.incr
        value1: on
        rett: on.rett
        bool1: before
    }
}
fn vgen_decr(on: Value, before: bool) Value {
    return Value {
        type: VAL.decr
        value1: on
        rett: on.rett
        bool1: before
    }
}

fn vgen_bool(b: Build, value: bool) Value {
    return Value {
        type: VAL.bool
        bool1: value
        rett: type_valk(b, "bool")
    }
}

fn vgen_cast(value: Value, type: Type) Value {
    return Value {
        type: VAL.cast
        value1: value
        rett: type
    }
}

fn vgen_null(rett: Type) Value {
    return Value {
        type: VAL.null
        rett: rett.get_nullable()
    }
}
fn vgen_null_fake(rett: Type) Value {
    return Value {
        type: VAL.null
        rett: rett
    }
}
fn vgen_void(b: Build) Value {
    return Value {
        type: VAL.void
        rett: type_void(b)
    }
}

fn vgen_class_init_base(ctx: Context, scope: Scope, class: Class) Value {

    let rett = class.get_type()
    let init = rett.is_gc() ? <{
        // Class
        let b = class.build

        let func = b.valk_class_func("gc", "Pool", class.uses_vtable ? "get_vtable" : "get")
        let pooli = vgen_int(class.pool_index.@cast(int), b.valk_type("type", "uint"))
        ctx.uses_func(func)

        let poolg = b.valk_global("gc", "pools")
        let pool = vgen_ptrv(vgen_ref(vgen_global(poolg), scope), type_ptr(b), pooli)
        ctx.uses_global(poolg)

        let values = Array[Value]{ pool }
        let call = vgen_func_call(b, scope, vgen_func_ptr(func), values)
        return call
    } : <{
        // Struct
        let b = class.build
        let func = b.valk_func("mem", "alloc_ob")
        ctx.uses_func(func)
        let values = Array[Value]{ vgen_int(class.size.@cast(int), b.valk_type("type", "uint")) }
        let call = vgen_func_call(b, scope, vgen_func_ptr(func), values)
        return call
    }

    return vgen_wrap(init)
}

fn vgen_class_init(ctx: Context, class: Class, scope: Scope, base: ?Value, values: Map[Value]) Value {

    ctx.uses_class(class)

    if class.type == CT.class {
        let current_func = ctx.getFunc()
        current_func.info_creates_objects = true
    }

    if class.uses_vtable && !values.has("_VTABLE") {
        values.set("_VTABLE", vgen_export_symbol(class.vtable_export_name(), type_ptr(class.build)))
    }

    let rett = class.get_type()
    if class.size == 0 {
        let v = vgen_null(rett)
        v.rett = rett
        return v
    }

    buffer_values_map(scope, values)
    base = base ?? vgen_class_init_base(ctx, scope, class)
    let b = class.build

    // Code
    let sub = scope.sub_scope(SCOPE.default)

    each values as value, name {
        if value.type == VAL.undefined : continue
        if !value.rett.is_gc() : continue
        sub.ast.append(tgen_statement(value))
    }

    sub.ast.append(tgen_statement(base))

    if class.type == CT.class {
        let propc = vgen_ptrv(base, b.valk_type("type", "u8"), vgen_int(-3, b.valk_type("type", "int")))
        ast_gen_assign(ctx, sub, propc, vgen_int(class.get_gc_prop_count(), b.valk_type("type", "u8")), false, null)
    }

    let props = class.get_props()
    each values as value, name {
        let prop = props.get(name) ! continue
        ast_gen_assign(ctx, sub, vgen_prop(prop, base), value, false, null)
    }

    return Value {
        type: VAL.class_init
        values_map: values
        value1: base
        scope1: sub
        rett: rett
    }
}

fn vgen_array_init(ctx: Context, scope: Scope, base: Value, values: Array[Value], item_type: Type, rett: Type) Value {

    let b = rett.build
    let size_type = b.valk_type("type", "uint")
    let sub = scope.sub_scope(SCOPE.default)

    sub.ast.append(tgen_statement(base))

    let offset: uint = 0
    each values as val {
        let left = vgen_ptrv(base, item_type, vgen_int(offset.to(int), size_type))
        ast_gen_assign(ctx, sub, left, val, false)
        offset++
    }
    if values.length < rett.array_size {
        let filler = values.get(values.length - 1) !? vgen_undefined(b)
        while values.length < rett.array_size {
            let left = vgen_ptrv(base, item_type, vgen_int(offset.to(int), size_type))
            ast_gen_assign(ctx, sub, left, filler, false)
            offset++
            values.append(filler)
        }
    }

    return Value {
        type: VAL.array_init
        value1: base
        value2: vgen_inline_scope(sub, rett)
        rett: rett
    }
}

fn buffer_values(decl_scope: Scope, values: Array[Value], include_last: bool (true)) {
    let len = values.length
    each values as v, i {
        if !include_last && len == i + 1 : continue
        if v.needs_buffer() {
            v = vgen_buffer(decl_scope, v)
            values.set(i, v) _
        }
    }
}
fn buffer_values_map(decl_scope: Scope, values: Map[Value]) {
    each values as v, k {
        if v.needs_buffer() {
            v = vgen_buffer(decl_scope, v)
            values.set(k, v)
        }
    }
}

fn vgen_buffer(decl_scope: Scope, value: Value) Value {
    let func = decl_scope.func
    if !isset(func) : return value
    if func.no_buffers : return value
    if value.type == VAL.buffer {
        let decl = value.decl
        if isset(decl) {
            if func.fast().reuse_buffer(decl) : return value
        }
    }
    let decl = func.get_buffer(value.rett, decl_scope)
    return Value {
        type: VAL.buffer
        value1: value
        decl: decl
        rett: value.rett
    }
}

fn vgen_not(value: Value) Value {
    return Value {
        type: VAL.not
        value1: value
        rett: value.rett
    }
}

fn vgen_stack_alloc(type: Type) Value {
    return Value {
        type: VAL.stack_alloc
        int: type.size().@cast(int)
        rett: type.get_pointer()
    }
}

fn vgen_this_or_that(cond: Value, v1: Value, v2: Value, rett: Type) Value {
    return Value {
        type: VAL.this_or_that
        value1: cond
        value2: v1
        value3: v2
        rett: rett
    }
}

fn vgen_grouped_values(b: Build, values: Array[Value]) Value {
    if values.length == 0 {
        return vgen_void(b)
    }
    if values.length == 1 {
        let first = values.get(0) !? null
        if isset(first) : return first
    }
    let types = Array[Type].new()
    each values as val {
        types.append(val.rett)
    }
    let rett = type_multi(b, types)
    return Value {
        type: VAL.grouped_values
        values: values
        rett: rett
    }
}
fn vgen_add_value(b: Build, to: Value, add: Value) Value {
    if add.rett.is_void() : return to
    let values : ?Array[Value] = null
    if to.is_multi() : values = to.values
    if !isset(values) {
        if to.rett.is_void() : return add
        values = Array[Value]{}
        values.append(to)
    }
    values.append(add)
    return vgen_grouped_values(b, values)
}
fn vgen_force_group(b: Build, on: Value) Value {
    if on.rett.is_multi() : return on
    let types = Array[Type]{ on.rett }
    let rett = type_multi(b, types)
    return Value {
        type: VAL.grouped_values
        values: Array[Value]{ on }
        rett: rett
    }
}

fn vgen_vscope(b: Build, scope: Scope, decls: Array[Decl]) Value {

    if decls.length == 0 {
        return Value {
            type: VAL.vscope
            scope1: scope
            rett: type_void(b)
        }
    }

    let types = Array[Type]{}
    let values = Array[Value]{}
    each decls as decl {
        types.append(decl.type)
        values.append(vgen_decl(decl))
    }

    return Value {
        type: VAL.vscope
        scope1: scope
        values: values
        rett: type_multi(b, types)
    }
}

fn vgen_setjmp(b: Build, buffer: Value) Value {
    return Value {
        type: VAL.setjmp
        value1: buffer
        rett: type_valk(b, "i32")
    }
}

fn vgen_longjmp(b: Build, buffer: Value) Value {
    return Value {
        type: VAL.longjmp
        value1: buffer
        rett: type_void(b)
    }
}

fn vgen_export_symbol(name: String, rett: Type) Value {
    return Value {
        type: VAL.export_symbol
        string: name
        rett: rett
    }
}

fn vgen_assign(left: Value, right: Value) Value {
    return Value {
        type: VAL.assign
        value1: left
        value2: right
        rett: left.rett
    }
}
fn vgen_declare(decl: Decl, value: Value) Value {
    return Value {
        type: VAL.declare
        decl: decl
        value1: value
        rett: decl.type
    }
}

fn vgen_wrap(val: Value) Value {
    return Value {
        func_retvs: val.func_retvs
        type: VAL.wrap
        value1: val
        rett: val.rett
    }
}
fn vgen_this_but_that(this: Value, that: Value) Value {
    let wrap = vgen_wrap(that)
    wrap.pre_value = this
    return wrap
}
fn vgen_cond_value(cond: Value, value: Value, velse: ?Value (null)) Value {
    return Value {
        type: VAL.cond
        value1: cond
        value2: value
        value3: velse
        rett: type_void(cond.rett.build)
    }
}

fn vgen_error_check(b: Build, on: Value) Value {
    let code = on.func_err_code ?! b.error("Missing error code value (bug)")
    let val = vgen_int(0, code.rett)
    return vgen_compare(code, val, OP.ne, b.valk_type("type", "bool"))
}

fn vgen_empty_value(type: Type) Value {
    if type.is_void() {
        return vgen_void(type.build)
    }
    if type.is_pointer() {
        let n = vgen_null(type)
        n.rett = n.rett.get_non_nullable()
        return n
    }
    if type.is_float() {
        return vgen_float(0, type)
    }
    return vgen_int(0, type)
}

fn vgen_inline_scope(scope: Scope, rett: Type) Value {
    return Value {
        type: VAL.inline_scope
        scope1: scope
        rett: rett
    }
}

fn vgen_unroll_inline_scope(iscope: Value) Value {
    let scope = iscope.scope1
    if !isset(scope) : iscope.rett.build.error("Missing scope value for inline scope token (bug)")

    let last = scope.ast.get(scope.ast.length - 1) !? null
    if isset(last) {
        if last.type == AST.statement {
            let v = last.value1
            if isset(v) {
                let values = v.unroll()
                if values.length == 1 {
                    return vgen_this_but_that(iscope, v)
                } else {
                    let results = Array[Value].new()
                    each values as val, i {
                        results.append(vgen_this_but_that(iscope, val))
                    }
                    return vgen_grouped_values(iscope.rett.build, results)
                }
            }
        }
    }
    return iscope
}

fn vgen_phi(v1: Value, v2: Value, rett: Type) Value {
    return Value {
        type: VAL.phi
        value1: v1
        value2: v2
        rett: rett
    }
}

fn vgen_map(b: Build, ctx: Context, scope: Scope, generic_types: Array[Type], values: HashMap[Value, Value]) Value {

    let sub = scope.sub_scope(SCOPE.default)

    let mclass = b.valk_class("type", "HashMap")
    mclass = get_class_generic(b, mclass, generic_types)

    let func_new = mclass.get_func("new") ! ctx.error("Missing 'new' func")
    let func_set = mclass.get_func("set") ! ctx.error("Missing 'set' func")
    ctx.uses_func(func_new)
    ctx.uses_func(func_set)
    let map = vgen_func_call(b, sub, vgen_func_ptr(func_new), .{})

    each values as v, k {
        let stm = vgen_func_call(b, sub, vgen_func_ptr(func_set), .{ map, k, v })
        sub.ast.append(tgen_statement(stm))
    }

    return vgen_this_but_that(vgen_inline_scope(sub, map.rett), map)
}

fn vgen_load(on: Value) Value {
    if !on.rett.is_pointer() : return on
    let rett = on.rett.get_inline()
    if !rett.is_inline_type() : return on
    return Value {
        type: VAL.load
        value1: on
        rett: rett
    }
}
