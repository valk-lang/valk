
use valk:utils
use valk:json
use valk:thread
use valk:time
use build

class Lsp {
    buf: utils:ByteBuffer
    index: uint (0)
    stage: uint (0)
    headers: Map[String] (Map[String]{})
    data: json:Value (json:new_null())
    id: int (0)
    method: String ("")
    // Files
    file_content: Map[String] (Map[String]{})
    has_errors: Array[String] (Array[String]{})
    //
    file: String ("")
    line: uint (0)
    col: uint (0)
    //
    responded: bool (false)

    fn reset() {
        this.headers.clear()
        this.index = 0
        this.stage = 0
        this.data = json:new_null()
        this.id = 0
        this.method = ""
        this.responded = false
        //
        this.file = ""
        this.line = 0
        this.col = 0
    }

    fn parse() {

        while this.buf.length > 0 {
            if this.stage == 0 {
                this.parse_headers() ! {
                    if E == E.more : return
                    println("Invalid headers")
                    this.reset()
                    return
                }
            }
            if this.stage == 1 {
                this.parse_content() ! {
                    if E == E.more : return
                    println("Invalid content")
                    this.reset()
                    return
                }
            }

            this.handle()
            this.reset()
        }
    }

    fn parse_headers() !more !invalid {
        let buf = this.buf
        let data = buf.data
        let pos = this.index

        while true {
            let index = buf.index_of_byte('\r', pos) ! throw more
            if index == pos {
                // End of headers
                pos += 2
                break
            }

            // Read header
            let index2 = buf.index_of_byte(':', pos) ! throw invalid
            let nextch = buf.get(index + 1) ! throw more
            if index + 1 >= buf.length : throw more
            if (buf.get(index + 1) !? 0) != '\n' : throw invalid

            let key = buf.part(pos, index2 - pos).trim(" ").trim("\t")
            let value = buf.part(index2 + 1, index - index2 - 1).trim(" ").trim("\t")
            pos = index + 2
            this.index = pos

            log("Header: %key => %value")
            this.headers.set(key.lower(), value)
        }

        this.stage = 1
        this.buf.clear_until(pos)
        this.index = 0
    }

    fn parse_content() !more !invalid {
        log("Parse content")
        let len = (this.headers.get("content-length") !? "0").to_uint() ! throw invalid
        log("Content len: " + len)
        if this.buf.length < len : throw more
        let content = this.buf.part(0, len)
        this.buf.clear_until(len)

        let data = json:decode(content) ! {
            println("Invalid JSON-RPC input: " + content)
            throw invalid
        }

        this.data = data
    }

    fn handle() {
        let data = this.data

        let id = data.get("id").int()
        let method = data.get("method").string()
        let params = data.get("params")
        log("Method: " + method)

        this.id = id
        this.method = method

        if method == "initialize" {
            this.init(params)
        } else if method == "shutdown" {
        } else if method == "exit" {
            exit(0)
        } else if method == "textDocument/didOpen" {
            this.handle_open()
        } else if method == "textDocument/didClose" {
            this.handle_close()
        } else if method == "textDocument/didChange" {
            this.handle_change()
        } else if method == "textDocument/didSave" {
            this.handle_save()
        // } else if method == "textDocument/formatting" {
        } else if method == "textDocument/definition" {
            this.definition()
            this.send_empty_response()
        } else if method == "textDocument/completion" {
            this.completion()
            this.send_empty_response()
        } else if method == "textDocument/signatureHelp" {
            this.sighelp()
            this.send_empty_response()
        }
    }

    fn error(msg: String) {
        let resp = json:new_object()
        resp.set("id", json:new_int(this.id))
        resp.set("error", json:new_string(msg))
        this.respond(resp)
    }

    fn success(result: json:Value) {
        let resp = json:new_object()
        resp.set("id", json:new_int(this.id))
        resp.set("result", result)
        this.respond(resp)
    }

    fn send_empty_response() {
        let resp = json:new_object()
        resp.set("id", json:new_int(this.id))
        resp.set("result", json:new_object())
        this.respond(resp)
    }

    fn respond(data: json:Value) {
        if this.responded : return
        let content = data.encode(true)
        let resp = "Content-Length: " + (content.length + 1) + "\r\n"
        resp += "\r\n" + content
        println(resp)
        // print("'%resp'")
        this.responded = true
    }

    fn build() {
        let args = Array[String]{}

        let file = this.file
        if !file.is_empty() {
            args.push(file)
        }

        let b = build:init(args)
        b.lsp = this

        let t = co build:run(b)
        await t _
        this.send_errors(b)
    }

    fn send_errors(b: build:Build) {
        if !this.is_diag : return
        let errors = b.parse_errors
        let warnings = b.warnings

        let errors_per_fc = Map[Array[build:ParseError]]{}
        each errors as err {
            let fc = err.chunk.fc
            let list = errors_per_fc.get(fc.path) !? <{
                let list = Array[build:ParseError]{}
                errors_per_fc.set(fc.path, list)
                return list
            }
            list.push(err)
        }

        // Send errors
        each errors_per_fc as errors, path {
            this.send_errors_for_path(path, errors)
        }

        // Check previous error paths
        let new = Array[String]{}
        each this.has_errors as path {
            if errors_per_fc.has(path) {
                new.append(path)
                continue
            }
            this.send_errors_for_path(path, Array[build:ParseError]{})
        }
        this.has_errors = new

        // Add new error paths
        each errors_per_fc as errors, path {
            if !this.has_errors.contains(path) {
                this.has_errors.append(path)
            }
        }
    }

    fn send_errors_for_path(path: String, errors: Array[build:ParseError]) {

        let resp = json:new_object()
        let res = json:new_object()
        resp.set("method", json:new_string("textDocument/publishDiagnostics"))
        resp.set("params", res)

        // Result
        let diag = json:new_array()
        res.set("uri", "file://" + path)
        res.set("diagnostics", diag)

        //
        each errors as err {
            let item = json:new_object()
            let range = json:new_object()
            let pos = json:new_object()
            let pos2 = json:new_object()
            let chunk = err.chunk
            let chunk_end = err.chunk_end

            let sev = 1
            if err.type == build:err_type_warn : sev = 2

            item.set("severity", json:new_int(sev))
            item.set("message", json:new_string(err.msg))
            item.set("range", range)

            range.set("start", pos)
            range.set("end", pos2)

            pos.set("line", json:new_uint(chunk.line - 1))
            pos.set("character", json:new_uint(chunk.col - 1))
            pos2.set("line", json:new_uint(chunk_end.line - 1))
            pos2.set("character", json:new_uint(chunk_end.col - 1))

            diag.add(item)
        }

        this.respond(resp)
        this.responded = false
    }
}
