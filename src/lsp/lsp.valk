
use valk:utils
use valk:json
use valk:thread
use build

class Lsp {
    buf: utils:ByteBuffer
    index: uint (0)
    stage: uint (0)
    headers: Map[String] (Map[String]{})
    data: json:Value (json:new_null())
    id: int (0)
    method: String ("")
    // Files
    file_content: Map[String] (Map[String]{})
    //
    file: String ("")
    line: uint (0)
    col: uint (0)
    //
    responded: bool (false)

    fn reset() {
        this.headers.clear()
        this.buf.clear()
        this.index = 0
        this.stage = 0
        this.data = json:new_null()
        this.id = 0
        this.method = ""
        this.responded = false
        //
        this.file = ""
        this.line = 0
        this.col = 0
    }

    fn parse() {

        if this.stage == 0 {
            this.parse_headers() ! {
                if E == E.more : return
                log("Invalid headers")
                this.reset()
                return
            }
        }
        if this.stage == 1 {
            this.parse_content() ! {
                if E == E.more : return
                log("Invalid content")
                this.reset()
                return
            }
        }

        this.handle()
        this.reset()
    }

    fn parse_headers() !more !invalid {
        let buf = this.buf
        let data = buf.data
        let pos = this.index

        while true {
            let index = buf.index_of_byte('\r', pos) ! throw more
            if index == pos {
                // End of headers
                pos += 2
                break
            }

            // Read header
            let index2 = buf.index_of_byte(':', pos) ! throw invalid
            let nextch = buf.get(index + 1) ! throw more
            if index + 1 >= buf.length : throw more
            if (buf.get(index + 1) !? 0) != '\n' : throw invalid

            let key = buf.part(pos, index2 - pos).trim(" ").trim("\t")
            let value = buf.part(index2 + 1, index - index2 - 1).trim(" ").trim("\t")
            pos = index + 2
            this.index = pos

            log("Header: %key => %value")
            this.headers.set(key.lower(), value)
        }

        this.stage = 1
        log("Clear until: %pos")
        this.buf.clear_until(pos)
        this.index = 0
    }

    fn parse_content() !more !invalid {
        log("Parse content")
        let len = (this.headers.get("content-length") !? "0").to_uint() ! throw invalid
        log("Content len: " + len)
        if this.buf.length < len : throw more
        let content = this.buf.part(0, len)
        this.buf.clear_until(len)

        let data = json:decode(content) ! {
            log("Invalid JSON-RPC input: " + content)
            throw invalid
        }

        this.data = data
    }

    fn handle() {
        let data = this.data
        // println(data.encode(true))

        let id = data.get("id").int()
        let method = data.get("method").string()
        let params = data.get("params")
        log("Method: " + method)

        this.id = id
        this.method = method

        if method == "initialize" {
            this.init(params)
            return
        } else if method == "shutdown" {
        } else if method == "exit" {
            exit(0)
        } else if method == "textDocument/didOpen" {
            this.handle_open()
        } else if method == "textDocument/didClose" {
            this.handle_close()
        } else if method == "textDocument/didChange" {
            this.handle_change()
        } else if method == "textDocument/didSave" {
            this.handle_save()
        // } else if method == "textDocument/formatting" {
        } else if method == "textDocument/definition" {
            this.definition()
        } else if method == "textDocument/completion" {
            this.completion()
        } else if method == "textDocument/signatureHelp" {
            this.sighelp()
        } 

        this.send_empty_response()
    }

    fn error(msg: String) {
        let resp = json:new_object()
        resp.set("id", json:new_int(this.id))
        resp.set("error", json:new_string(msg))
        this.respond(resp)
    }

    fn success(result: json:Value) {
        let resp = json:new_object()
        resp.set("id", json:new_int(this.id))
        resp.set("result", result)
        this.respond(resp)
    }

    fn send_empty_response() {
        let resp = json:new_object()
        resp.set("id", json:new_int(this.id))
        resp.set("result", json:new_null())
        this.respond(resp)
    }

    fn respond(data: json:Value) {
        if this.responded : return
        let content = data.encode(true)
        let resp = "Content-Length: " + content.length + "\r\n"
        resp += "\r\n" + content
        println(resp)
        this.responded = true
    }

    fn build() {
        let t = co fn() {
            let args = Array[String]{ "--no-warn"}

            let file = this.file
            if !file.is_empty() {
                args.push(file)
            }

            let b = build:init(args)
            b.lsp = this
            build:run(b)
        }()

        await t ! return
    }

    fn send_errors(errors: Array[build:BuildError]) {

        let resp = json:new_object()
        let res = json:new_object()
        resp.set("id", json:new_int(this.id))
        resp.set("result", res)

        // Result
        let diag = json:new_array()
        res.set("uri", "file://" + this.file)
        res.set("diagnostics", diag)

        //
        each errors as err {
            let item = json:new_object()
            let range = json:new_object()
            let pos = json:new_object()
            let pos2 = json:new_object()
            let chunk = err.chunk
            if !isset(chunk) : continue
            let fc = chunk.fc
            if !isset(fc) : continue
            if fc.path != this.file : continue

            item.set("severity", json:new_int(1))
            item.set("message", json:new_string(err.msg))
            item.set("range", range)

            range.set("start", pos)
            range.set("end", pos2)

            pos.set("line", json:new_uint(chunk.line))
            pos.set("character", json:new_uint(chunk.col))
            pos2.set("line", json:new_uint(chunk.line))
            pos2.set("character", json:new_uint(chunk.col))

            diag.add(item)
        }

        this.respond(resp)
    }
}
