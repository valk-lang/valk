
use build
use valk:json

extend Lsp {
    fn definition() {
        let data = this.data
        let params = data.get("params")
        let doc = params.get("textDocument")
        let pos = params.get("position")
        let uri = doc.get("uri").string()
        if uri.is_empty() : return
        uri = uri.ltrim("file://")
        this.file = uri
        this.line = pos.get("line").int().to(uint)
        this.col = pos.get("character").int().to(uint)
        this.build()
    }

    fn check_definition(idf: build:Idf, name: String) {
        if !this.is_definition : return

        let chunk : ?build:Chunk = null
        if idf.for == build:idf_class {
            let class = idf.class
            if isset(class) {
                chunk = class.chunk
            }
        } else if idf.for == build:idf_func {
            let func = idf.func
            if isset(func) {
                chunk = func.chunk_args ?? func.chunk_body
            }
        } else if idf.for == build:idf_global {
            let g = idf.global
            if isset(g) {
                chunk = g.chunk_type
            }
        }

        if isset(chunk) {
            let fc = chunk.fc
            if isset(fc) {
                let resp = json:new_object()
                let res = json:new_object()
                resp.set("id", json:new_int(this.id))
                resp.set("result", res)

                let range = json:new_object()
                let pos = json:new_object()
                let pos2 = json:new_object()

                res.set("uri", "file://" + fc.path)
                res.set("range", range)

                range.set("start", pos)
                range.set("end", pos2)

                pos.set("line", json:new_uint(chunk.line))
                pos.set("character", json:new_uint(chunk.col))
                pos2.set("line", json:new_uint(chunk.line))
                pos2.set("character", json:new_uint(chunk.col))

                this.respond(res)
                cothrow stop_build
            }
        }
    }
}