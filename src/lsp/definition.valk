
use build
use valk:json

extend Lsp {
    fn definition() {
        let data = this.data
        let params = data.get("params")
        let doc = params.get("textDocument")
        let pos = params.get("position")
        let uri = doc.get("uri").string()
        if uri.is_empty() : return
        uri = uri.ltrim("file://")
        this.file = uri
        this.line = pos.get("line").int().to(uint) + 1
        this.col = pos.get("character").int().to(uint) + 1
        this.build()
    }

    fn check_definition(idf: build:Idf, name: String) {
        if !this.is_definition : return

        let chunk : ?build:Chunk = null
        if idf.for == build:idf_class {
            let class = idf.class
            if isset(class) {
                chunk = class.def_chunk
            }
        } else if idf.for == build:idf_func {
            let func = idf.func
            if isset(func) {
                chunk = func.def_chunk
            }
        } else if idf.for == build:idf_global {
            let g = idf.global
            if isset(g) {
                chunk = g.chunk_type
            }
        } else if idf.for == build:idf_trait {
            let t = idf.trait
            if isset(t) {
                chunk = t.chunk
            }
        }

        if isset(chunk) {
            this.send_def_chunk(chunk)
        }
    }

    fn check_func_definition(func: build:Func) {
        if !this.is_definition : return
        let chunk = func.def_chunk
        if isset(chunk) : this.send_def_chunk(chunk)
    }
    fn check_class_definition(class: build:Class) {
        if !this.is_definition : return
        let chunk = class.def_chunk
        if isset(chunk) : this.send_def_chunk(chunk)
    }
    fn check_prop_definition(prop: build:Prop) {
        if !this.is_definition : return
        let chunk = prop.def_chunk
        if isset(chunk) : this.send_def_chunk(chunk)
    }
    fn check_group_definition(group: build:Group) {
        if !this.is_definition : return
        let chunk = group.def_chunk
        if isset(chunk) : this.send_def_chunk(chunk)
    }

    fn send_def_chunk(chunk: build:Chunk) {
        let fc = chunk.fc
        let resp = json:new_object()
        let res = json:new_object()
        resp.set("id", json:new_int(this.id))
        resp.set("result", res)

        let range = json:new_object()
        let pos = json:new_object()
        let pos2 = json:new_object()

        res.set("uri", "file://" + fc.path)
        res.set("range", range)

        range.set("start", pos)
        range.set("end", pos2)

        pos.set("line", json:new_uint(chunk.line - 1))
        pos.set("character", json:new_uint(chunk.col - 1))
        pos2.set("line", json:new_uint(chunk.line - 1))
        pos2.set("character", json:new_uint(chunk.col - 1))

        this.respond(resp)
        cothrow stop_build
    }
}