
use build
use valk:json

class Completion {
    type: int
    label: String
    insert: ?String
    detail: ?String
}

extend Lsp {
    fn completion() {
        let data = this.data
        let params = data.get("params")
        let doc = params.get("textDocument")
        let pos = params.get("position")
        let uri = doc.get("uri").string()
        if uri.is_empty() : return
        uri = uri.ltrim("file://")
        this.file = uri
        this.line = pos.get("line").int().to(uint)
        this.col = pos.get("character").int().to(uint)
        this.build()
    }

    fn check_completion_scope(scope: build:Scope, name: String) {
        if !this.is_completion : return

        let scope_fc = scope.find_type(build:sc_fc) ! return
        let idf = scope_fc.identifiers.get(name) ! return
        if idf.for != build:idf_scope : return
        let s = idf.scope
        if !isset(s) : return

        let list = Array[Completion]{}
        each s.identifiers as v, k {
            list.append(Completion {
                type: type_for_idf(v)
                label: k
            })
        }

        this.send_completion(list)
    }

    fn check_completion_namespace(pkc: build:Pkc) {
        if !this.is_completion : return

        let cfg = pkc.config
        if !isset(cfg) : return
        let spaces = cfg.json.get("namespaces").map()

        let list = Array[Completion]{}
        each spaces as space, name {
            list.append(Completion {
                type: lsp_type_module
                label: name
            })
        }

        this.send_completion(list)
    }

    fn check_completion_on_class(class: build:Class) {
        let list = Array[Completion]{}
        let funcs = class.get_funcs()
        let props = class.get_props()
        each funcs as item, name {
            list.append(Completion {
                type: lsp_type_function
                label: name
            })
        }
        each props as item, name {
            list.append(Completion {
                type: lsp_type_property
                label: name
            })
        }
        this.send_completion(list)
    }
    fn check_completion_on_group(group: build:Group) {
        let list = Array[Completion]{}
        each group.funcs as item, name {
            list.append(Completion {
                type: lsp_type_function
                label: name
            })
        }
        this.send_completion(list)
    }
    fn check_completion_on_enum(e: build:Enum) {
        let list = Array[Completion]{}
        each e.item_chunks as item, name {
            list.append(Completion {
                type: lsp_type_text
                label: name
            })
        }
        this.send_completion(list)
    }
    fn check_completion_simple(items: Array[String]) {
        let list = Array[Completion]{}
        each items as item {
            list.append(Completion {
                type: lsp_type_text
                label: item
            })
        }
        this.send_completion(list)
    }

    fn send_completion(list: Array[Completion]) {

        let res = json:new_object()
        let items = json:new_array()

        res.set("isIncomplete", json:new_bool(false))
        res.set("items", items)

        each list as li {
            let insert = li.insert
            let detail = li.detail

            let item = json:new_object()
            item.set("kind", json:new_int(li.type))
            item.set("label", json:new_string(li.label))

            if isset(detail) {
                let d = json:new_object()
                item.set("labelDetails", d)
                d.set("detail", json:new_string(detail))
            }

            if isset(insert) : item.set("insertText", json:new_string(insert))
            if li.type == lsp_type_method || li.type == lsp_type_function : item.set("insertTextFormat", json:new_int(2))

            items.add(item)
        }

        this.success(res)
    }
}
