
use valk:mem

fn ctxhash(content: String) String {

    let data = content.data_ptr()
    let len: u8 = 32
    let buf = mem:calloc(len @as uint)

    let dpos: uint = 0
    let rpos: u8 = 0
    let diff: u8 = 0

    let end = false

    while true {
        let ch = @ptrv(data, u8, dpos++)
        if ch == 0 {
            end = true
            dpos = 0
            continue
        }

        diff += (ch + dpos @as u8) * 21 + rpos
        @ptrv(buf, u8, rpos++) = ch + diff

        if rpos == len {
            if end : break
            rpos = 0
        }
    }

    let mix = "TMpUivZnQsHw1klS3Ah5d6qr7tjKxJOIEmYP8VgGzcDR0f2uBe4aobWLNCFy9X".data_ptr()

    let i = len
    while i-- > 0 {
        let ch = @ptrv(buf, u8, i)
        diff += (ch + i) * 11 + i
        @ptrv(buf, u8, i) = @ptrv(mix, u8, (ch + diff) % 62)
    }

    return String.make_from_ptr(buf, len)

    // unsigned char *content = (unsigned char *)content_;
    // unsigned char *buf = (unsigned char *)buf_;

    // const int hash_len = 32;

    // memset(buf, '\0', hash_len);

    // int res_pos = 0;
    // int str_pos = 0;
    // unsigned char diff = 0;

    // bool end = false;

    // while (true) {
    //     unsigned char str_ch = content[str_pos++];
    //     if (str_ch == '\0') {
    //         end = true;
    //         str_pos = 0;
    //         continue;
    //     }

    //     diff += (str_ch + str_pos) * 0b00010101 + res_pos;
    //     buf[res_pos++] += str_ch + diff;

    //     if (res_pos == hash_len) {
    //         if (end)
    //             break;
    //         res_pos = 0;
    //     }
    // }

    const char *chars = "TMpUivZnQsHw1klS3Ah5d6qr7tjKxJOIEmYP8VgGzcDR0f2uBe4aobWLNCFy9X";

    int i = hash_len;
    while (i-- > 0) {
        const unsigned char str_ch = buf[i];
        diff += (str_ch + i) * 0b0001011 + i;
        buf[i] = chars[(str_ch + diff) % 62];
    }
    buf[hash_len] = '\0';
}