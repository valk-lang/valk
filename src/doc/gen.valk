
use build
use valk:json
use valk:fs

fn doc_gen(b: build:Build) {
    let cli = b.cli
    let no_private = cli.flags.contains("--no-private")

    let doc = json:new_object()
    let spaces = json:new_object()
    doc.set("namespaces", spaces)

    let pkc = b.nsc_main().pkc
    let fake_func = build:Func {
        unit: b.units.get(0) ! panic("Missing build unit")
        build: b
        fc: b.generated_fc()
        parse_fc: b.generated_fc()
        name: "fake"
        export_name: "fake"
        display_name: "fake"
        rett: build:type_void(b)
        arg_scope: build:Scope.new(build:sc_func)
        act: 0
    }
    fake_func.init_ast_scope()

    each pkc.namespaces as nsc, name {
        let space = json:new_object()
        spaces.set(name, space)

        let classes = json:new_object()
        let funcs = json:new_object()
        let globals = json:new_object()
        space.set("classes", classes)
        space.set("functions", funcs)
        space.set("globals", globals)

        let u = nsc.default_unit

        each u.classes as class {
            if no_private && build:act_is_private(class.act) : continue
            if !class.gen_docs : continue
            let gnames = class.generic_names

            let c = json:new_object()
            classes.set(class.name, c)
            let props = json:new_object()
            let funcs = json:new_object()
            c.set("act", jact(class.act))
            c.set("properties", props)
            c.set("functions", funcs)
            let mode_for = class.mode_for_class
            if isset(mode_for) {
                c.set("mode_for", json:new_string(mode_for.get_type()))
            }
            if isset(gnames) {
                let arr = Array[json:Value]{}
                each gnames as gname : arr.push(json:new_string(gname.name))
                c.set("generics", json:new_array(arr))
            }

            each class.get_props() as prop, name, i {
                if no_private && build:act_is_private(prop.act) : continue
                if i == 0 && name == "_VTABLE" : continue
                let p = json:new_object()
                p.set("type", json:new_string(prop.type))
                p.set("act", jact(prop.act))
                props.set(prop.name, p)
            }
            each class.funcs as func {
                if no_private && build:act_is_private(func.act) : continue
                jfunc(funcs, func, fake_func)
            }
        }

        each u.functions as func {
            let class = func.class
            if isset(class) : continue
            if no_private && build:act_is_private(func.act) : continue
            jfunc(funcs, func, fake_func)
        }

        each u.globals as g {
            if no_private && build:act_is_private(g.act) : continue
            let gl = json:new_object()
            globals.set(g.name, gl)
            gl.set("act", jact(g.act))
            gl.set("type", json:new_string(g.type))
            gl.set("shared", json:new_bool(g.shared))
        }
    }

    let json = doc.encode(true)
    // Output
    let is_markdown = cli.flags.contains("--markdown")
    let output = json
    if is_markdown : output = convert_to_markdown(b, doc)

    // Write output
    let outpath = cli.get_first_values_for("-o") !? null
    if isset(outpath) {
        let ext = is_markdown ? ".md" : ".json"
        outpath = outpath.rtrim(".exe")
        if !outpath.ends_with(ext) : outpath += ".doc" + ext
        fs:write(outpath, output) ! panic("Failed to write file: " + outpath)
    } else {
        println(output)
    }
}

fn jact(act: int) json:Value {
    let str = build:act_to_str_all(act)
    return json:new_string(str)
}

fn jfunc(funcs: json:Value, func: build:Func, fake_func: build:Func) {
    if !func.gen_docs : return

    let f = json:new_object()
    funcs.set(func.name, f)

    let gnames = func.generic_names
    if isset(gnames) {
        let arr = Array[json:Value]{}
        each gnames as gname : arr.push(json:new_string(gname.name))
        f.set("generics", json:new_array(arr))
    }


    f.set("act", jact(func.act))
    f.set("is_static", json:new_bool(func.is_static))
    let class = func.class
    
    let args = Array[json:Value]{}
    each func.args as arg, i {
        if i == 0 && isset(class) && !func.is_static : continue
        let a = json:new_object()
        args.push(a)
        a.set("name", json:new_string(arg.name))
        a.set("type", json:new_string(arg.type))

        let default_chunk = arg.chunk_value
        if isset(default_chunk) {
            let p = build:Parser.new(default_chunk, null)
            p.suggest_type = arg.type
            p.func_ = fake_func
            let scope = fake_func.fast().scope
            scope.parent_idf = func.arg_scope
            let v = build:read_value(p, scope)
            a.set("default-value", jval(v))
        }
    }

    f.set("arguments", json:new_array(args))
    f.set("return-type", json:new_string(func.rett))

    let errors = Array[json:Value]{}
    each func.errors as err, name {
        errors.push(json:new_string(name))
    }
    f.set("errors", json:new_array(errors))
}

fn jval(v: build:Value) json:Value {
    return json:new_string(v.to_str() !? "...")
}
