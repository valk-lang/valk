
use build
use valk:json
use valk:fs

fn doc_gen(b: build:Build) {
    let cli = b.cli
    let no_private = cli.flags.contains("--no-private")

    let doc = json:object()
    let spaces = json:object()
    doc.set("namespaces", spaces)

    let pkc = b.nsc_main().pkc
    let fake_func = build:Func {
        unit: b.units.get(0) ! panic("Missing build unit")
        build: b
        fc: null
        name: "fake"
        export_name: "fake"
        display_name: "fake"
        rett: build:type_void(b)
        arg_scope: build:Scope.new(build:sc_func)
        act: 0
    }
    fake_func.init_ast_scope()

    each pkc.namespaces as nsc, name {
        let space = json:object()
        spaces.set(name, space)

        let classes = json:object()
        let funcs = json:object()
        let globals = json:object()
        space.set("classes", classes)
        space.set("functions", funcs)
        space.set("globals", globals)

        let u = nsc.default_unit

        each u.classes as class {
            if no_private && build:act_is_private(class.act) : continue
            let c = json:object()
            classes.set(class.name, c)
            let props = json:object()
            let funcs = json:object()
            c.set("act", jact(class.act))
            c.set("properties", props)
            c.set("functions", funcs)

            each class.get_props() as prop, name, i {
                if no_private && build:act_is_private(prop.act) : continue
                if i == 0 && name == "_VTABLE" : continue
                let p = json:object()
                p.set("type", json:string(prop.type))
                p.set("act", jact(prop.act))
                props.set(prop.name, p)
            }
            each class.get_funcs() as func {
                if no_private && build:act_is_private(func.act) : continue
                jfunc(funcs, func, fake_func)
            }
        }

        each u.functions as func {
            let class = func.class
            if isset(class) : continue
            if no_private && build:act_is_private(func.act) : continue
            jfunc(funcs, func, fake_func)
        }

        each u.globals as g {
            if no_private && build:act_is_private(g.act) : continue
            let gl = json:object()
            globals.set(g.name, gl)
            gl.set("act", jact(g.act))
            gl.set("type", json:string(g.type))
            gl.set("shared", json:bool(g.shared))
        }
    }

    let json = doc.encode(true)
    // Output
    let is_markdown = cli.flags.contains("--markdown")
    let output = json
    if is_markdown : output = convert_to_markdown(b, doc)

    // Write output
    let outpath = cli.get_first_values_for("-o") !? null
    if isset(outpath) {
        let ext = is_markdown ? ".md" : ".json"
        outpath = outpath.rtrim(".exe")
        if !outpath.ends_with(ext) : outpath += ".doc" + ext
        fs:write(outpath, output) ! panic("Failed to write file: " + outpath)
    } else {
        println(output)
    }
}

fn jact(act: int) json:Value {
    let str = build:act_to_str_all(act)
    return json:string(str)
}

fn jfunc(funcs: json:Value, func: build:Func, fake_func: build:Func) {
    let f = json:object()
    funcs.set(func.name, f)
    f.set("act", jact(func.act))
    f.set("is_static", json:bool(func.is_static))
    let class = func.class
    
    let args = array[json:Value]{}
    each func.args as arg, i {
        if i == 0 && isset(class) && !func.is_static : continue
        let a = json:object()
        args.push(a)
        a.set("name", json:string(arg.name))
        a.set("type", json:string(arg.type))

        let default_chunk = arg.chunk_value
        if isset(default_chunk) {
            let p = build:Parser.new(default_chunk, null)
            p.suggest_type = arg.type
            p.func_ = fake_func
            let scope = fake_func.fast().scope
            scope.parent_idf = func.arg_scope
            let v = build:read_value(p, scope)
            a.set("default-value", jval(v))
        }
    }

    f.set("arguments", json:array(args))
    f.set("return-type", json:string(func.rett))
}

fn jval(v: build:Value) json:Value {
    return json:string(v.to_str() !? "...")
}
