
use valk:time 
use valk:gc 

global keep: ?Node (null)
global amount: uint (10_000_000)

class Node {
    next: ?Node

    fn verify() uint {
        let n : ?Node = this
        let c : uint = 0
        while isset(n) {
            n = n.next
            c++
        }
        return c
    }
}

fn gen(amount: uint) Node {
    let i : uint = 0
    let prev = Node {}
    let first = prev
    while i++ < amount {
        let n = Node {}
        prev.next = n
        prev = n
    }
    return first
}

fn create_objects() {
    let first = gen(0)
    let start = time:microtime()
    let i = amount
    while i-- > 0 {
        let n = gen(0)
    }
    let elapsed = time:microtime() - start

	println("Created %amount objects in %{ elapsed / 1000 } ms")
	println("Verify: " + first.verify())
	println("Memory usage: " + gc:mem_usage_thread / 1024)
}

fn longlived_objects() {
    let first = gen(0)
    let last = first
    let start = time:microtime()
    let i = amount
    while i-- > 0 {
        let n = gen(0)
        last.next = n
        last = n
    }
    let elapsed = time:microtime() - start
    keep = first

	println("Created %amount objects in %{ elapsed / 1000 } ms")
	println("Verify: " + first.verify())
	println("Memory usage: %{ gc:mem_usage_thread / 1024 } KB")
}

fn verify_keep() uint {
    let k = keep
    if isset(k) : return k.verify()
    return 0
}

fn free_objects() {
    let check = verify_keep()
    let start = time:microtime()
    keep = null
    gc:collect()
    gc:collect()
    let elapsed = time:microtime() - start

	println("Free %amount objects in %{ elapsed / 1000 } ms")
	println("Verify: " + check)
	println("Memory usage: %{ gc:mem_usage_thread / 1024 } KB")
}

fn main() {
    print("\n")
    create_objects()
    print("\n")
    longlived_objects()
    print("\n")
    free_objects()
    print("\n")
}