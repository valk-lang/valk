diff --git a/lib/src/gc/gc-local.valk b/lib/src/gc/gc-local.valk
index babeaf9..49c3b4e 100644
--- a/lib/src/gc/gc-local.valk
+++ b/lib/src/gc/gc-local.valk
@@ -72,6 +72,7 @@ struct GcLocal {
 
         if this.disable : return
         this.disable = true
+println("-")
 
         // 
         this.loop_stack_items(GcLocal.mark_on_stack)
diff --git a/lib/src/gc/marking.valk b/lib/src/gc/marking.valk
index d318d24..6a35742 100644
--- a/lib/src/gc/marking.valk
+++ b/lib/src/gc/marking.valk
@@ -1,13 +1,37 @@
 
 global mark_list : Lifo (@undefined)
 
+// macro array optional("[" s T:t1 s "]") "{" repeat(items, ws V:v1 ws optional(",") ws, "}")
+// {
+// }
+
+fn adjust_block(item: ptr, used: bool) {
+    let data = (@offset(item, u8, -8)).@cast(GcData)
+    let offset = data.block_offset
+    let block = item - offset
+    let total = @ptrv(block, uint, 1)
+    let isize = @ptrv(block, uint, 4)
+    let index = (offset - 8 - total - POOL_DATA_OFFSET) / isize
+
+    if used {
+        @ptrv(block, uint, 2)++
+        @ptrv(block, u8, index + POOL_DATA_OFFSET) = 1
+        mem_marked += @ptrv(block, uint, 4)
+    } else {
+        @ptrv(block, uint, 2)--
+        @ptrv(block, u8, index + POOL_DATA_OFFSET) = 0
+        mem_marked -= @ptrv(block, uint, 4)
+    }
+}
+
 fn increase_block(item: ptr) $hot {
     let data = (@offset(item, u8, -8)).@cast(GcData)
     let offset = data.block_offset
     if offset > 0 {
-        let block = item - offset
-        @ptrv(block, uint, 2)++ // Increase block items-used
-        mem_marked += @ptrv(block, uint, 4)
+        adjust_block(item, true)
+        // let block = item - offset
+        // @ptrv(block, uint, 2)++ // Increase block items-used
+        // mem_marked += @ptrv(block, uint, 4)
     }
 }
 
@@ -29,9 +53,10 @@ fn mark_used(item: ptr) $hot {
             // New item
             let offset = data.block_offset
             if offset > 0 {
-                let block = item - offset
-                @ptrv(block, uint, 2)++ // Increase block items-used
-                mem_marked += @ptrv(block, uint, 4)
+                // let block = item - offset
+                // @ptrv(block, uint, 2)++ // Increase block items-used
+                // mem_marked += @ptrv(block, uint, 4)
+                adjust_block(item, true)
             }
         }
 
@@ -95,9 +120,10 @@ fn disconnect_rec(item: ptr) $hot {
         let offset = data.block_offset
 
         if offset > 0 {
-            let block = item - offset
-            @ptrv(block, uint, 2)-- // Reduce block items-used
-            mem_marked -= @ptrv(block, uint, 4)
+            // let block = item - offset
+            // @ptrv(block, uint, 2)-- // Reduce block items-used
+            // mem_marked -= @ptrv(block, uint, 4)
+            adjust_block(item, false)
         }
 
         data.state = state_new
@@ -184,9 +210,15 @@ fn share(item: ptr) {
                 // New item
                 let offset = data.block_offset
                 if offset > 0 {
-                    let block = item - offset
-                    @ptrv(block, uint, 2)++ // Increase block items-used
-                    mem_marked += @ptrv(block, uint, 4)
+                    // let block = item - offset
+                    // @ptrv(block, uint, 2)++ // Increase block items-used
+                    // let total = @ptrv(block, uint, 1)
+                    // let isize = @ptrv(block, uint, 4)
+                    // let index = (offset - total - POOL_DATA_OFFSET - 8) / isize
+                    // @ptrv(block, u8, index + POOL_DATA_OFFSET) = 1
+
+                    // mem_marked += @ptrv(block, uint, 4)
+                    adjust_block(item, true)
                 }
             }
         }
diff --git a/lib/src/gc/pool.valk b/lib/src/gc/pool.valk
index 15f5f47..d95d336 100644
--- a/lib/src/gc/pool.valk
+++ b/lib/src/gc/pool.valk
@@ -89,8 +89,8 @@ struct Pool {
     blockc: uint
     first: ptr
     block: ptr
-    item_adr: ptr (null.@cast(ptr))
-    item_adr_last: ptr (null.@cast(ptr))
+    index: uint (0)
+    item_count: uint (0)
     isize: uint (0)
 
     + static fn init(size: uint) Pool {
@@ -106,20 +106,24 @@ struct Pool {
     }
 
     static fn create_block(size: uint, isize: uint) ptr {
-        let max: uint = 65400 / isize
+        let max: uint = 65000 / isize
         if max > 248 : max = 248
         if size > max : size = max
         if size == 0 : size = 1
-        let b = mem:alloc(size * isize + POOL_DATA_OFFSET)
+        let size_rounded = size.round_up(size_of(ptr))
+        let b = mem:alloc(size * isize + POOL_DATA_OFFSET + size_rounded)
         // Settings
         @ptrv(b, ?ptr, 0) = null // next block
         @ptrv(b, uint, 1) = size // count
         @ptrv(b, uint, 2) = 0 // items used
         @ptrv(b, uint, 3) = 0 // usage percent
         @ptrv(b, uint, 4) = isize // item size
-        // Set indexes
-        let data = b + POOL_DATA_OFFSET
-        let base_offset = POOL_DATA_OFFSET + 8
+        // Clear used boxes
+        let used_list = b + POOL_DATA_OFFSET
+        mem:clear(used_list, size)
+        // Set offsets
+        let data = used_list + size_rounded
+        let base_offset : uint = data - b + 8
         let i : uint = 0
         while i < size {
             let offset = i * isize
@@ -155,21 +159,32 @@ struct Pool {
             this.set_block(block)
         }
 
+        let index = this.index
+        let item_count = this.item_count
+        let block = this.block
         while true {
-            let item_adr = this.item_adr
-            if item_adr > this.item_adr_last {
-                this.set_next_block(this.block)
+            let item_count = this.item_count
+            if index == item_count {
+                this.set_next_block(block)
+                index = 0
+                item_count = this.item_count
+                block = this.block
                 continue
             }
-            this.item_adr = item_adr + isize
+            index++
 
-            let data = item_adr.@cast(GcData)
-            if data.state != state_new : continue
+            let used_list = block + POOL_DATA_OFFSET 
+            let used_box = used_list + index
+            if @ptrv(used_box, u8) != 0 : continue
+
+            this.index = index
+
+            let item = used_list + item_count.round_up(size_of(ptr)) + (index * isize)
 
             // Increase mem usage
             mem_new += isize
 
-            return item_adr + 8
+            return item + 8
         }
 
         panic("Failed to allocate memory")
@@ -203,8 +218,8 @@ struct Pool {
 
     fn set_block(block: ptr) {
         this.block = block
-        this.item_adr = block + POOL_DATA_OFFSET
-        this.item_adr_last = this.item_adr + ((@ptrv(block, uint, 1) - 1) * this.isize)
+        this.index = 0
+        this.item_count = @ptrv(block, uint, 1)
     }
 
     fn reset() {
